{
  "examples": [
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"task_processor\")\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    data: Dict[str, Any]\n    completed: bool = False\n    result: Optional[Any] = None\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: List[Task] = []\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task {task.id}: {task.name}\")\n        \n    def process_task(self, task: Task) -> Task:\n        logger.info(f\"Processing task {task.id}: {task.name}\")\n        try:\n            # Simulate work\n            processing_time = 1 + random.random() * 2\n            time.sleep(processing_time)\n            \n            # Process based on task data\n            if \"multiply\" in task.data:\n                task.result = task.data[\"multiply\"][0] * task.data[\"multiply\"][1]\n            elif \"concat\" in task.data:\n                task.result = \"\".join(task.data[\"concat\"])\n            else:\n                task.result = f\"Processed {task.name}\"\n                \n            task.completed = True\n            logger.info(f\"Completed task {task.id} in {processing_time:.2f}s\")\n        except Exception as e:\n            logger.error(f\"Error processing task {task.id}: {e}\")\n        return task\n        \n    def process_all(self) -> List[Task]:\n        # Sort tasks by priority (higher number = higher priority)\n        sorted_tasks = sorte",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n    \n    def get_task(self, task",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        logger.info(\"Task Manager initialized\")\n    \n    def add_task(self, task: Task) -> bool:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists\")\n            return False\n        \n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return True\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task_status(self, task_id: int, status: TaskStatus) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            logger.error(f\"Task with ID {task_id} not found\")\n            return False\n        \n        task.status = status\n        logger.info(f\"Updated task {task.name} status to {status.name}\")\n        return True\n    \n    def get_executable_tasks(self) -> List[Task]:\n        result = []\n        for task in self.tasks.values():\n            if task.status == TaskStatus.PENDING:\n                dependencies_met = all(\n                    self.",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_system\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int = 0\n    categories: List[str] = field(default_factory=list)\n    \n    def is_in_stock(self) -> bool:\n        return self.quantity > 0\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"price\": self.price,\n            \"quantity\": self.quantity,\n            \"categories\": self.categories\n        }\n\nclass InventoryManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.products: Dict[str, Product] = {}\n        self.storage_path = storage_path or Path(\"inventory.json\")\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product {product.id} already exists, updating instead\")\n        self.products[product.id] = product\n        logger.info(f\"Added/updated product: {product.name}\")\n        \n    def remove_product(self, product_id: str) -> bool:\n        if product_id in self.products:\n            del self.products[product_id]\n            logger.info(f\"Removed product with ID: {product_id}\")\n            return True\n        logger.warning(f\"Cannot remove: Product {product_id} not found\")\n        return False\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products.values() if category in p.categories]\n    \n    def save_to_file(self",
    "import time\nfrom functools import wraps\nfrom typing import Callable, Dict, List, Optional, TypeVar, Any\n\nT = TypeVar('T')\n\n# Cache decorator with expiration\ndef cached(expiry_seconds: int = 60):\n    cache: Dict[str, Dict[str, Any]] = {}\n    \n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> T:\n            # Create a cache key from the function name and arguments\n            key = f\"{func.__name__}:{str(args)}:{str(kwargs)}\"\n            \n            # Check if result is cached and not expired\n            if key in cache:\n                entry = cache[key]\n                if time.time() - entry['timestamp'] < expiry_seconds:\n                    return entry['result']\n            \n            # Call the function and cache the result\n            result = func(*args, **kwargs)\n            cache[key] = {\n                'result': result,\n                'timestamp': time.time()\n            }\n            return result\n        \n        # Add a method to clear the cache\n        wrapper.clear_cache = lambda: cache.clear()\n        return wrapper\n    \n    return decorator\n\nclass DataProcessor:\n    def __init__(self, name: str):\n        self.name = name\n        self.processed_count = 0\n    \n    @cached(expiry_seconds=30)\n    def process_data(self, data: List[int], factor: int = 2) -> List[int]:\n        \"\"\"Process the input data with the given factor.\"\"\"\n        print(f\"Processing data with factor {factor}...\")\n        time.sleep(1)  # Simulate processing time\n        self.processed_count += 1\n        return [item * factor for item in data]\n\n# Example usage\nif __name__ == \"__main__\":\n    processor = DataProcessor(\"MainProcessor\")\n    \n    # First call - will execute the function\n    result1 = processor.process_data([1, 2, 3, 4, 5])\n    print(f\"Result 1: {result1}\")",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags or [],\n            \"due_date\": self.due_date\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def complete_task(self, task_id: str) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                logger.info(f\"Marked task as completed: {task.name}\")\n                self.save_tasks()\n                return True\n        return False\n    \n    def get_tasks_by_priority(self, min_priority: int = 0) -> List[Task]:\n        return sorted(\n            [t for t in self.tasks if t.priority >= min_priority and not t.completed],\n            key=lambda x: x.priority,\n            reverse=True\n        )\n    \n    def save_tasks(self) -> None",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'tags': self.tags or []\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t['id'],\n                    title=t['title'],\n                    description=t['description'],\n                    completed=t['completed'],\n                    created_at=datetime.fromisoformat(t['created_at']),\n                    tags=t.get('tags', [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks:",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        if not self.due_date or self.completed:\n            return False\n        return datetime.now() > self.due_date\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        \n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):",
    "import logging\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom typing import Dict, List, Optional\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass ItemType(Enum):\n    WEAPON = auto()\n    ARMOR = auto()\n    POTION = auto()\n    TREASURE = auto()\n\n@dataclass\nclass Item:\n    name: str\n    item_type: ItemType\n    value: int\n    weight: float\n    \n    def __str__(self) -> str:\n        return f\"{self.name} ({self.item_type.name}): {self.value} gold, {self.weight} kg\"\n\nclass Inventory:\n    def __init__(self, capacity: float = 100.0):\n        self.items: List[Item] = []\n        self.capacity = capacity\n        \n    def add_item(self, item: Item) -> bool:\n        current_weight = self.total_weight()\n        if current_weight + item.weight <= self.capacity:\n            self.items.append(item)\n            logger.info(f\"Added {item.name} to inventory\")\n            return True\n        logger.warning(f\"Cannot add {item.name}: exceeds capacity\")\n        return False\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name.lower() == item_name.lower():\n                removed = self.items.pop(i)\n                logger.info(f\"Removed {removed.name} from inventory\")\n                return removed\n        logger.warning(f\"Item {item_name} not found in inventory\")\n        return None\n    \n    def total_weight(self) -> float:\n        return sum(item.weight for item in self.items)\n    \n    def total_value(self) -> int:\n        return sum(item.value for item in self.items)",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum, auto\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    completion_time: Optional[float] = None\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"Task Manager initialized\")\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n    \n    def get_next_task(self) -> Optional[Task]:\n        pending_tasks = [t for t in self.tasks if t.status == TaskStatus.PENDING]\n        if not pending_tasks:\n            return None\n        return max(pending_tasks, key=lambda x: x.priority)\n    \n    def process_tasks(self, max_tasks: int = 5) -> None:\n        processed = 0\n        while processed < max_tasks:\n            task = self.get_next_task()\n            if not task:\n                logger.info(\"No pending tasks available\")\n                break\n            \n            try:\n                logger.info(f\"Processing task: {task.name}\")\n                task.status = TaskStatus.IN_PROGRESS\n                \n                # Simulate work with random success/failure\n                time.sleep(0.1)  # Reduced for faster execution\n                if random.random() < 0.8:  # 80% success rate\n                    task.status = TaskStatus.COMPLETED\n                    task.completion_time = time.",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        self.tasks[task_name].completed = True\n        logger.info(f\"Completed task: {task_name}\")\n        self.save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[str] = None\n\n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags or [],\n            \"due_date\": self.due_date\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (Priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n        \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].complete()\n            logger.info(f\"Completed task: {task_name}\")\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_priority(self, min_priority: int = 0) -> List[Task]:\n        return [task for task in self.tasks.values() \n                if task.priority >= min_priority and not task.",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task with ID: {task_id}\")\n            return True\n        return False\n    \n    def list_tasks(self, tag_filter: Optional[str] = None) ->",
    "import logging\nimport json\nimport os\nfrom dataclasses import dataclass, field, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport argparse\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: str = field(default_factory=lambda: datetime.now().isoformat())\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_dict = json.load(f)\n                    for name, task_data in tasks_dict.items():\n                        self.tasks[name] = Task(**task_data)\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, IOError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n\n    def save_tasks(self) -> None:\n        try:\n            tasks_dict = {name: asdict(task) for name, task in self.tasks.items()}\n            with open(self.storage_path, \"w\") as f:\n                json.dump(tasks_dict, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except IOError as e:\n            logger.",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(\"No existing task file found\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_file, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return self.due_date and not self.completed and self.due_date < datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=",
    "import csv\nimport os\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_expense: bool = True\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str = \"expenses.csv\"):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n    \n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            return\n            \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.fromisoformat(row['date']),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description'],\n                    is_expense=row['is_expense'].lower() == 'true'\n                ))\n    \n    def save_data(self) -> None:\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['date', 'amount', 'category', 'description', 'is_expense'])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.isoformat(),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description,\n                    'is_expense': str(t.is_expense)\n                })\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self.save_data()\n    \n    def get_summary_by_category(self) -> Dict[str, float]:\n        summary = {}\n        for t in self.transactions:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'due_date': self.due_date.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Task':\n        return cls(\n            id=data['id'],\n            title=data['title'],\n            description=data['description'],\n            due_date=datetime.fromisoformat(data['due_date']),\n            completed=data['completed'],\n            tags=data['tags']\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                self.save_tasks()",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    filename: str\n    size_bytes: int\n    last_modified: float\n    is_directory: bool\n    \n    @property\n    def size_kb(self) -> float:\n        return self.size_bytes / 1024\n    \n    def __str__(self) -> str:\n        file_type = \"Directory\" if self.is_directory else \"File\"\n        return f\"{file_type}: {self.filename} - {self.size_kb:.2f} KB\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions\n        self.stats: List[FileStats] = []\n        \n    def analyze_file(self, filepath: str) -> Optional[FileStats]:\n        try:\n            # Simulate work\n            time.sleep(random.uniform(0.01, 0.05))\n            \n            is_dir = os.path.isdir(filepath)\n            stats = os.stat(filepath)\n            return FileStats(\n                filename=os.path.basename(filepath),\n                size_bytes=stats.st_size,\n                last_modified=stats.st_mtime,\n                is_directory=is_dir\n            )\n        except Exception as e:\n            logger.error(f\"Error analyzing {filepath}: {e}\")\n            return None\n    \n    def scan(self, use_threads: bool = True) -> List[FileStats]:\n        if not os.path.exists(self.root_dir):\n            logger.error(f\"Directory {self.root_dir} does not exist\")\n            return []",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) \n                            if task_data",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: Optional[str] = None) -> Task:\n        parsed_date = datetime.fromisoformat(due_date) if due_date else None\n        task = Task(id=self.next_id, title=title, description=description, due_date=parsed_date)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def get_all_tasks(self) -> List[Task]:\n        return list(self.tasks.values())\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.id}: {self.name} (priority: {self.priority})\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return sorted(\n            [task for task in self.tasks if not task.completed],\n            key=lambda x: x.priority,\n            reverse=True\n        )\n    \n    def get_random_task(self) ->",
    "import json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5 scale\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if not 1 <= self.priority <= 5:\n            raise ValueError(\"Priority must be between 1 and 5\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks:",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        next_id = len(self.tasks) + 1\n        task = Task(id=next_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            logger.info(f\"Deleted task {task_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\nclass WeatherType(Enum):\n    SUNNY = auto()\n    CLOUDY = auto()\n    RAINY = auto()\n    SNOWY = auto()\n\n@dataclass\nclass DailyWeather:\n    day: int\n    temperature: float\n    weather_type: WeatherType\n    precipitation_chance: float\n\nclass WeatherSimulator:\n    def __init__(self, days: int, starting_temp: float = 20.0):\n        self.days = days\n        self.current_temp = starting_temp\n        self.weather_data: List[DailyWeather] = []\n        \n    def simulate(self) -> List[DailyWeather]:\n        logger.info(f\"Starting weather simulation for {self.days} days\")\n        \n        for day in range(1, self.days + 1):\n            # Temperature varies by up to 5 degrees from previous day\n            self.current_temp += random.uniform(-5, 5)\n            # Keep temperature in reasonable range\n            self.current_temp = max(min(self.current_temp, 40), -10)\n            \n            # Select weather type with some continuity\n            weather_types = list(WeatherType)\n            if day > 1 and random.random() < 0.7:\n                # 70% chance to have similar weather as previous day\n                prev_weather = self.weather_data[-1].weather_type\n                weather_type = random.choice([\n                    prev_weather, \n                    random.choice(weather_types)\n                ])\n            else:\n                weather_type = random.choice(weather_types)\n            \n            # Calculate precipitation chance based on weather type\n            if weather_type == WeatherType.SUNNY:\n                precip_chance = random.uniform(0",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_manager\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int\n    tags: List[str] = field(default_factory=list)\n    last_updated: str = field(default_factory=lambda: datetime.now().isoformat())\n\nclass InventoryManager:\n    def __init__(self, storage_path: str = \"inventory.json\"):\n        self.storage_path = Path(storage_path)\n        self.products: Dict[str, Product] = {}\n        self.load_inventory()\n    \n    def load_inventory(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No inventory file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.products = {\n                    id: Product(**product_data)\n                    for id, product_data in data.items()\n                }\n            logger.info(f\"Loaded {len(self.products)} products from inventory\")\n        except Exception as e:\n            logger.error(f\"Failed to load inventory: {e}\")\n    \n    def save_inventory(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump({id: vars(product) for id, product in self.products.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.products)} products to inventory\")\n        except Exception as e:\n            logger.error(f\"Failed to save inventory: {e}\")\n    \n    def add_product(self, product",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists. Overwriting.\")\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task with ID: {task_id}\")\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save(self) -> None:",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {k: Task(**v) for k, v in data.items()}\n            except (json.JSONDecodeError, IOError) as e:\n                print(f\"Error loading tasks: {e}\")\n                self.tasks = {}\n\n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({k: asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n        except IOError as e:\n            print(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description: str, priority: int, tags: List[str] = None) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}\"\n        self.tasks[task_id] = Task(title=title, description=description, priority=priority, tags=tags)\n        self._save_tasks()\n        return task_id\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_i",
    "import csv\nimport os\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom typing import Dict, List, Tuple\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.sales_data = []\n        self.load_data()\n\n    def load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            raise FileNotFoundError(f\"Data file not found: {self.data_file}\")\n        \n        with open(self.data_file, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            self.sales_data = list(reader)\n    \n    def get_monthly_sales(self) -> Dict[str, float]:\n        monthly_sales = defaultdict(float)\n        \n        for record in self.sales_data:\n            try:\n                date = datetime.strptime(record['date'], '%Y-%m-%d')\n                month_key = f\"{date.year}-{date.month:02d}\"\n                monthly_sales[month_key] += float(record['amount'])\n            except (ValueError, KeyError) as e:\n                print(f\"Error processing record: {record}. Error: {e}\")\n        \n        return dict(monthly_sales)\n    \n    def get_top_products(self, limit: int = 5) -> List[Tuple[str, float]]:\n        product_sales = defaultdict(float)\n        \n        for record in self.sales_data:\n            try:\n                product_sales[record['product']] += float(record['amount'])\n            except (KeyError, ValueError):\n                continue\n        \n        return sorted(product_sales.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    try:\n        analyzer = SalesAnalyzer(\"sales_data.csv\")\n        \n        print(\"Monthly Sales:\")\n        for month, amount in analyzer.get_monthly_sales().items():\n            print(f\"{",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom datetime import datetime\nimport threading\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self.lock = threading.Lock()\n        self.load_tasks()\n        \n    def add_task(self, name: str, description: str, tags: List[str] = None) -> Task:\n        with self.lock:\n            task = Task(\n                id=self.next_id,\n                name=name,\n                description=description,\n                created_at=datetime.now(),\n                tags=tags or []\n            )\n            self.tasks.append(task)\n            self.next",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max([t.id for t in self.tasks], default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        logger.info(f\"Task '{title}' added with ID {task_id}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                self.save_tasks()\n                logger.info(f\"Task {task_id} marked as completed\")\n                return True\n        logger.warning(f\"Task {task_id} not found\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) ->",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\nimport random\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('inventory_system')\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    quantity: int\n    category: str\n\nclass InventoryManager:\n    def __init__(self, data_file: Path):\n        self.data_file = data_file\n        self.products: List[Product] = []\n        self.load_inventory()\n    \n    def load_inventory(self) -> None:\n        if not self.data_file.exists():\n            logger.warning(f\"Data file {self.data_file} not found. Starting with empty inventory.\")\n            return\n        \n        try:\n            with open(self.data_file, 'r') as f:\n                data = json.load(f)\n                self.products = [Product(**item) for item in data]\n            logger.info(f\"Loaded {len(self.products)} products from inventory\")\n        except json.JSONDecodeError:\n            logger.error(f\"Invalid JSON in {self.data_file}\")\n        except Exception as e:\n            logger.error(f\"Error loading inventory: {e}\")\n    \n    def save_inventory(self) -> None:\n        try:\n            with open(self.data_file, 'w') as f:\n                json.dump([vars(p) for p in self.products], f, indent=2)\n            logger.info(f\"Saved {len(self.products)} products to inventory\")\n        except Exception as e:\n            logger.error(f\"Error saving inventory: {e}\")\n    \n    def add_product(self, product: Product) -> None:\n        if any(p.id == product.id for p in self.products):\n            logger.warning(f\"Product with ID {product.id} already exists",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks[self.next_id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_all_tasks(self)",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    notes: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {\n                        name: Task(**task_data)\n                        for name, task_data in data.items()\n                    }\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to parse tasks file: {self.storage_path}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self):\n        data = {\n            name: {\n                \"name\": task.name,\n                \"priority\": task.priority,\n                \"completed\": task.completed,\n                \"tags\": task.tags,\n                \"notes\": task.notes\n            } for name, task in self.tasks.items()\n        }\n        with open(self.storage_path, 'w') as f:\n            json.dump(data, f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n    \n    def add_task(self, title: str, description: str, due_date: datetime, \n                 tags: Optional[List[str]] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, \n                    due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n    \n    def filter_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def get_overdue_tasks",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_income: bool\n\n\nclass BudgetTracker:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n\n    def _load_transactions(self):\n        if not os.path.exists(self.file_path):\n            return\n        \n        with open(self.file_path, 'r', newline='') as file:\n            reader = csv.reader(file)\n            next(reader, None)  # Skip header\n            for row in reader:\n                if len(row) == 5:\n                    date_str, amount, category, description, is_income = row\n                    self.transactions.append(Transaction(\n                        date=datetime.strptime(date_str, '%Y-%m-%d'),\n                        amount=float(amount),\n                        category=category,\n                        description=description,\n                        is_income=is_income.lower() == 'true'\n                    ))\n\n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_transactions()\n\n    def _save_transactions(self):\n        with open(self.file_path, 'w', newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow(['date', 'amount', 'category', 'description', 'is_income'])\n            for t in self.transactions:\n                writer.writerow([\n                    t.date.strftime('%Y-%m-%d'),\n                    t.amount,\n                    t.category,\n                    t.description,\n                    t.is_income\n                ])\n\n    def get_balance(self) -> float:\n        return sum(t.amount if t.is_income else -t.amount for t in self.transactions)\n\n    def get_",
    "import logging\nimport os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists. Updating.\")\n        self.tasks[task.name] = task\n        \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Task '{task_name}' removed\")\n            return True\n        logger.warning(f\"Task '{task_name}' not found\")\n        return False\n    \n    def get_tasks_by",
    "import json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.__dict__ for task in self.tasks.values()], f, indent=2)\n            logger.info(\"Tasks saved successfully\")\n        except IOError as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None)",
    "import os\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Created task {task.id}: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task {task_id}\")\n            return True\n        return False\n    \n    def filter_",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    tags: Optional[List[str]] = None\n    \n    def apply_discount(self, percentage: float) -> float:\n        \"\"\"Apply discount to product price\"\"\"\n        if not 0 <= percentage <= 100:\n            raise ValueError(\"Discount percentage must be between 0 and 100\")\n        return self.price * (1 - percentage / 100)\n\nclass Inventory:\n    def __init__(self, data_file: str = \"inventory.json\"):\n        self.data_file = Path(data_file)\n        self.products: Dict[int, Product] = {}\n        self._load_inventory()\n    \n    def _load_inventory(self) -> None:\n        \"\"\"Load inventory from JSON file\"\"\"\n        if self.data_file.exists():\n            try:\n                with open(self.data_file, 'r') as f:\n                    data = json.load(f)\n                    for item in data:\n                        self.products[item['id']] = Product(**item)\n                logger.info(f\"Loaded {len(self.products)} products from {self.data_file}\")\n            except json.JSONDecodeError:\n                logger.error(f\"Invalid JSON in {self.data_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading inventory: {str(e)}\")\n    \n    def save_inventory(self) -> None:\n        \"\"\"Save inventory to JSON file\"\"\"\n        try:\n            with open(self.data_file, 'w') as f:\n                json.dump([asdict(p) for p in self.products.values()], f",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"□\"\n        due = f\", due: {self.due_date.strftime('%Y-%m-%d')}\" if self.due_date else \"\"\n        return f\"[{status}] {self.name} (priority: {self.priority}{due})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_completed_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.completed]\n    \n    def get_high_priority_tasks(self, threshold: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority <= threshold]\n    \n    def save_to_file(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            for task in self.tasks:\n                due_date_str = task.due_date.strftime('%Y-%m-%d') if task.due_date else \"None\"",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    dependencies: List[str] = field(default_factory=list)\n    metadata: Dict = field(default_factory=dict)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                serializable_tasks = []\n                for task in self.tasks.values():\n                    task_dict = task.__dict__.copy()\n                    task_dict['created_at'] = task_dict['created_at'].iso",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1 if self.tasks else 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            self.save_tasks()\n            return True\n        logger.warning(f\"Task with ID {task_id} not",
    "from collections import defaultdict\nimport heapq\nfrom typing import Dict, List, Tuple, Set\n\n\nclass Graph:\n    def __init__(self):\n        self.edges = defaultdict(list)\n        self.weights = {}\n    \n    def add_edge(self, from_node: str, to_node: str, weight: int) -> None:\n        self.edges[from_node].append(to_node)\n        self.edges[to_node].append(from_node)  # For undirected graph\n        self.weights[(from_node, to_node)] = weight\n        self.weights[(to_node, from_node)] = weight\n    \n    def dijkstra(self, start_node: str) -> Dict[str, int]:\n        \"\"\"Find shortest paths from start_node to all other nodes.\"\"\"\n        shortest_paths = {start_node: 0}\n        priority_queue = [(0, start_node)]\n        visited = set()\n        \n        while priority_queue:\n            current_distance, current_node = heapq.heappop(priority_queue)\n            \n            if current_node in visited:\n                continue\n                \n            visited.add(current_node)\n            \n            for neighbor in self.edges[current_node]:\n                weight = self.weights[(current_node, neighbor)]\n                distance = current_distance + weight\n                \n                if neighbor not in shortest_paths or distance < shortest_paths[neighbor]:\n                    shortest_paths[neighbor] = distance\n                    heapq.heappush(priority_queue, (distance, neighbor))\n        \n        return shortest_paths\n\n\ndef main():\n    g = Graph()\n    g.add_edge('A', 'B', 4)\n    g.add_edge('A', 'C', 2)\n    g.add_edge('B', 'C', 1)\n    g.add_edge('B', 'D', 5)\n    g.add_edge('C', 'D', 8)\n    g.add_edge('C', 'E', 10)\n    g.add_edge('D', 'E', 2)",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Completed task: {self.title}\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date)\n        self.tasks.append(task)\n        self.save_tasks()\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            logger.",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_data in data:\n                task = Task(\n                    name=task_data['name'],",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        return self.due_date and not self.completed and datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.warning(f\"Storage file not found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            self.tasks = []\n            for item in data:\n                item['created_at'] = datetime.fromisoformat(item['create",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    name: str\n    size: int\n    path: str\n    content_type: Optional[str] = None\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: List[str] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions or ['.txt', '.py', '.md', '.json']\n        self.results = []\n    \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        \n        if not os.path.exists(self.root_dir):\n            logger.error(f\"Directory does not exist: {self.root_dir}\")\n            return []\n        \n        with ThreadPoolExecutor(max_workers=4) as executor:\n            for root, _, files in os.walk(self.root_dir):\n                for file in files:\n                    if any(file.endswith(ext) for ext in self.extensions):\n                        executor.submit(self._process_file, root, file)\n        \n        return sorted(self.results, key=lambda x: x.size, reverse=True)\n    \n    def _process_file(self, root: str, filename: str):\n        try:\n            file_path = os.path.join(root, filename)\n            # Simulate processing time\n            time.sleep(random.uniform(0.1, 0.3))\n            \n            file_size = os.path.getsize(file_path)\n            _, ext = os.path.splitext(filename)\n            content_type = self._get_content_type(ext)\n            \n            file_",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    isbn: str\n    rating: Optional[float] = None\n\nclass BookRepository:\n    def __init__(self):\n        self.books = []\n    \n    def add_book(self, book: Book) -> None:\n        self.books.append(book)\n    \n    def find_by_author(self, author: str) -> List[Book]:\n        return [book for book in self.books if book.author == author]\n    \n    def find_by_year_range(self, start_year: int, end_year: int) -> List[Book]:\n        return [book for book in self.books if start_year <= book.year <= end_year]\n\nclass BookService:\n    def __init__(self, repository: BookRepository):\n        self.repository = repository\n        self.api_url = \"https://example.com/api/books/\"\n    \n    def fetch_book_details(self, isbn: str) -> Optional[dict]:\n        try:\n            response = requests.get(f\"{self.api_url}{isbn}\", timeout=5)\n            if response.status_code == 200:\n                return response.json()\n            logger.warning(f\"Failed to fetch book with ISBN {isbn}: {response.status_code}\")\n            return None\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching book with ISBN {isbn}: {e}\")\n            return None\n    \n    def enrich_books_with_ratings(self) -> None:\n        def process_book(book):\n            details = self.fetch_book_details(book.isbn)\n            if details and 'rating' in details:\n                book.rating = details['rating",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            logger.info(f\"Deleted task with ID: {task_id}\")\n            return True\n        return False\n    \n    def list_tasks",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created task {task_id}: {name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus\n    tags: List[str]\n    priority: int  # 1-5, where 5 is highest\n\n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"status\": self.status.name,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n\n    @classmethod\n    def from_dict(cls, data):\n        return cls(\n            id=data[\"id\"],\n            title=data[\"title\"],\n            description=data[\"description\"],\n            status=TaskStatus[data[\"status\"]],\n            tags=data[\"tags\"],\n            priority=data[\"priority\"]\n        )\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title, description, tags=None, priority=3):\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            status=TaskStatus.TODO,\n            tags=tags or [],\n            priority=priority\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id):\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_status(self, task_id, new_status):\n        task = self.get_task(task_id)\n        if task:\n            task.status = new_status\n            return True\n        return False\n\n    def get_tasks_by_status(self, status):\n        return [task for task in self.tasks if task",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom pathlib import Path\nimport json\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"due_date\": self.due_date,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def get_high_priority_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= 8]\n        \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file {self",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    tags: List[str] = field(default_factory=list)\n    subtasks: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> str:\n        task_id = f\"task-{random.randint(1000, 9999)}\"\n        self.tasks[task_id] = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        return task_id\n    \n    def update_status(self, task_id: str, status: TaskStatus) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].status = status\n            return True\n        return False\n    \n    def add_subtask(self, parent_id: str, subtask_id: str) -> bool:\n        if parent_id in self.tasks and subtask_id in self.tasks:\n            self.tasks[parent_id].subtasks.append(subtask_id)\n            return True\n        return False\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task in self.tasks.values() if task.status == status]\n    \n    def export_to_json(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            serializable_tasks = {}\n            for task_id, task in self.tasks.items():\n                task_dict = task.__dict",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_data in data:\n                        task = Task(\n                            id=task_data[\"id\"],\n                            title=task_data[\"title\"],\n                            description=task_data[\"description\"],\n                            completed=task_data[\"completed\"],\n                            created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                            completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) if task_data[\"completed_at\"] else None\n                        )\n                        self.tasks.append(task)\n                logger.",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_all_tasks(self, include_completed: bool = True) -> List[Task]:\n        if include_completed:\n            return self.tasks\n        return [task for task in self.tasks if not task.completed]\n\n    def _generate_id(self) -> int:\n        if not self.tasks:\n            return 1\n        return max(task.id for task in self.tasks) + 1\n\n    def load_tasks(self):\n        if not self.storage_path.exists():\n            self.tasks = []\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n        except (",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    completed: bool\n    created_at: datetime\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, starting fresh\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    self.tasks[task_id] = Task(\n                        id=task_id,\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) \n                            if task_data.get(\"completed_at\") else None\n                    )\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        data = {}\n        for task_id, task in self.tasks.items():\n            data[task_id]",
    "import requests\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    humidity: int\n    description: str\n    timestamp: float\n\nclass WeatherService:\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = \"https://api.openweathermap.org/data/2.5/weather\"\n        \n    def get_weather(self, city: str) -> Optional[WeatherData]:\n        try:\n            params = {\n                'q': city,\n                'appid': self.api_key,\n                'units': 'metric'\n            }\n            response = requests.get(self.base_url, params=params, timeout=5)\n            response.raise_for_status()\n            \n            data = response.json()\n            return WeatherData(\n                city=city,\n                temperature=data['main']['temp'],\n                humidity=data['main']['humidity'],\n                description=data['weather'][0]['description'],\n                timestamp=time.time()\n            )\n        except requests.exceptions.RequestException as e:\n            logger.error(f\"Error fetching weather data for {city}: {e}\")\n            return None\n\nclass WeatherMonitor:\n    def __init__(self, service: WeatherService, cities: List[str]):\n        self.service = service\n        self.cities = cities\n        self.data = []\n    \n    def fetch_all_weather_data(self) -> List[WeatherData]:\n        with ThreadPoolExecutor(max_workers=5) as executor:\n            results = list(executor.map(self.service.get_weather, self.cities))\n        \n        # Filter out None values\n        valid_results = [r for r in results",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n    \n    def __str__(self) -> str:\n        return f\"Task {self.id}: {self.name} [{self.status.name}]\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.completed_task_ids: List[int] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added {task}\")\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def process_tasks(self) -> None:\n        pending_tasks = [t for t in self.tasks if t.status == TaskStatus.PENDING]\n        \n        for task in pending_tasks:\n            if task.can_start(self.completed_task_ids):\n                task.status = TaskStatus.IN_PROGRESS\n                logger.info(f\"Started {task}\")\n                \n                # Simulate task processing\n                success = random",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field, asdict\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, name: str, description: str, tags: List[str] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, description=description, tags=tags or [])\n        self.tasks[name] = task\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, name: str) -> None:\n        if name not in self.tasks:\n            raise ValueError(f\"Task with name '{name}' not found\")\n        \n        self.tasks[name].complete()\n        self._save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        with open(self.storage_path,",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n    def remove_tag(self, tag: str) -> None:\n        if tag in self.tags:\n            self.tags.remove(tag)\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\ndef main():",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        self.logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return task\n    \n    def assign_task(self, task_id: int, person: str) -> bool:\n        task = self._find_task(task_id)\n        if task:\n            task.assigned_to = person\n            task.status = TaskStatus.IN_PROGRESS\n            self.logger.info(f\"Assigned task {task.id} to {person}\")\n            return True\n        return False\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self._find_task(task_id)\n        if task:\n            task.status = TaskStatus.COMPLETED\n            self.logger.info(f\"Completed task {task.id}\")",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    tags: List[str] = field(default_factory=list)\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n        return True\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        task = self.tasks[task_name]\n        task.completed = True\n        task.completed_at = datetime.now()\n        logger.info(f\"Completed task: {task_name}\")\n        self._save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        logger.info(\"Task Manager initialized\")\n\n    def add_task(self, name: str, description: str, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        # Validate dependencies exist\n        if dependencies:\n            for dep_id in dependencies:\n                if dep_id not in self.tasks:\n                    logger.error(f\"Dependency {dep_id} does not exist\")\n                    raise ValueError(f\"Dependency {dep_id} does not exist\")\n        \n        self.tasks[task_id] = Task(\n            id=task_id,\n            name=name,\n            description=description,\n            dependencies=dependencies or []\n        )\n        logger.info(f\"Added task {task_id}: {name}\")\n        return task_id\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_status(self, task_id: int, status: TaskStatus) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item['id'],\n                            title=item['title'],\n                            description=item['description'],\n                            completed=item['completed'],\n                            created_at=datetime.fromisoformat(item['created_at']),\n                            completed_at=datetime.fromisoformat(item['completed_at']) if item['completed_at'] else None\n                        )\n                        for item in data\n                    ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([\n                    {\n                        'id': task.id,\n                        'title': task.title,\n                        'description': task.description,\n                        'completed': task.completed,\n                        'created_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n\n    def save_tasks(self):",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport requests\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    isbn: str\n    genre: Optional[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            'title': self.title,\n            'author': self.author,\n            'year': self.year,\n            'isbn': self.isbn,\n            'genre': self.genre\n        }\n\nclass BookLibrary:\n    def __init__(self, data_file: str = 'books.json'):\n        self.data_file = Path(data_file)\n        self.books: List[Book] = []\n        self.load_books()\n        \n    def load_books(self) -> None:\n        if self.data_file.exists():\n            try:\n                with open(self.data_file, 'r') as f:\n                    books_data = json.load(f)\n                    self.books = [Book(**book) for book in books_data]\n                logger.info(f\"Loaded {len(self.books)} books from {self.data_file}\")\n            except json.JSONDecodeError:\n                logger.error(f\"Error decoding {self.data_file}\")\n        else:\n            logger.info(f\"No existing library found at {self.data_file}\")\n    \n    def save_books(self) -> None:\n        with open(self.data_file, 'w') as f:\n            json.dump([book.to_dict() for book in self.books], f, indent=2)\n        logger.info(f\"Saved {len(self.books)} books to {self.data_file}\")\n    \n    def add_book(self, book: Book) -> None:",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.title] = task\n        logger.info(f\"Added task: {task.title}\")\n        self._save_tasks()\n    \n    def get_task(self, title: str) -> Optional[Task]:\n        return self.tasks.get(title)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_dict in data:\n                due_date =",
    "import logging\nimport requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    isbn: str\n    rating: float = 0.0\n    \n    def __post_init__(self):\n        if self.rating < 0 or self.rating > 5:\n            raise ValueError(\"Rating must be between 0 and 5\")\n\nclass BookRepository:\n    def __init__(self):\n        self.books = {}\n        \n    def add_book(self, book: Book) -> None:\n        self.books[book.isbn] = book\n        logger.info(f\"Added book: {book.title} by {book.author}\")\n        \n    def get_book(self, isbn: str) -> Optional[Book]:\n        return self.books.get(isbn)\n    \n    def get_books_by_author(self, author: str) -> List[Book]:\n        return [book for book in self.books.values() if book.author == author]\n    \n    def get_books_above_rating(self, min_rating: float) -> List[Book]:\n        return [book for book in self.books.values() if book.rating >= min_rating]\n\n@lru_cache(maxsize=100)\ndef fetch_book_info(isbn: str) -> Optional[dict]:\n    \"\"\"Fetch book information from external API (cached)\"\"\"\n    try:\n        url = f\"https://example.com/api/books/{isbn}\"\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n        return response.json()\n    except requests.RequestException as e:\n        logger.error(f\"Error fetching book info for ISBN {isbn}: {e}\")\n        return None\n\ndef",
    "import random\nfrom typing import List, Dict, Optional\nfrom dataclasses import dataclass\nfrom collections import defaultdict\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.tasks_by_priority: Dict[int, List[Task]] = defaultdict(list)\n        self.next_id = 1\n\n    def add_task(self, name: str, priority: int) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.tasks[task.id] = task\n        self.tasks_by_priority[priority].append(task)\n        self.next_id += 1\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.tasks.get(task_id)\n        if task:\n            task.completed = True\n            return task\n        return None\n\n    def get_next_task(self) -> Optional[Task]:\n        for priority in sorted(self.tasks_by_priority.keys(), reverse=True):\n            tasks = [t for t in self.tasks_by_priority[priority] if not t.completed]\n            if tasks:\n                return tasks[0]\n        return None\n\n    def get_stats(self) -> Dict[str, int]:\n        completed = sum(1 for t in self.tasks.values() if t.completed)\n        return {\n            \"total\": len(self.tasks),\n            \"completed\": completed,\n            \"pending\": len(self.tasks) - completed\n        }\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some tasks\n    tasks = [\n        manager.add_task(\"Implement login feature\", 3),\n        manager.add_task(\"Fix critical bug\", 5),\n        manager.add_task(\"Update documentation\", 1),\n        manager.add_task(\"Refactor utils module\", 2)\n    ]\n    \n    # Complete",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No existing tasks file found\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: str):\n        self.station_id = station_id\n        self.location = location\n        self.temperature_readings = []\n        self.humidity_readings = []\n        \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n        \n    def average_temperature(self) -> float:\n        if not self.temperature_readings:\n            return 0.0\n        return sum(self.temperature_readings) / len(self.temperature_readings)\n    \n    def average_humidity(self) -> float:\n        if not self.humidity_readings:\n            return 0.0\n        return sum(self.humidity_readings) / len(self.humidity_readings)\n    \n    def __str__(self) -> str:\n        return f\"Station {self.station_id} at {self.location}\"\n\n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n        \n    def add_station(self, station: WeatherStation) -> None:\n        self.stations[station.station_id] = station\n        \n    def get_station(self, station_id: str) -> WeatherStation:\n        return self.stations.get(station_id)\n    \n    def get_hottest_location(self) -> Tuple[str, float]:\n        if not self.stations:\n            return (\"No stations\", 0.0)\n        \n        hottest = max(self.stations.values(), \n                      key=lambda station: station.average_temperature())\n        return (hottest.location, hottest.average_temperature())\n    \n    def generate_report(self) -> Dict[str, List[float]]:\n        report = defaultdict(list)\n        for station in self.stations.values():\n            report[station.location].append(station.average_temperature())\n        return dict(report)",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional, Dict, Any\nimport json\n\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    extension: str\n    is_hidden: bool\n\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, ignore_hidden: bool = True):\n        self.root_dir = Path(root_dir)\n        self.ignore_hidden = ignore_hidden\n        self.logger = self._setup_logger()\n        \n    @staticmethod\n    def _setup_logger():\n        logger = logging.getLogger(\"file_analyzer\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def analyze(self) -> Dict[str, Any]:\n        if not self.root_dir.exists():\n            self.logger.error(f\"Directory {self.root_dir} does not exist\")\n            return {}\n            \n        self.logger.info(f\"Analyzing directory: {self.root_dir}\")\n        files = self._collect_files()\n        \n        result = {\n            \"total_files\": len(files),\n            \"total_size\": sum(f.size for f in files),\n            \"extensions\": self._count_extensions(files),\n            \"hidden_files\": sum(1 for f in files if f.is_hidden)\n        }\n        \n        return result\n    \n    def _collect_files(self) -> List[FileStats]:\n        files = []\n        for file_path in self.root_dir.rglob(\"*\"):\n            if file_path.is_file():\n                is_hidden = file_path.name.startswith(\".\")\n                if is_hidden and self.ignore_hidden:\n                    continue\n                    \n                files.append(FileStats(\n                    path=file_path,\n                    size",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    id=task_dict['id'],\n                    title=task_dict['title'],\n                    description=task_dict['description'],\n                    completed=task_dict.get('completed', False),\n                    tags=task_dict.get('tags', [])\n                )\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        tasks_data = [\n            {\n                'id': task.id,\n                'title': task.title,\n                'description': task.description,\n                'completed': task.completed,\n                'tags': task.tags\n            }\n            for task",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime, timedelta\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    due_date=datetime.fromisoformat(task_dict[\"due_date\"]),\n                    completed=task_dict[\"completed\"],\n                    tags=task_dict.get(\"tags\", [])",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    modified_time: float\n    \n    @property\n    def size_mb(self) -> float:\n        return self.size / (1024 * 1024)\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = root_dir\n        self.extensions = extensions or ['.txt', '.py', '.md', '.json']\n        \n    def get_matching_files(self) -> List[FileInfo]:\n        results = []\n        for root, _, files in os.walk(self.root_dir):\n            for file in files:\n                if any(file.endswith(ext) for ext in self.extensions):\n                    full_path = os.path.join(root, file)\n                    try:\n                        stats = os.stat(full_path)\n                        results.append(FileInfo(\n                            path=full_path,\n                            size=stats.st_size,\n                            modified_time=stats.st_mtime\n                        ))\n                    except OSError as e:\n                        logger.error(f\"Error accessing {full_path}: {e}\")\n        return results\n    \n    def process_file(self, file_info: FileInfo) -> dict:\n        # Simulate processing by sleeping for a random time\n        time.sleep(random.uniform(0.1, 0.3))\n        return {\n            'path': file_info.path,\n            'size_mb': file_info.size_mb,\n            'is_large': file_info.size_mb > 1.0\n        }\n    \n    def analyze_",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists. Overwriting.\")\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n        \n    def delete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task with ID: {task_id}\")\n            return True\n        logger.warning(f\"Task with ID {task_id} not found.\")\n        return False\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        self.save_tasks()\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            logger.",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    ) for t in tasks_data\n                ]\n                logger.info",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"price\": self.price,\n            \"category\": self.category,\n            \"in_stock\": self.in_stock\n        }\n\nclass Inventory:\n    def __init__(self, data_file: str = \"inventory.json\"):\n        self.data_file = data_file\n        self.products: Dict[str, Product] = {}\n        self._load_data()\n        \n    def _load_data(self) -> None:\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, 'r') as f:\n                    data = json.load(f)\n                    for item in data:\n                        self.products[item[\"id\"]] = Product(**item)\n                logger.info(f\"Loaded {len(self.products)} products from {self.data_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading inventory: {e}\")\n        else:\n            logger.warning(f\"Inventory file {self.data_file} not found. Starting with empty inventory.\")\n    \n    def save(self) -> None:\n        with open(self.data_file, 'w') as f:\n            json.dump([p.to_dict() for p in self.products.values()], f, indent=2)\n        logger.info(f\"Saved {len(self.products)} products to {self.",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(\"No task storage found, starting with empty task list\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def add_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, with 5 being highest priority\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def get_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def load_tasks(self):\n        if self.storage_path.exists():\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(",
    "import os\nimport json\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                \n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    \n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n        \n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n            \n        with open(self.data_file, 'r', newline='') as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description']\n                ))\n    \n    def add_transaction(self, amount: float, category: str, description: str, date: Optional[datetime] = None):\n        if date is None:\n            date = datetime.now()\n        \n        transaction = Transaction(date=date, amount=amount, category=category, description=description)\n        self.transactions.append(transaction)\n        self._save_data()\n        \n    def _save_data(self):\n        with open(self.data_file, 'w', newline='') as file:\n            writer = csv.DictWriter(file, fieldnames=['date', 'amount', 'category', 'description'])\n            writer.writeheader()\n            for transaction in self.transactions:\n                writer.writerow({\n                    'date': transaction.date.strftime('%Y-%m-%d'),\n                    'amount': transaction.amount,\n                    'category': transaction.category,\n                    'description': transaction.description\n                })\n    \n    def get_summary_by_category(self) -> Dict[str, float]:\n        summary = {}\n        for transaction in self.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    @lru_cache(maxsize=32)\n    def get_completion_rate(self) -> float:\n        if not self.tasks:\n            return 0.0\n        completed = sum(1 for task in self.tasks if task.completed)\n        return completed / len(self.tasks)\n    \n    def get_high_priority_tasks(self) -> List[Task]:\n        return sorted([t for t in self.tasks if not t.completed and t.priority > 2], \n                     key=lambda x: x.priority, reverse=True)\n\n\ndef main():\n    manager = TaskManager()",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus\n    tags: List[str]\n    priority: int  # 1-5 where 5 is highest\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title, description, tags=None, priority=3):\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            status=TaskStatus.TODO,\n            tags=tags or [],\n            priority=priority\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task.id\n\n    def get_task(self, task_id) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_status(self, task_id, new_status):\n        task = self.get_task(task_id)\n        if task:\n            task.status = new_status\n            return True\n        return False\n\n    def filter_by_status(self, status):\n        return [task for task in self.tasks if task.status == status]\n\n    def filter_by_tag(self, tag):\n        return [task for task in self.tasks if tag in task.tags]\n\n    def get_high_priority_tasks(self, min_priority=4):\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def export_to_json(self, filename):\n        with open(filename, 'w') as f:\n            tasks_dict = [\n                {\n                    'id': task.id,\n                    'title': task.title,\n                    'description': task.description,",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus\n    tags: List[str]\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        logger.info(\"Task Manager initialized\")\n\n    def add_task(self, title, description, tags=None):\n        task_id = self.next_id\n        self.next_id += 1\n        \n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            status=TaskStatus.TODO,\n            tags=tags or []\n        )\n        \n        self.tasks[task_id] = task\n        logger.info(f\"Task created: {task.title} (ID: {task.id})\")\n        return task_id\n\n    def update_status(self, task_id, new_status):\n        if task_id not in self.tasks:\n            logger.error(f\"Task with ID {task_id} not found\")\n            return False\n            \n        task = self.tasks[task_id]\n        old_status = task.status\n        task.status = new_status\n        logger.info(f\"Task {task_id} status changed: {old_status} -> {new_status}\")\n        return True\n    \n    def assign_task(self, task_id, person):\n        if task_id not in self.tasks:\n            logger.error(f\"Task with ID {task_id} not found\")\n            return False",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field, asdict\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self) -> None:\n        self.completed = True\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self._save_tasks()\n    \n    def remove_task(self, task_name: str) -> Optional[Task]:\n        if task_name in self.tasks:\n            task = self.tasks.pop(task_name)\n            self._save_tasks()\n            return task\n        return None\n    \n    def get_task(self, task_name: str) -> Optional[Task]:\n        return self.tasks.get(task_name)\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_tasks_by_priority(self, min_priority: int = 1) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            serialized = {name: asdict(task",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport os\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed=t[\"completed\"],\n                        tags=t.get(\"tags\", [])\n                    )\n                    for t in tasks_data\n                ]\n        except (json.JSONDecodeError, FileNotFoundError):\n            self.tasks = []\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        new_id = max",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        return cls(\n            id=data[\"id\"],\n            title=data[\"title\"],\n            description=data[\"description\"],\n            created_at=datetime.fromisoformat(data[\"created_at\"]),\n            completed=data[\"completed\"],\n            tags=data.get(\"tags\", [])\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)\n            with open(self.storage_path, 'w') as f:\n                json.dump([], f)\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                for task_data in tasks_data:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.debug(f\"Added tag '{tag}' to task {self.id}\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> str:\n        logger.info(f\"Starting task {self.id}: {self.name}\")\n        time.sleep(self.duration)  # Simulate work\n        self.result = f\"Result of {self.name}\"\n        logger.info(f\"Completed task {self.id}: {self.name}\")\n        return self.result\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def can_execute(self, task_id: int, completed_tasks: List[int]) -> bool:\n        task = self.tasks[task_id]\n        return all(dep in completed_tasks for dep in task.dependencies)\n    \n    def execute_all(self) -> dict:\n        completed_tasks = []\n        results = {}\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(completed_tasks) < len(self.tasks):\n                eligible_tasks = [\n                    task_id for task_id in self.tasks \n                    if task_id not in completed_tasks and self.can_execute(task_id, completed_tasks)\n                ]\n                \n                if not eligible_tasks:\n                    logger.warning(\"",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    conditions: str\n    humidity: Optional[int] = None\n    \n    def __post_init__(self):\n        if self.temperature < -100 or self.temperature > 100:\n            raise ValueError(f\"Invalid temperature: {self.temperature}\")\n\nclass WeatherService:\n    def __init__(self, api_key: str, base_url: str = \"https://api.example.com/weather\"):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.cache = {}\n        self.cache_expiry = {}\n        self.cache_ttl = 300  # 5 minutes\n        \n    def get_weather(self, city: str) -> WeatherData:\n        # Check cache first\n        if city in self.cache and time.time() - self.cache_expiry.get(city, 0) < self.cache_ttl:\n            logger.info(f\"Cache hit for {city}\")\n            return self.cache[city]\n        \n        logger.info(f\"Fetching weather data for {city}\")\n        try:\n            # Simulate API call\n            # In a real app, this would be: response = requests.get(f\"{self.base_url}/{city}\", params={\"api_key\": self.api_key})\n            time.sleep(1)  # Simulate network delay\n            \n            # Mock response based on city name\n            mock_data = {\n                \"temperature\": hash(city) % 40,\n                \"conditions\": [\"Sunny\", \"Cloudy\", \"Rainy\", \"Snowy\"][hash(city) % 4],\n                \"humidity\": hash(city) % 100",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_system\")\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    quantity: int\n    \n    def __post_init__(self):\n        if self.price < 0:\n            raise ValueError(\"Price cannot be negative\")\n        if self.quantity < 0:\n            raise ValueError(\"Quantity cannot be negative\")\n\nclass InventoryManager(ABC):\n    @abstractmethod\n    def add_product(self, product: Product) -> None:\n        pass\n    \n    @abstractmethod\n    def remove_product(self, product_id: int) -> Optional[Product]:\n        pass\n    \n    @abstractmethod\n    def get_total_inventory_value(self) -> float:\n        pass\n\nclass SimpleInventoryManager(InventoryManager):\n    def __init__(self):\n        self.products: List[Product] = []\n        \n    def add_product(self, product: Product) -> None:\n        for existing_product in self.products:\n            if existing_product.id == product.id:\n                logger.warning(f\"Product with ID {product.id} already exists\")\n                return\n        self.products.append(product)\n        logger.info(f\"Added product: {product.name}\")\n        \n    def remove_product(self, product_id: int) -> Optional[Product]:\n        for i, product in enumerate(self.products):\n            if product.id == product_id:\n                removed_product = self.products.pop(i)\n                logger.info(f\"Removed product: {removed_product.name}\")\n                return removed_product\n        logger.warning(f\"Product with ID {product_id} not found\")\n        return None\n    \n    def get_total_inventory_value(self) -> float:\n        return sum(",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item['id'],\n                            title=item['title'],\n                            description=item['description'],\n                            completed=item['completed'],\n                            created_at=datetime.fromisoformat(item['created_at']),\n                            completed_at=datetime.fromisoformat(item['completed_at']) if item['completed_at'] else None\n                        ) for item in data\n                    ]\n                logger.info(f\"Loaded {",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom collections import defaultdict\nimport argparse\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            with open(self.storage_file, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n        except FileNotFoundError:\n            logger.warning(f\"Storage file {self.storage_file} not found, starting with empty task list\")\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_file, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks.values()], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_file}\")\n    \n    def add_task(self, title: str, description: str, tags:",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            raise ValueError(f\"Task with id {task.id} already exists\")\n        self.tasks[task.id] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.title}\")\n    \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        result = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            result[\"due_date\"] = self.due_date.isoformat()\n        return result\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_data in tasks_data:\n                due_date = None\n                if \"due_date\" in task_data:\n                    due_date = datetime.fromisoformat(task_data[\"due_date\"])\n                \n                task = Task(\n                    id=task_data[\"id\"],\n                    title=task_data[\"title\"],\n                    description=task_data",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n    \n    def execute(self) -> bool:\n        try:\n            logger.info(f\"Executing task {self.id}: {self.name}\")\n            self.status = TaskStatus.IN_PROGRESS\n            \n            # Simulate work with some randomness\n            success = random.random() > 0.2\n            \n            if success:\n                self.status = TaskStatus.COMPLETED\n                logger.info(f\"Task {self.id} completed successfully\")\n            else:\n                self.status = TaskStatus.FAILED\n                logger.warning(f\"Task {self.id} failed\")\n            \n            return success\n        except Exception as e:\n            logger.error(f\"Error executing task {self.id}: {str(e)}\")\n            self.status = TaskStatus.FAILED\n            return False\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.completed_task_ids: List[int] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task {task.id}:",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) +",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime,\n                priority: int, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            priority=priority,\n            tags=tags\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_over",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    status: TaskStatus\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        logger.info(\"Task manager initialized\")\n        \n    def add_task(self, task: Task) -> int:\n        task_id = self.next_id\n        self.tasks[task_id] = task\n        self.next_id += 1\n        logger.info(f\"Added task {task_id}: {task.name}\")\n        return task_id\n        \n    def update_status(self, task_id: int, new_status: TaskStatus) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Cannot update task {task_id}: not found\")\n            return False\n            \n        if new_status == TaskStatus.IN_PROGRESS:\n            # Check if dependencies are completed\n            for dep_id in self.tasks[task_id].dependencies:\n                if dep_id in self.tasks and self.tasks[dep_id].status != TaskStatus.DONE:\n                    logger.warning(f\"Cannot start task {task_id}: dependency {dep_id} not completed\")\n                    return False\n                    \n        self.tasks[task_id].status = new_status\n        logger.info(f\"Updated task {task_id} status to {new_status.name}\")",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_manager\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int = 0\n    categories: List[str] = field(default_factory=list)\n    \n    def is_in_stock(self) -> bool:\n        return self.quantity > 0\n        \n    def update_quantity(self, amount: int) -> None:\n        new_quantity = self.quantity + amount\n        if new_quantity < 0:\n            raise ValueError(f\"Cannot reduce quantity below 0 (requested: {amount})\")\n        self.quantity = new_quantity\n        logger.info(f\"Updated product {self.id} quantity to {self.quantity}\")\n\n\nclass InventoryManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.products: Dict[str, Product] = {}\n        self.storage_path = storage_path or Path(\"inventory.json\")\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product {product.id} already exists, updating\")\n        self.products[product.id] = product\n        \n    def remove_product(self, product_id: str) -> None:\n        if product_id not in self.products:\n            raise KeyError(f\"Product {product_id} not found\")\n        del self.products[product_id]\n        logger.info(f\"Removed product {product_id}\")\n        \n    def get_low_stock_products(self, threshold: int = 5) -> List[Product]:\n        return [p for p in self.products.values() if 0 < p.quantity <= threshold]\n    \n    def save(self) -> None",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    \n    @property\n    def is_expense(self) -> bool:\n        return self.amount < 0\n    \n    @property\n    def absolute_amount(self) -> float:\n        return abs(self.amount)\n\n\nclass BudgetTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n    \n    def _load_transactions(self) -> None:\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description']\n                ))\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self._save_transactions()\n    \n    def _save_transactions(self) -> None:\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['date', 'amount', 'category', 'description'])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description\n                })\n    \n    def get_category_summary(self) -> Dict[str, float]:\n        summary = {}\n        for t in self.",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.max_workers = max_workers\n        self.tasks: Dict[int, Task] = {}\n        self.results: Dict[int, str] = {}\n        self.completed_tasks: List[int] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n    \n    def process_task(self, task_id: int) -> str:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        result = f\"Task {task.name} completed successfully\"\n        self.results[task_id] = result\n        self.completed_tasks.append(task_id)\n        return result\n    \n    def can_process(self, task_id: int) -> bool:\n        dependencies = self.tasks[task_id].dependencies\n        return all(dep in self.completed_tasks for dep in dependencies)\n    \n    def run(self) -> Dict[int, str]:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            pending_tasks = list(self.tasks.keys())\n            \n            while pending_tasks:\n                processable = [t for t in pending_tasks if self.can_",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id: int = 1\n    \n    def create_task(self, description: str) -> Task:\n        task = Task(id=self.next_id, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Created task {task.id}: {description}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_completed_tasks(self) -> List[",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        new_task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(new_task)\n        logger.info(f\"Added task: {new_task.title}\")\n        self.save_tasks()\n        return new_task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = next((t for t in self.tasks if t.id == task_id), None)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom collections import defaultdict\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> int:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        return task.id\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: int, **kwargs) -> bool:\n        if task_id not in self.tasks:\n            return False\n        \n        for key, value in kwargs.items():\n            if hasattr(self.tasks[task_id], key):\n                setattr(self.tasks[task_id], key, value)\n        return True\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in (task.tags or [])]\n    \n    def get_stats(self) -> Dict:\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks.values() if task.completed)\n        \n        tag_counts = defaultdict(int)\n        for task in self.tasks.values():\n            for tag",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.debug(f\"Added tag '{tag}' to task {self.id}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def create_task(self, title: str, description: str) -> Task:\n        task = Task(id=self.next_id, title=title, description=description)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Created task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_status(self, task_id: int, status: TaskStatus) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.status = status\n            logger.info(f\"Updated task {task_id} status to {status.name}\")\n            return True\n        return False",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None, priority: int = 1) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        self.tasks[task_id] = Task(\n            title=title,\n            description=description,\n            tags=tags or [],\n            priority=priority\n        )\n        self.save_tasks()\n        return task_id\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data =",
    "import logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List['Task'] = field(default_factory=list)\n    completion_percentage: int = 0\n\n    def update_status(self, new_status: TaskStatus) -> None:\n        logging.info(f\"Task '{self.name}' status changed from {self.status} to {new_status}\")\n        self.status = new_status\n        if new_status == TaskStatus.COMPLETED:\n            self.completion_percentage = 100\n\n\nclass ProjectManager:\n    def __init__(self, name: str):\n        self.name = name\n        self.tasks: List[Task] = []\n        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\n        self.logger = logging.getLogger(__name__)\n\n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        self.logger.info(f\"Task '{task.name}' added to project '{self.name}'\")\n\n    def get_task_by_name(self, name: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.name == name:\n                return task\n        return None\n\n    def update_task_progress(self, task_name: str, progress: int) -> bool:\n        task = self.get_task_by_name(task_name)\n        if not task:\n            self.logger.error(f\"Task '{task_name}' not found\")\n            return False\n\n        if task.status == TaskStatus.COMPLETED:\n            self.logger.warning(f\"Task '{task_name}' is already completed\")\n            return False\n\n        task.completion_percentage = min(progress,",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.storage_path = storage_path or Path.home() / \"tasks.json\"\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists\")\n            return False\n        \n        self.tasks[task.id] = task\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return True\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task with ID {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        self.save_tasks()\n        logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(\"No task file found, starting with empty task list\")\n            return\n        \n        try:\n            data = json.loads(self.storage_",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t['id'],\n                    title=t['title'],\n                    description=t['description'],\n                    completed=t['completed'],\n                    created_at=datetime.fromisoformat(t['created_at']),\n                    completed_at=datetime.fromisoformat(t['completed_at']) if t['complete",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def list_tasks(self, show_completed: bool = True) -> List[Task]:\n        if show_completed:\n            return self.tasks\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks],",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def create_task(self, name: str, description: str) -> Task:\n        task = Task(id=self.next_id, name=name, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Created task: {task.name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def execute_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                return None\n                \n        # Simulate task execution\n        time.sleep(task.duration * 0.1)  # Scale down for demo purposes\n        result = f\"Task {task.name} (ID: {task.id}) completed with priority {task.priority}\"\n        task.completed = True\n        self.results[task_id] = result\n        return result\n        \n    def run_parallel(self, max_workers: int = 3) -> List[str]:\n        results = []\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while len(self.results) < len(self.tasks):\n                eligible_tasks = [\n                    t.id for t in self.tasks.values() \n                    if not t.completed and all(d in self.results for d in t.dependencies)\n                ]\n                \n                if not eligible_tasks:\n                    break\n                    \n                # Sort by priority\n                eligible_tasks.sort(key=lambda tid: self.tasks[tid].priority, reverse=True)\n                \n                # Submit tasks\n                futures = {executor.submit(self.execute_task",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_stats(self) -> Dict:\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks if task.completed)\n        return {\n            \"total\": total,\n            \"completed\": complete",
    "import random\nfrom typing import List, Dict, Optional\nfrom dataclasses import dataclass\nfrom collections import defaultdict\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self) -> None:\n        self.completed = True\n        \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"☐\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.tags: Dict[str, List[int]] = defaultdict(list)\n        self._next_id = 1\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self._next_id, name=name, priority=priority)\n        self.tasks[task.id] = task\n        self._next_id += 1\n        return task\n        \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.tasks.get(task_id)\n        if task:\n            task.complete()\n        return task\n    \n    def add_tag(self, task_id: int, tag: str) -> bool:\n        if task_id in self.tasks:\n            self.tags[tag].append(task_id)\n            return True\n        return False\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [self.tasks[task_id] for task_id in self.tags.get(tag, [])]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks.values() \n                if task.priority >= min_priority and not task.completed]\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some tasks\n    tasks = [\n        manager.add_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse {self.storage_path}. Starting with empty task list.\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description: str",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item['id'],\n                            title=item['title'],\n                            description=item['description'],\n                            completed=item['completed'],\n                            created_at=datetime.fromisoformat(item['created_at']),\n                            completed_at=datetime.fromisoformat(item['completed_at']) if item['completed_at'] else None\n                        ) for item in data\n                    ]\n                logger.info(f\"Loaded {len(self.tasks",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    notes: Optional[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.completed = True\n                logger.info(f\"Marked task as completed: {task_name}\")\n                self.save_tasks()\n                return True\n        logger.warning(f\"Task not found: {task_name}\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def save_tasks(self) -> None:\n        try:\n            task_data = [task.__dict__ for task in self.tasks]\n            with open(self.storage_path, 'w') as f:\n                json.dump(task_data, f, indent=2)\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks: Dict[int, Task] = {}\n        self.completed_tasks: List[int] = []\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task {task_id} not found\")\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.completed_tasks:\n                logger.warning(f\"Task {task_id} waiting for dependency {dep_id}\")\n                return None\n                \n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate occasional failures\n        if random.random() < 0.1:\n            logger.error(f\"Task {task.name} failed\")\n            return None\n            \n        logger.info(f\"Completed task {task.name}\")\n        self.completed_tasks.append(task.id)\n        return f\"Result of {task.name}\"\n        \n    def run_all_tasks(",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as completed\")\n        \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"□\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    @lru_cache(maxsize=32)\n    def get_stats(self) -> dict:\n        completed = sum(1 for task in self.tasks if task.completed)\n        return {\n            \"total\": len(self.tasks),\n            \"completed\": completed,\n            \"pending\": len(self.tasks) - completed,\n            \"completion_rate\": completed / len(self.tasks) if self.tasks else 0\n        }\n    \n    def get_sorted_tasks(self) -> List[Task]:\n        return sorted(self.tasks, key=lambda",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    duration: float\n    dependencies: List[str] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.max_workers = max_workers\n        self.tasks: Dict[str, Task] = {}\n        self.results: Dict[str, Any] = {}\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: str) -> Dict[str, Any]:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        success = random.random() > 0.2  # 80% success rate\n        \n        result = {\n            \"task_id\": task_id,\n            \"success\": success,\n            \"processing_time\": task.duration,\n            \"timestamp\": time.time()\n        }\n        \n        if success:\n            logger.info(f\"Task {task.name} completed successfully\")\n        else:\n            logger.warning(f\"Task {task.name} failed\")\n            \n        return result\n    \n    def execute(self) -> Dict[str, Any]:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Process tasks with dependencies last\n            independent_tasks = [t for t in self.tasks.values() if not",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime, \n                 tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            tags=tags or []\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n\n    def export_to_json(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            tasks_dict =",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = self._generate_id()\n        new_task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks.append(new_task)\n        self.save_tasks()\n        return new_task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def filter_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n\n    def _generate_id(self) -> int:\n        if not self.tasks:\n            return 1\n        return max(task.id for task in self.tasks) + 1\n\n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n\n    def load_tasks(self):\n        if not self.storage_path.exists():\n            self.tasks =",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    id: int\n    amount: float\n    date: datetime\n    category: str\n    description: Optional[str] = None\n    \n    def is_expense(self) -> bool:\n        return self.amount < 0\n    \n    def is_income(self) -> bool:\n        return self.amount > 0\n\n\nclass BudgetTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n    \n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    id=int(row['id']),\n                    amount=float(row['amount']),\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    category=row['category'],\n                    description=row.get('description')\n                ))\n    \n    def save_data(self):\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['id', 'amount', 'date', 'category', 'description'])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'id': t.id,\n                    'amount': t.amount,\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'category': t.category,\n                    'description': t.description or ''\n                })\n    \n    def add_transaction(self, amount: float, category: str, description: str = None) -> Transaction:\n        next_id = max([t.id for t in self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        if self.due_date and not self.completed:\n            return datetime.now() > self.due_date\n        return False\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    completed=t[\"completed\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate result\n        result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        task.result = result\n        \n        logger.info(f\"Completed task {task.name} (ID: {task.id})\")\n        return result\n        \n    def execute_workflow(self) -> Dict[int, Any]:\n        results = {}\n        processed_tasks = set()\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(processed_tasks) < len(self.tasks):\n                ready_tasks = []\n                \n                # Find tasks with satisfied dependencies\n                for task_id, task in self.tasks.items():\n                    if task_id not in processed_tasks and all(dep in processed_tasks for",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, name: str, description: str) -> int:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        self.logger.info(f\"Task created: {task.name} (ID: {task.id})\")\n        return task_id\n    \n    def assign_task(self, task_id: int, person: str) -> bool:\n        task = self._get_task_by_id(task_id)\n        if not task:\n            self.logger.error(f\"Task with ID {task_id} not found\")\n            return False\n        \n        task.assigned_to = person\n        task.status = TaskStatus.IN_PROGRESS\n        self.logger.info(f\"Task {task_id} assigned to {person}\")\n        return True\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self._get_task_by_id(task_id)",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport os\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_complete(self):\n        self.completed = True\n        return self\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks = []\n        self.storage_path = storage_path\n        self.load_tasks()\n\n    def add_task(self, task: Task) -> Task:\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n\n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            tasks_dict = [\n                {\n                    \"id\": t.id,\n                    \"title\": t.title,\n                    \"description\": t.description,\n                    \"completed\": t.completed,\n                    \"due_date\": t.due_date.isoformat() if t.due_date else None,\n                    \"tags\":",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\nimport argparse\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    description: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task_data) for task_data in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, FileNotFoundError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n                self.tasks = []\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n            self.tasks = []\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, task: Task):\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def get_tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def delete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            del self.tasks[index]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_stats(self) -> Dict:\n        completed = sum(1 for task in self.tasks if task.completed)\n        return {\n            \"total\": len(self.tasks),\n            \"completed\": completed,\n            \"pending\": len(self.tasks) - completed\n        }\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n    \n    def __str__(self) -> str:\n        return f\"Task {self.id}: {self.name} ({self.status.name})\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.completed_task_ids: List[int] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added {task}\")\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def process_tasks(self) -> None:\n        pending_tasks = [t for t in self.tasks if t.status == TaskStatus.PENDING]\n        \n        for task in pending_tasks:\n            if task.can_start(self.completed_task_ids):\n                task.status = TaskStatus.IN_PROGRESS\n                logger.info(f\"Started {task}\")\n                \n                # Simulate task execution\n                success = random.",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        return self\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass ItemType(Enum):\n    WEAPON = auto()\n    ARMOR = auto()\n    POTION = auto()\n    TREASURE = auto()\n\n@dataclass\nclass Item:\n    name: str\n    item_type: ItemType\n    value: int\n    weight: float\n    \n    def __post_init__(self):\n        if self.value < 0:\n            logger.warning(f\"Negative value for {self.name}, setting to 0\")\n            self.value = 0\n        if self.weight <= 0:\n            logger.warning(f\"Invalid weight for {self.name}, setting to 0.1\")\n            self.weight = 0.1\n\nclass Inventory:\n    def __init__(self, capacity: float):\n        self.items: List[Item] = []\n        self.capacity = capacity\n        \n    def add_item(self, item: Item) -> bool:\n        current_weight = sum(i.weight for i in self.items)\n        if current_weight + item.weight <= self.capacity:\n            self.items.append(item)\n            logger.info(f\"Added {item.name} to inventory\")\n            return True\n        logger.warning(f\"Cannot add {item.name}: exceeds capacity\")\n        return False\n    \n    def get_items_by_type(self, item_type: ItemType) -> List[Item]:\n        return [item for item in self.items if item.item_type == item_type]\n    \n    def get_total_value(self) -> int:\n        return sum(item.value for item in self.items)\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    tags: List[str] = None\n\n    def __post_init__(self):\n        self.tags = self.tags or []\n        if self.price < 0:\n            raise ValueError(\"Price cannot be negative\")\n\n\nclass Inventory:\n    def __init__(self, data_file: Path):\n        self.data_file = data_file\n        self.products: Dict[int, Product] = {}\n        self._load_data()\n\n    def _load_data(self) -> None:\n        if not self.data_file.exists():\n            logger.warning(f\"Data file {self.data_file} not found. Starting with empty inventory.\")\n            return\n        \n        try:\n            with open(self.data_file, 'r') as f:\n                data = json.load(f)\n                for item in data:\n                    self.products[item['id']] = Product(**item)\n            logger.info(f\"Loaded {len(self.products)} products from {self.data_file}\")\n        except json.JSONDecodeError:\n            logger.error(f\"Invalid JSON in {self.data_file}\")\n        except Exception as e:\n            logger.error(f\"Error loading data: {e}\")\n\n    def save_data(self) -> None:\n        with open(self.data_file, 'w') as f:\n            json.dump([vars(p) for p in self.products.values()], f, indent=2)\n        logger.info(f\"Saved {len(self.products)} products to {self.data_file}\")\n\n    def add_product(self, product: Product) -> None:",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: Optional[str] = None, tags: List[str] = None) -> Task:\n        due_date_obj = datetime.fromisoformat(due_date) if due_date else None\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date_obj, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if key == 'due_date' and value and isinstance(value, str):\n                    value = datetime.fromisoformat(value)\n                setattr(task, key, value)\n            self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n\n    def",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    assigned_to: Optional[str] = None\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, task: Task) -> int:\n        task_id = self.next_id\n        self.tasks[task_id] = task\n        self.next_id += 1\n        logger.info(f\"Added task {task_id}: {task.name}\")\n        return task_id\n    \n    def update_status(self, task_id: int, new_status: TaskStatus) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        # Check if dependencies are completed\n        if new_status == TaskStatus.IN_PROGRESS:\n            for dep_id in self.tasks[task_id].dependencies:\n                if dep_id in self.tasks and self.tasks[dep_id].status != TaskStatus.DONE:\n                    logger.warning(f\"Cannot start task {task_id}: dependency {dep_id} not completed\")\n                    return False\n        \n        self.tasks[task_id].status = new_status\n        logger.info(f\"Updated task {task_i",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n    \n    def execute(self) -> bool:\n        try:\n            logger.info(f\"Executing task: {self.name}\")\n            # Simulate work with random success/failure\n            success = random.random() > 0.2\n            self.status = TaskStatus.COMPLETED if success else TaskStatus.FAILED\n            return success\n        except Exception as e:\n            logger.error(f\"Error executing task {self.name}: {e}\")\n            self.status = TaskStatus.FAILED\n            return False\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.completed_task_ids: List[int] = []\n    \n    def add_task(self, task: Task) -> int:\n        self.tasks.append(task)\n        return len(self.tasks) - 1\n    \n    def run(self) -> bool:\n        all_completed = True\n        \n        while True:\n            progress_made = False\n            \n            for i, task in enumerate(self.tasks):\n                if task.status == TaskStatus.PENDING and task.can_start(self.completed_task_ids):",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags or [],\n            \"due_date\": self.due_date\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Task':\n        return cls(\n            id=data[\"id\"],\n            name=data[\"name\"],\n            priority=data[\"priority\"],\n            completed=data.get(\"completed\", False),\n            tags=data.get(\"tags\", []),\n            due_date=data.get(\"due_date\")\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task.from_dict(task_data) for task_data in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict[\"due_date\"] = datetime.fromisoformat(task_dict[\"due_date\"])\n                    self.tasks[task_dict[\"id\"]] = Task(**task_dict)\n        except (FileNotFoundError, json.JSONDecodeError):\n            self.tasks = {}\n\n    def _save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            tasks_list = []\n            for task in self.tasks.values():\n                task_dict = task.__dict__.copy()\n                task_dict[\"due_date\"] = task_dict[\"due_date\"].isoformat()\n                tasks_list.append(task_dict)\n            json.dump(tasks_list, f, indent=2)\n\n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None, \n                 tags: List[str] = None) -> Task:\n        if due_date is None:\n            due_date = datetime.now() + timedelta(days=7)\n        task_id = random.randint(1000, 9999)\n        while task_id in self.tasks:\n            task_id = random.randint(1000, 9999)\n        \n        task = Task(id=task_i",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n                        self.next_id = max(self.next_id, task.id + 1)\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.to_dict() for task in self.tasks.values()], f, indent=2)\n            logger",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n\n    def execute_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n\n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                return None\n\n        # Simulate task execution\n        time.sleep(task.duration)\n        result = f\"Task {task.name} (ID: {task.id}) completed\"\n        self.results[task_id] = result\n        return result\n\n    def run_parallel(self, max_workers: int = 3) -> List[str]:\n        remaining_tasks = set(self.tasks.keys())\n        results = []\n\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while remaining_tasks:\n                eligible_tasks = []\n                for task_id in remaining_tasks:\n                    task = self.tasks[task_id]\n                    if all(dep in self.results for dep in task.dependencies):\n                        eligible_tasks.append((task_id, task.priority))\n\n                if not eligible_tasks:\n                    break\n\n                # Sort by priority (higher first)\n                eligible_tasks.sort(key=lambda x: x[1], reverse=True)\n                \n                futures = {executor.submit(self.execute_task, task_id): task_id \n                           for task_id, _ in eligible_tasks[:max_workers]}\n                \n                for",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return asdict(self)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(\n            title=title,\n            description=description,\n            created_at=datetime.now()\n        )\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> Optional[Task]:\n        if 0 <= index < len(self.tasks):\n            task = self.tasks[index]\n            task.complete()\n            self.save_tasks()\n            return task\n        return None\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            self.tasks = []\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [\n                    Task(\n                        title=item['title'],\n                        description=item['description'],\n                        created_at=datetime.fromisoformat(item['created_at']),\n                        completed=item['completed'],\n                        completed_at=datetime.fromisoformat(item['completed_at']) \n                            if item['completed_at'] else None\n                    )\n                    for item in data\n                ]\n        except (",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending = self.get_pending_tasks()\n        if not pending:\n            return None\n        return max(pending, key=lambda t:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n        \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created new task: {name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_completed_tasks(self)",
    "import os\nimport json\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_dict in tasks_data:\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        complete",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        task_dict = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            task_dict[\"due_date\"] = self.due_date.isoformat()\n        return task_dict\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as file:\n                tasks_data = json.load(file)\n                \n            self.tasks = []\n            for task_data in tasks_data:\n                due_date = None\n                if \"due_date\" in task_data:\n                    due_date = datetime.fromisoformat(task_data[\"due_date\"])\n                \n                task = Task(\n                    id=task_data[\"id\"],\n                    title=task_data[\"title\"],\n                    description=task",
    "import logging\nimport os\nimport time\nfrom dataclasses import dataclass\nfrom functools import wraps\nfrom typing import Callable, Dict, List, Optional, TypeVar\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef retry(max_attempts: int = 3, delay: float = 1.0):\n    \"\"\"Decorator to retry a function on exception.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> T:\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    if attempts == max_attempts:\n                        logger.error(f\"Failed after {max_attempts} attempts: {e}\")\n                        raise\n                    logger.warning(f\"Attempt {attempts} failed: {e}. Retrying in {delay}s...\")\n                    time.sleep(delay)\n            return None  # This should never be reached\n        return wrapper\n    return decorator\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    completed: bool = False\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n        \n    def add_task(self, name: str) -> int:\n        task_id = self.next_id\n        self.tasks[task_id] = Task(id=task_id, name=name)\n        self.next_id += 1\n        logger.info(f\"Added task '{name}' with ID {task_id}\")\n        return task_id",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom pathlib import Path\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    modified: float\n    content_hash: Optional[str] = None\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, file_extensions: List[str] = None):\n        self.root_dir = Path(root_dir)\n        self.file_extensions = file_extensions or ['.txt', '.py', '.json']\n        self.results = []\n    \n    def _hash_file_content(self, file_path: Path) -> str:\n        import hashlib\n        try:\n            with open(file_path, 'rb') as f:\n                return hashlib.md5(f.read()).hexdigest()\n        except Exception as e:\n            logger.error(f\"Failed to hash {file_path}: {e}\")\n            return None\n    \n    def process_file(self, file_path: Path) -> Optional[FileInfo]:\n        try:\n            if file_path.suffix not in self.file_extensions:\n                return None\n            \n            stats = file_path.stat()\n            file_info = FileInfo(\n                path=str(file_path.relative_to(self.root_dir)),\n                size=stats.st_size,\n                modified=stats.st_mtime,\n                content_hash=self._hash_file_content(file_path)\n            )\n            return file_info\n        except Exception as e:\n            logger.error(f\"Error processing {file_path}: {e}\")\n            return None\n    \n    def analyze(self, max_workers: int = 4) -> List[FileInfo]:\n        start_time = time.time()\n        files_to_",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def save_tasks(self",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_expense: bool = True\n\n\nclass BudgetTracker:\n    def __init__(self, filename: str = \"transactions.csv\"):\n        self.filename = filename\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n    \n    def _load_transactions(self):\n        if not os.path.exists(self.filename):\n            return\n        \n        with open(self.filename, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description'],\n                    is_expense=row['is_expense'].lower() == 'true'\n                ))\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self._save_transactions()\n    \n    def _save_transactions(self) -> None:\n        with open(self.filename, 'w', newline='') as csvfile:\n            fieldnames = ['date', 'amount', 'category', 'description', 'is_expense']\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description,\n                    'is_expense': t.is_expense\n                })\n    \n    def get_balance(self) -> float:\n        return sum([-t.amount if t.is_expense else",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks.values()], f, indent=2)\n            logger.info(\"Tasks saved to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    \nclass ExpenseTracker:\n    def __init__(self, filename: str):\n        self.filename = filename\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n    \n    def _load_transactions(self):\n        if not os.path.exists(self.filename):\n            return\n            \n        with open(self.filename, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description']\n                ))\n    \n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_transactions()\n        \n    def _save_transactions(self):\n        with open(self.filename, 'w', newline='') as csvfile:\n            writer = csv.DictWriter(csvfile, fieldnames=['date', 'amount', 'category', 'description'])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description\n                })\n    \n    def get_summary_by_category(self) -> Dict[str, float]:\n        summary = {}\n        for t in self.transactions:\n            summary[t.category] = summary.get(t.category, 0) + t.amount\n        return summary\n\nif __name__ == \"__main__\":\n    tracker = ExpenseTracker(\"expenses.csv\")\n    \n    # Add some sample transactions",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    dependencies: List[int]\n    completed: bool = False\n    result: Optional[Any] = None\n\nclass TaskManager:\n    def __init__(self, config_path: str):\n        self.tasks: Dict[int, Task] = {}\n        self.config_path = config_path\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.config_path):\n            logger.warning(f\"Config file {self.config_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.config_path, 'r') as f:\n                data = json.load(f)\n                for task_data in data.get('tasks', []):\n                    task = Task(\n                        id=task_data['id'],\n                        name=task_data['name'],\n                        priority=task_data['priority'],\n                        dependencies=task_data.get('dependencies', []),\n                        completed=task_data.get('completed', False)\n                    )\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from config\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        data = {'tasks': []}\n        for task in self.tasks.values():\n            task_dict = {\n                'id': task.id,\n                'name': task.name,\n                'priority': task.priority,",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    humidity: int\n    description: str\n    wind_speed: float\n\nclass WeatherService:\n    def __init__(self, api_key: str, base_url: str = \"https://api.example.com/weather\"):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.cache: Dict[str, WeatherData] = {}\n    \n    def get_weather(self, city: str) -> Optional[WeatherData]:\n        if city in self.cache:\n            logger.info(f\"Cache hit for {city}\")\n            return self.cache[city]\n        \n        try:\n            logger.info(f\"Fetching weather data for {city}\")\n            response = requests.get(\n                f\"{self.base_url}\",\n                params={\"city\": city, \"api_key\": self.api_key},\n                timeout=5\n            )\n            response.raise_for_status()\n            data = response.json()\n            \n            weather = WeatherData(\n                city=city,\n                temperature=data[\"temperature\"],\n                humidity=data[\"humidity\"],\n                description=data[\"description\"],\n                wind_speed=data[\"wind_speed\"]\n            )\n            \n            self.cache[city] = weather\n            return weather\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching weather for {city}: {e}\")\n            return None\n\ndef get_weather_for_cities(cities: List[str], api_key: str) -> Dict[str, Optional[WeatherData]]:\n    service = WeatherService(api_key)\n    results = {}\n    \n    with ThreadPoolExecutor(max_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n    \n    def execute(self) -> bool:\n        try:\n            logger.info(f\"Executing task: {self.name}\")\n            self.status = TaskStatus.IN_PROGRESS\n            \n            # Simulate work with some randomness\n            success = random.random() > 0.2\n            \n            if success:\n                self.status = TaskStatus.COMPLETED\n                logger.info(f\"Task {self.name} completed successfully\")\n            else:\n                self.status = TaskStatus.FAILED\n                logger.warning(f\"Task {self.name} failed\")\n            \n            return success\n        except Exception as e:\n            logger.error(f\"Error executing task {self.name}: {str(e)}\")\n            self.status = TaskStatus.FAILED\n            return False\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.completed_task_ids: List[int] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.debug(f\"Added task: {task.name}\")",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, worker: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task with status {self.status}\")\n        \n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = worker\n        logger.info(f\"Task {self.id} started by {worker}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        \n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"New task created: {task.name} (ID: {task.id})\")\n        return task",
    "import random\nfrom typing import List, Dict, Optional\nfrom dataclasses import dataclass\nfrom collections import defaultdict\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self):\n        self._tasks: Dict[int, Task] = {}\n        self._tasks_by_priority = defaultdict(list)\n        self._next_id = 1\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self._next_id, name=name, priority=priority)\n        self._tasks[task.id] = task\n        self._tasks_by_priority[priority].append(task.id)\n        self._next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self._tasks.get(task_id)\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            return task.complete()\n        return None\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        for priority in sorted(self._tasks_by_priority.keys(), reverse=True):\n            task_ids = [tid for tid in self._tasks_by_priority[priority] \n                       if not self._tasks[tid].completed]\n            if task_ids:\n                return self._tasks[task_ids[0]]\n        return None\n    \n    def get_stats(self) -> Dict[str, int]:\n        completed = sum(1 for task in self._tasks.values() if task.completed)\n        return {\n            \"total\": len(self._tasks),\n            \"completed\": completed,\n            \"pending\": len(self._tasks) - completed\n        }\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some sample tasks",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        logger.warning(f\"Task with ID {task_id} not",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    id: int\n    name: str\n    value: float\n    category: str\n\n\nclass Inventory:\n    def __init__(self):\n        self.items: List[Item] = []\n    \n    def add_item(self, item: Item) -> None:\n        logger.info(f\"Adding item: {item.name}\")\n        self.items.append(item)\n    \n    def remove_item(self, item_id: int) -> Optional[Item]:\n        for index, item in enumerate(self.items):\n            if item.id == item_id:\n                logger.info(f\"Removing item: {item.name}\")\n                return self.items.pop(index)\n        logger.warning(f\"Item with id {item_id} not found\")\n        return None\n    \n    def get_total_value(self) -> float:\n        return sum(item.value for item in self.items)\n    \n    def get_items_by_category(self, category: str) -> List[Item]:\n        return [item for item in self.items if item.category == category]\n\n\n@lru_cache(maxsize=128)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n\ndef main():\n    # Create inventory\n    inventory = Inventory()\n    \n    # Generate some random items\n    categories = [\"Electronics\", \"Books\", \"Clothing\", \"Food\"]\n    \n    for i in range(10):\n        item = Item(\n            id=i,\n            name=f\"Item-{i}\",\n            value=random.uniform(10.0, 100.0),\n            category=random.choice(categories)",
    "import os\nimport json\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, starting fresh\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_dict in tasks_data:\n                due_date = None\n                if task_dict.get(\"due_date\"):\n                    due_date = datetime.fromisoformat(task_dict[\"due_date\"])\n                \n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom typing import List, Optional\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        logger.info(\"Task Manager initialized\")\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return task\n    \n    def assign_task(self, task_id: int, assignee: str) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.assigned_to = assignee\n            task.status = TaskStatus.IN_PROGRESS\n            logger.info(f\"Assigned task {task_id} to {assignee}\")\n            return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.status = TaskStatus.COMPLETED\n            logger.info(f\"Marked task {task_id} as completed\")\n            return True\n        return False\n    \n    def get_task(self, task_id: int) -> Optional[Task]:",
    "import os\nimport json\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def get_high_priority_tasks(self, min_priority: int = 8) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n\ndef generate_sample_tasks(count: int = 5) -> List[Task]:\n    tasks = []\n    for i in range(1, count + 1):\n        # Random due date between yesterday and 7 days from now\n        days_offset = random.randint(-1, 7)\n        due_date = datetime.now() + timedelta(days=days_offset)\n        \n        tasks.append(Task(\n            id=i,\n            name=f",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        data_copy = data.copy()\n        data_copy[\"created_at\"] = datetime.fromisoformat(data_copy[\"created_at\"])\n        return cls(**data_copy)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = {\n                        task_id: Task.from_dict(task_data)\n                        for task_id, task_data in tasks_data.items()\n                    }\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def mark_complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime,\n                 priority: int, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            priority=priority,\n            tags=tags or []\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n\n    def get_tasks_by_priority(self, min_priority: int = 1) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def export_to_json(self, filename: str)",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, description=description, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                logger.info(f\"Completed task: {task}\")\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def get_pending_tasks(self, sort_by_priority: bool = False) -> List[Task]:\n        pending = [task for task in self.tasks if not task.completed]\n        if sort_by_priority:\n            pending.sort(key=lambda x: x.priority, reverse=True)\n        return pending\n\ndef demo_task_manager():\n    manager = TaskManager()\n    \n    # Add some tasks\n    tasks = [\n        (\"Implement user authentication\", 3),\n        (\"Fix bug in payment module\", 5),\n        (\"Update documentation\", 2),\n        (\"Refactor database layer\", 4)\n    ]\n    \n    for desc, priority in tasks:\n        manager.add_task(desc, priority)\n    \n    # Complete",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=task[\"id\"],\n                    title=task[\"title\"],\n                    description=task[\"description\"],\n                    completed=task[\"completed\"],\n                    created_at=datetime.fromisoformat(task[\"created_at\"]),\n                    completed_at=datetime.fromisoformat(task[\"complete",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        new_task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks.append(new_task)\n        logger.info(f\"Added task: {new_task.title}\")\n        self.save_tasks()\n        return new_task\n        \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport logging\nfrom pathlib import Path\nimport argparse\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[str] = None\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        self.tasks[task.name] = task\n        self.save_tasks()\n        return True\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        del self.tasks[task_name]\n        self.save_tasks()\n        return True\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(\"No existing tasks file found\")\n            return\n        \n        try:\n            data = json.loads(self.storage_path.rea",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    task_dicts = json.load(f)\n                    self.tasks = [Task(**task) for task in task_dicts]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) ->",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item[\"id\"],\n                            title=item[\"title\"],\n                            description=item[\"description\"],\n                            completed=item[\"completed\"],\n                            created_at=datetime.fromisoformat(item[\"created_at\"]),\n                            completed_at=datetime.fromisoformat(item[\"completed_at\"]) if item[\"completed_at\"] else None\n                        )\n                        for item in data\n                    ]\n                logger.info(f",
    "import logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    metadata: Dict[str, Any] = field(default_factory=dict)\n    created_at: float = field(default_factory=time.time)\n    completed_at: Optional[float] = None\n\n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = time.time()\n        \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"metadata\": self.metadata,\n            \"created_at\": self.created_at,\n            \"completed_at\": self.completed_at\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        logger.info(f\"Adding task: {task.name}\")\n        self.tasks.append(task)\n        self._save_tasks()\n        \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name and not task.completed:\n                task.complete()\n                logger.info(f\"Completed task: {task.name}\")\n                self._save_tasks()\n                return True\n        return False\n    \n    def get_pending_tasks(self, tag:",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        due_date = None\n                        if task_data.get('due_date'):\n                            due_date = datetime.fromisoformat(task_data['due_date'])\n                        self.tasks[task_id] = Task(\n                            name=task_data['name'],\n                            description=task_data['description'],\n                            due_date=due_date,\n                            completed=task_data['completed'],\n                            tags=task_data['tags']\n                        )\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks:",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with id {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending_tasks = self.get_pending_tasks()\n        if not pending_tasks:",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.next_id = 1\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        self._save_tasks()\n        logger.info(f\"Completed task ID: {task_id}\")\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path,",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task_by_name(self, name: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.name == name:\n                return task\n        return None\n    \n    def save(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Tasks saved to {self.storage_path}\")\n    \n    def load(self) -> None:\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file {self.storage_path} not found\")\n            return\n        \n        with open(self.storage_path, 'r') as f:\n            data = json.load(f)",
    "import logging\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport threading\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    assigned_to: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.lock = threading.Lock()\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, 'r') as f:\n                    task_dicts = json.load(f)\n                    self.tasks = [Task(**task) for task in task_dicts]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        with self.lock:\n            task_id = max([t.id for t in self.tasks], default=0) + 1\n            task = Task(id=task_id, name=name, priority=priority)\n            self.tasks.append(task)\n            self",
    "import time\nfrom functools import wraps\nfrom typing import Callable, TypeVar, Any, List, Dict\nimport logging\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef retry(max_attempts: int = 3, delay: float = 1.0):\n    \"\"\"Decorator that retries a function if it raises an exception.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> T:\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    if attempts == max_attempts:\n                        logger.error(f\"Failed after {max_attempts} attempts: {e}\")\n                        raise\n                    logger.warning(f\"Attempt {attempts} failed: {e}. Retrying in {delay} seconds...\")\n                    time.sleep(delay)\n            return None  # This line should never be reached\n        return wrapper\n    return decorator\n\nclass DataProcessor:\n    def __init__(self, name: str):\n        self.name = name\n        self.data: List[Dict[str, Any]] = []\n    \n    @retry(max_attempts=5, delay=0.5)\n    def fetch_data(self, data_id: int) -> Dict[str, Any]:\n        \"\"\"Simulate fetching data that might fail occasionally.\"\"\"\n        if random.random() < 0.7:  # 70% chance of failure on first try\n            raise ConnectionError(\"Network error occurred\")\n        return {\"id\": data_id, \"timestamp\": time.time(), \"value\": random.randint(1, 100)}\n    \n    def process_batch(self, batch_ids: List[int]) -> None:\n        \"\"\"Process a batch of data items.\"\"\"\n        logger",
    "import csv\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport os\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_expense: bool = True\n    \n    @property\n    def formatted_date(self) -> str:\n        return self.date.strftime(\"%Y-%m-%d\")\n    \n    @property\n    def signed_amount(self) -> float:\n        return -self.amount if self.is_expense else self.amount\n\nclass BudgetTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n        \n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            logger.info(f\"No existing data file found at {self.data_file}\")\n            return\n            \n        try:\n            with open(self.data_file, 'r', newline='') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    self.transactions.append(Transaction(\n                        date=datetime.strptime(row['date'], \"%Y-%m-%d\"),\n                        amount=float(row['amount']),\n                        category=row['category'],\n                        description=row['description'],\n                        is_expense=row['is_expense'].lower() == 'true'\n                    ))\n            logger.info(f\"Loaded {len(self.transactions)} transactions\")\n        except Exception as e:\n            logger.error(f\"Error loading data: {e}\")\n            \n    def save_data(self) -> None:\n        try:\n            with open(self.data_file, 'w', new",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: Optional[str] = None\n\n\nclass ExpenseTracker:\n    def __init__(self, filename: str = \"expenses.csv\"):\n        self.filename = filename\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n\n    def _load_transactions(self):\n        if not os.path.exists(self.filename):\n            return\n        \n        with open(self.filename, 'r', newline='') as csvfile:\n            reader = csv.reader(csvfile)\n            next(reader)  # Skip header\n            for row in reader:\n                date = datetime.strptime(row[0], \"%Y-%m-%d\")\n                amount = float(row[1])\n                category = row[2]\n                description = row[3] if row[3] else None\n                self.transactions.append(Transaction(date, amount, category, description))\n\n    def add_transaction(self, amount: float, category: str, description: str = None, \n                         date: datetime = None):\n        if date is None:\n            date = datetime.now()\n        transaction = Transaction(date, amount, category, description)\n        self.transactions.append(transaction)\n        self._save_transactions()\n        return transaction\n\n    def _save_transactions(self):\n        with open(self.filename, 'w', newline='') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow(['Date', 'Amount', 'Category', 'Description'])\n            for t in self.transactions:\n                writer.writerow([\n                    t.date.strftime(\"%Y-%m-%d\"), \n                    t.amount, \n                    t.category, \n                    t.description or ''\n                ])\n\n    def get_total_by_category(self):\n        totals = {}\n        for t in self.transactions:\n            if t.category not in totals:\n                totals",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n    \n    def add_task(self, title, description, due_date, priority=1, tags=None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            priority=priority,\n            tags=tags\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n    \n    def get_high_priority_tasks(self, min_priority=3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def get_tasks_by_tag(self, tag) -> List",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def find_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def _load_tasks(self) -> None:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass FruitType(Enum):\n    APPLE = auto()\n    BANANA = auto()\n    ORANGE = auto()\n    GRAPE = auto()\n    PEAR = auto()\n\n@dataclass\nclass Fruit:\n    type: FruitType\n    weight: float\n    ripe: bool = False\n    \n    def ripen(self) -> None:\n        if not self.ripe:\n            self.ripe = True\n            logger.info(f\"{self.type.name} has ripened\")\n    \n    @property\n    def is_heavy(self) -> bool:\n        weights = {\n            FruitType.APPLE: 0.2,\n            FruitType.BANANA: 0.15,\n            FruitType.ORANGE: 0.25,\n            FruitType.GRAPE: 0.01,\n            FruitType.PEAR: 0.18\n        }\n        return self.weight > weights.get(self.type, 0.1)\n\nclass FruitBasket:\n    def __init__(self, capacity: int = 10):\n        self.capacity = capacity\n        self.fruits: List[Fruit] = []\n    \n    def add_fruit(self, fruit: Fruit) -> bool:\n        if len(self.fruits) >= self.capacity:\n            logger.warning(\"Basket is full, cannot add more fruits\")\n            return False\n        \n        self.fruits.append(fruit)\n        logger.info(f\"Added {fruit.type.name} to the basket\")\n        return True\n    \n    def get_ripe_fruits(self) -> List[Fruit]:\n        return [fruit for fruit in self.fruits if fruit.ripe]\n    \n    def ripen_all(self",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Task {task_id} added: {name}\")\n        return task\n    \n    def assign_task(self, task_id: int, person: str) -> bool:\n        task = self._get_task_by_id(task_id)\n        if not task:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        task.assigned_to = person\n        task.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {task_id} assigned to {person}\")\n        return True\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self._get_task_by_id(task_id)\n        if not task:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        task.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {task_id} marked as completed\")\n        return",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n            \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> Task:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        return task\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n        \n    def get_incomplete_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n        \n    def save(self) -> bool:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Tasks saved to {self.storage_path}\")\n            return True\n        except Exception as e:\n            logger.error(",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None, \n                 tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            due_date=due_date,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    genre: str\n    rating: float = 0.0\n    \n    def __post_init__(self):\n        if self.rating < 0 or self.rating > 5:\n            raise ValueError(\"Rating must be between 0 and 5\")\n\nclass Library:\n    def __init__(self, name: str):\n        self.name = name\n        self.books: List[Book] = []\n        \n    def add_book(self, book: Book) -> None:\n        self.books.append(book)\n        logger.info(f\"Added book: {book.title} by {book.author}\")\n        \n    def find_books_by_author(self, author: str) -> List[Book]:\n        return [book for book in self.books if book.author.lower() == author.lower()]\n    \n    def get_books_by_genre(self, genre: str) -> List[Book]:\n        return [book for book in self.books if book.genre.lower() == genre.lower()]\n    \n    def save_to_file(self, filepath: str) -> None:\n        data = {\n            \"name\": self.name,\n            \"books\": [\n                {\n                    \"title\": book.title,\n                    \"author\": book.author,\n                    \"year\": book.year,\n                    \"genre\": book.genre,\n                    \"rating\": book.rating\n                }\n                for book in self.books\n            ]\n        }\n        \n        with open(filepath, 'w') as f:\n            json.dump(data, f, indent=2)\n        logger.info(f\"Library saved to {filepath}\")\n    \n    @classmethod\n    def load_from_file(cls, filepath:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> Task:\n        if not self.tasks:\n            task.id = 1\n        else:\n            task.id = max(t.id for t in self.tasks) + 1\n        self.tasks.append(task)\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            logger.info(f\"Deleted task: {task.title",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, name: str, description: str, tags: List[str] = None, priority: int = 1) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(\n            name=name,\n            description=description,\n            tags=tags or [],\n            priority=priority\n        )\n        self.tasks[name] = task\n        self.save_tasks()\n        return task\n\n    def complete_task(self, name: str) -> None:\n        if name not in self.tasks:\n            raise ValueError(f\"Task '{name}' not found\")\n        \n        self.tasks[name].completed = True\n        self.save_tasks()\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({\n                name: {\n                    **task.__dict__,\n                    'created_at': task.created_at.iso",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n                self.tasks = []\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n    def mark_complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks[task_id] = task\n        logger.info(f\"Task created: {task.title}\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Task {task_id} deleted\")\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def save_tasks(self)",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    name: str\n    weight: float\n    value: float\n\n    def value_density(self) -> float:\n        return self.value / self.weight if self.weight > 0 else 0\n\nclass Knapsack:\n    def __init__(self, capacity: float):\n        self.capacity = capacity\n        self.items: List[Item] = []\n        self.current_weight = 0\n        self.current_value = 0\n    \n    def add_item(self, item: Item) -> bool:\n        if self.current_weight + item.weight <= self.capacity:\n            self.items.append(item)\n            self.current_weight += item.weight\n            self.current_value += item.value\n            logger.info(f\"Added {item.name} to knapsack\")\n            return True\n        return False\n    \n    def __str__(self) -> str:\n        return f\"Knapsack: {len(self.items)} items, weight={self.current_weight:.2f}, value={self.current_value:.2f}\"\n\nclass PackingStrategy(ABC):\n    @abstractmethod\n    def pack(self, items: List[Item], knapsack: Knapsack) -> None:\n        pass\n\nclass GreedyValueStrategy(PackingStrategy):\n    def pack(self, items: List[Item], knapsack: Knapsack) -> None:\n        sorted_items = sorted(items, key=lambda x: x.value, reverse=True)\n        for item in sorted_items:\n            knapsack.add_item(item)\n\nclass GreedyDensityStrategy(PackingStrategy):\n    def pack(self, items: List[Item], knapsack: Knapsack) -> None:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Wait for dependencies to complete\n        for dep_id in task.dependencies:\n            if dep_id not in self.tasks or self.tasks[dep_id].result is None:\n                raise ValueError(f\"Dependency {dep_id} not completed for task {task_id}\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        result = f\"Result of task {task.name} with {random.randint(1, 100)}\"\n        task.result = result\n        return result\n    \n    def execute_all(self) -> Dict[int, Any]:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Find tasks with no dependencies\n            ready_tasks = [t.id for t in self.tasks.values() if not t.dependencies]\n            futures = {executor.submit(self.process_task, task",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        name=t[\"name\"],\n                        description=t[\"description\"],\n                        completed=t[\"completed\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                    ) for t in tasks_data\n                ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.debug(f\"Added tag '{tag}' to task {self.id}\")\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._next_id = 1\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(id=self._next_id, title=title, description=description)\n        self.tasks.append(task)\n        self._next_id += 1\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with id {task_id} not found\")\n        return None\n    \n    def save(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json_data = [\n                    {\n                        'name': task.name,\n                        'priority': task.priority,\n                        'created_at': task.created_at.isoformat(),",
    "import os\nimport json\nimport logging\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return asdict(self)\n        \nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_id, task_dict in tasks_data.items():\n                # Convert string dates to datetime objects\n                task_dict[\"created_at\"] = datetime.fromisoformat(task_dict[\"created_at\"])\n                if task_dict[\"completed_at\"]:\n                    task_dict[\"completed_at\"] = datetime.fromisoformat(task_dict[\"completed_at\"])\n                self.tasks[task_id] = Task(**task_dict)\n                \n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            \n    def",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom pathlib import Path\nimport json\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: Path\n    size: int\n    extension: str\n    is_hidden: bool\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, excluded_dirs: Optional[List[str]] = None):\n        self.root_dir = Path(root_dir)\n        self.excluded_dirs = excluded_dirs or ['.git', 'node_modules', '__pycache__']\n        self.results: Dict[str, List[FileInfo]] = {}\n        \n    def analyze(self) -> Dict[str, List[FileInfo]]:\n        \"\"\"Analyze files in the directory structure.\"\"\"\n        if not self.root_dir.exists():\n            logger.error(f\"Directory {self.root_dir} does not exist\")\n            return {}\n            \n        logger.info(f\"Starting analysis of {self.root_dir}\")\n        \n        with ThreadPoolExecutor() as executor:\n            for root, dirs, files in os.walk(self.root_dir):\n                # Skip excluded directories\n                dirs[:] = [d for d in dirs if d not in self.excluded_dirs]\n                \n                # Process files in parallel\n                root_path = Path(root)\n                file_paths = [root_path / file for file in files]\n                executor.map(self._process_file, file_paths)\n                \n        logger.info(f\"Analysis complete. Found {sum(len(files) for files in self.results.values())} files\")\n        return self.results\n    \n    def _process_file(self, file_path: Path) -> None:\n        \"\"\"Process a single file.\"\"\"\n        try:\n            if not file_path.exists():\n                return",
    "import logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[str] = field(default_factory=list)\n    \n    def can_execute(self, completed_tasks: List[str]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n    \n    def execute(self) -> bool:\n        try:\n            logger.info(f\"Executing task: {self.name} (priority: {self.priority})\")\n            # Simulate work with a random success rate\n            success = random.random() > 0.2\n            self.status = TaskStatus.COMPLETED if success else TaskStatus.FAILED\n            return success\n        except Exception as e:\n            logger.error(f\"Task {self.name} failed with error: {e}\")\n            self.status = TaskStatus.FAILED\n            return False\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.completed_tasks: List[str] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.debug(f\"Added task: {task.name}\")\n    \n    def run(self) -> None:\n        # Sort tasks by priority (higher number = higher priority)\n        self.tasks.sort(key=lambda x: x.priority, reverse=True)\n        \n        while self.tasks:\n            executable_tasks = [\n                task for task in self.tasks \n                if task.can_execute(self",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    for task_id, task_dict in tasks_data.items():\n                        self.tasks[int(task_id)] = Task(**task_dict)\n            except (json.JSONDecodeError, FileNotFoundError):\n                self.tasks = {}\n    \n    def _save_tasks(self):\n        tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n        with open(self.storage_path, \"w\") as f:\n            json.dump(tasks_dict, f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n    \n    def get_task(self, task_id:",
    "import os\nimport json\nfrom datetime import datetime\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional, Dict, Any\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in data.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({str(k): asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    completed: bool = False\n    result: Optional[str] = None\n\nclass TaskProcessor:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def process_task(self, task: Task) -> Task:\n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        task.completed = True\n        task.result = f\"Result for task {task.name}\"\n        logger.info(f\"Completed task: {task.name} (ID: {task.id})\")\n        return task\n    \n    def process_all_tasks(self, max_workers: int = 3) -> List[Task]:\n        sorted_tasks = sorted(self.tasks, key=lambda t: t.priority)\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            completed_tasks = list(executor.map(self.process_task, sorted_tasks))\n        \n        return completed_tasks\n\ndef main():\n    processor = TaskProcessor()\n    \n    # Create some sample tasks\n    for i in range(5):\n        task = Task(\n            id=i,\n            name=f\"Task-{i}\",\n            duration=random.uniform(0.5, 2.0),\n            priority=random.randint(1, 10)\n        )",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def get_ready_tasks(self) -> List[Task]:\n        ready_tasks = []\n        for task_id, task in self.tasks.items():\n            if not task.completed and all(self.tasks[dep_id].completed \n                                         for dep_id in task.dependencies\n                                         if dep_id in self.tasks):\n                ready_tasks.append(task)\n        return ready_tasks\n    \n    def execute_task(self, task: Task) -> None:\n        print(f\"Starting task {task.id}: {task.name}\")\n        time.sleep(task.duration)\n        task.completed = True\n        print(f\"Completed task {task.id}: {task.name}\")\n        \n    def run_parallel(self, max_workers: int = 4) -> None:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while not all(task.completed for task in self.tasks.values()):\n                ready_tasks = self.get_ready_tasks()\n                if not ready_tasks:\n                    time.sleep(0.1)\n                    continue\n                    \n                for task in ready_tasks:\n                    executor.submit(self.execute_task, task)\n                \n                time.sleep(0.5)  # Allow time for tasks to start\n\n\nif __name__ == \"__main__\":\n    scheduler = TaskScheduler()\n    \n    # Create some tasks with dependencies\n    task1 = Task(1, \"Initialize\",",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, description: str) -> Task:\n        task = Task(id=self.next_id, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def assign_task(self, task_id: int, person: str) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.assigned_to = person\n            task.status = TaskStatus.IN_PROGRESS\n            logger.info(f\"Task {task_id} assigned to {person}\")\n            return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.status = TaskStatus.COMPLETED\n            logger.info(f\"Task {task_id} marked as completed\")\n            return True\n        return False\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task {",
    "import csv\nimport argparse\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass SalesRecord:\n    date: str\n    product: str\n    quantity: int\n    price: float\n    \n    @property\n    def total(self) -> float:\n        return self.quantity * self.price\n\n\nclass SalesAnalyzer:\n    def __init__(self, filename: str):\n        self.filename = filename\n        self.records: List[SalesRecord] = []\n        self._load_data()\n        \n    def _load_data(self) -> None:\n        try:\n            with open(self.filename, 'r', newline='') as csvfile:\n                reader = csv.DictReader(csvfile)\n                for row in reader:\n                    self.records.append(SalesRecord(\n                        date=row['date'],\n                        product=row['product'],\n                        quantity=int(row['quantity']),\n                        price=float(row['price'])\n                    ))\n        except FileNotFoundError:\n            print(f\"Error: File {self.filename} not found\")\n    \n    def total_sales(self) -> float:\n        return sum(record.total for record in self.records)\n    \n    def sales_by_product(self) -> Dict[str, float]:\n        result = defaultdict(float)\n        for record in self.records:\n            result[record.product] += record.total\n        return dict(result)\n    \n    def best_selling_product(self) -> Optional[str]:\n        sales = self.sales_by_product()\n        if not sales:\n            return None\n        return max(sales.items(), key=lambda x: x[1])[0]\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Analyze sales data')\n    parser.add_argument('filename', help='CSV file with sales data')\n    args = parser.parse_args()\n    \n    analyzer = SalesAnalyzer(args.filename)\n    \n    print(f\"Total sales: ${analyzer.total_sales():.2",
    "import argparse\nimport csv\nimport json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass SalesRecord:\n    product_id: str\n    quantity: int\n    price: float\n    customer_id: str\n    date: str\n\n    @property\n    def total(self) -> float:\n        return self.quantity * self.price\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_path: Path):\n        self.data_path = data_path\n        self.records: List[SalesRecord] = []\n        self._load_data()\n\n    def _load_data(self) -> None:\n        with open(self.data_path, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self.records.append(SalesRecord(\n                    product_id=row['product_id'],\n                    quantity=int(row['quantity']),\n                    price=float(row['price']),\n                    customer_id=row['customer_id'],\n                    date=row['date']\n                ))\n\n    def get_total_sales(self) -> float:\n        return sum(record.total for record in self.records)\n\n    def get_sales_by_product(self) -> Dict[str, float]:\n        result = {}\n        for record in self.records:\n            result[record.product_id] = result.get(record.product_id, 0) + record.total\n        return result\n\n    def export_summary(self, output_path: Path) -> None:\n        summary = {\n            \"total_sales\": self.get_total_sales(),\n            \"sales_by_product\": self.get_sales_by_product(),\n            \"record_count\": len(self.records)\n        }\n        with open(output_path, 'w') as f:\n            json.dump(summary, f, indent=2)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Analyze sales data')\n    parser.add_argument('--input",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}, creating new task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed=t[\"completed\"],\n                    tags=t.get(\"tags\", [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    completed=t[\"completed\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    tags=t.get(\"tags\", [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskPriority(Enum):\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n    CRITICAL = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: TaskPriority\n    completed: bool = False\n    dependencies: List[int] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.logger = logging.getLogger(__name__)\n\n    def add_task(self, task: Task) -> int:\n        self.tasks.append(task)\n        task_id = len(self.tasks) - 1\n        self.logger.info(f\"Added task '{task.name}' with ID {task_id}\")\n        return task_id\n\n    def complete_task(self, task_id: int) -> bool:\n        if 0 <= task_id < len(self.tasks):\n            task = self.tasks[task_id]\n            \n            # Check if dependencies are completed\n            for dep_id in task.dependencies:\n                if not self.tasks[dep_id].completed:\n                    self.logger.warning(f\"Cannot complete task {task_id}: dependency {dep_id} not completed\")\n                    return False\n            \n            task.completed = True\n            self.logger.info(f\"Marked task {task_id} as completed\")\n            return True\n        return False\n\n    def get_pending_tasks(self, priority: Optional[TaskPriority] = None) -> List[tuple]:\n        result = []\n        for idx, task in enumerate(self.tasks):\n            if not task.completed and (priority is None or task.priority == priority):\n                result.append((idx, task))\n        return result\n\n\ndef main():\n    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.max_workers = max_workers\n        self.tasks: Dict[int, Task] = {}\n        self.completed_tasks: List[int] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.warning(f\"Task {task_id} not found\")\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.completed_tasks:\n                logger.info(f\"Task {task_id} waiting for dependency {dep_id}\")\n                return None\n                \n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Task {task.name} completed in {task.duration:.2f}s\"\n        self.completed_tasks.append(task.id)\n        return result\n        \n    def run_all_tasks(self) -> List[str]:\n        results = []\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.completed_tasks)",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.results = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        \n    def process_task(self, task_id: int) -> Optional[float]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task ID {task_id} not found\")\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                logger.warning(f\"Dependency {dep_id} not completed for task {task_id}\")\n                return None\n                \n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        # Simulate work\n        time.sleep(task.duration)\n        result = task.duration * random.random() * task.priority\n        logger.info(f\"Completed task: {task.name} with result: {result:.2f}\")\n        self.results[task_id] = result\n        return result\n        \n    def process_all(self) -> dict:\n        with ThreadPoolExecutor(max_workers=",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport logging\nfrom datetime import datetime\nimport os\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_system\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    stock: int\n    category: str\n    last_updated: str = field(default_factory=lambda: datetime.now().isoformat())\n    \n    def is_available(self) -> bool:\n        return self.stock > 0\n    \n    def update_stock(self, quantity: int) -> None:\n        self.stock += quantity\n        self.last_updated = datetime.now().isoformat()\n        logger.info(f\"Updated stock for {self.name} (ID: {self.id}). New stock: {self.stock}\")\n\nclass InventoryManager:\n    def __init__(self, storage_file: str = \"inventory.json\"):\n        self.storage_file = storage_file\n        self.products: Dict[str, Product] = {}\n        self.load_inventory()\n    \n    def load_inventory(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, \"r\") as f:\n                    data = json.load(f)\n                    self.products = {\n                        p_id: Product(**p_data) \n                        for p_id, p_data in data.items()\n                    }\n                logger.info(f\"Loaded {len(self.products)} products from {self.storage_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading inventory: {e}\")\n        else:\n            logger.info(f\"No inventory file found at {self.storage_file}\")\n    \n    def save_inventory(self) -> None:\n        try:\n            with open(self.storage_file, \"w",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max([t.id for t in self.tasks],",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO, \n                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    \nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}. Starting with empty task list.\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except IOError as e:\n            logger.error(f\"Error saving tasks: {e}\")\n            \n    def add_task(self, title: str, description: str) -> Task:",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self._save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict['due_date'] = datetime.fromisoformat(task_dict['due_date'])",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, assignee: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task {self.id}: not in PENDING state\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = assignee\n        logger.info(f\"Task {self.id} started by {assignee}\")\n        \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task {self.id}: not in IN_PROGRESS state\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n        \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task {task_id}: {name}\")\n        return task",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks storage found, starting with empty task list\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    CANCELLED = auto()\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"status\": self.status.name,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists\")\n            return\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        \n    def update_status(self, task_id: str, status: TaskStatus) -> bool:\n        if task_id not in self.tasks:\n            logger.error(f\"Task with ID {task_id} not found\")\n            return False\n        self.tasks[task_id].status = status\n        logger.info(f\"Updated task {task_id} status to {status.name}\")\n        return True\n    \n    def get_tasks_by_status(self, status: Optional[TaskStatus] = None) -> List[Task]:\n        if status is None:\n            return list(self.tasks.values())\n        return [task for task in self.",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    \n    def is_expense(self) -> bool:\n        return self.amount < 0\n    \n    def is_income(self) -> bool:\n        return self.amount > 0\n\n\nclass BudgetTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n    \n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description']\n                ))\n    \n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_data()\n    \n    def _save_data(self):\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['date', 'amount', 'category', 'description'])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description\n                })\n    \n    def get_summary_by_category(self) -> Dict[str, float]:\n        summary = {}\n        for t in self.transactions:\n            if t.category not in summary",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id =",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Post:\n    id: int\n    title: str\n    body: str\n    user_id: int\n    comments: Optional[List[dict]] = None\n\nclass PostService:\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n        \n    def get_post(self, post_id: int) -> Optional[Post]:\n        try:\n            response = requests.get(f\"{self.base_url}/posts/{post_id}\")\n            response.raise_for_status()\n            post_data = response.json()\n            return Post(**post_data)\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching post {post_id}: {e}\")\n            return None\n    \n    def get_comments(self, post_id: int) -> List[dict]:\n        try:\n            response = requests.get(f\"{self.base_url}/posts/{post_id}/comments\")\n            response.raise_for_status()\n            return response.json()\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching comments for post {post_id}: {e}\")\n            return []\n    \n    def fetch_post_with_comments(self, post_id: int) -> Optional[Post]:\n        post = self.get_post(post_id)\n        if post:\n            post.comments = self.get_comments(post_id)\n        return post\n\ndef process_posts(post_ids: List[int], base_url: str) -> List[Post]:\n    service = PostService(base_url)\n    results = []\n    \n    with ThreadPoolExecutor(max_workers=5) as executor:\n        futures = [executor.submit(",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    @lru_cache(maxsize=32)\n    def get_priority_stats(self) -> dict:\n        if not self.tasks:\n            return {\"avg\": 0, \"max\": 0, \"min\": 0}\n        \n        priorities = [task.priority for task in self.tasks]\n        return {\n            \"avg\": sum(priorities) / len(priorities),\n            \"max\": max(priorities),\n            \"min\": min(priorities)\n        }\n    \n    def get_sorted_tasks(self, by_priority: bool = True) -> List[Task]:\n        if by_priority:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: Optional[str]\n    due_date: Optional[datetime]\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, filename: str = \"tasks.json\"):\n        self.filename = filename\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            with open(self.filename, 'r') as f:\n                data = json.load(f)\n                self.tasks = [\n                    Task(\n                        id=item[\"id\"],\n                        title=item[\"title\"],\n                        description=item[\"description\"],\n                        due_date=datetime.fromisoformat(item[\"due_date\"]) if item[\"due_date\"] else None,\n                        completed=item[\"completed\"],\n                        tags=item[\"tags\"]\n                    )\n                    for item in data\n                ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.filename}\")\n        except (FileNotFoundError, json.JSONDecodeError):\n            logger.warning(f\"Could not load tasks from {self.filename}, starting with empty list\")\n            self.tasks = []",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n                    self.next_id = max(self.next_id, task.id + 1)\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([asdict(task) for task in self.tasks.values()], f, indent=2)\n\n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(id=self.next_id, title=title, description=description)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task and not task.completed:\n            task.completed = True\n            task.completed_at = datetime.now().isoformat()\n            self.save_tasks()\n            return True",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int  # 1-5 scale\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at,\n            \"completed_at\": self.completed_at\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, name, description, priority):\n        task = Task(name=name, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_idx):\n        if 0 <= task_idx < len(self.tasks):\n            self.tasks[task_idx].complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_pending_tasks(self):\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_completed_tasks(self):\n        return [task for task in self.tasks if task.completed]\n    \n    def get_high_priority_tasks(self, min_priority=4):\n        return [task for task in self.tasks \n                if task.priority >= min_priority and not task.complete",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom pathlib import Path\nfrom typing import List, Optional\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            data = json.loads(self.storage_path.read_text())\n            self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Faile",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport os\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_data in tasks_data:\n                created_at = datetime.fromisoformat(task_data[\"created_at\"]) if task_data[\"created_at\"] else None\n                completed_at = datetime.fromisoformat(task_data[\"completed_at\"]) if task_data[\"completed_at\"] else None\n                \n                task = Task(\n                    id=task_data[\"id\"],\n                    title=task_data[\"title\"],\n                    description=task_data[\"description\"],\n                    completed=task_data[\"completed\"],",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data['id'],\n                        title=task_data['title'],\n                        description=task_data['description'],\n                        completed=task_data['completed'],\n                        created_at=datetime.fromisoformat(task_data['created_at']),\n                        completed_at=datetime.fromisoformat(task_data['completed_at']) \n                                    if task",
    "import logging\nimport time\nfrom functools import wraps\nfrom typing import Callable, Dict, List, Optional, TypeVar, Any\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef retry(max_attempts: int = 3, delay: float = 1.0):\n    \"\"\"Decorator that retries a function if it raises an exception.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> T:\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    if attempts == max_attempts:\n                        logger.error(f\"Failed after {max_attempts} attempts: {e}\")\n                        raise\n                    wait_time = delay * (2 ** (attempts - 1))  # Exponential backoff\n                    logger.warning(f\"Attempt {attempts} failed: {e}. Retrying in {wait_time:.2f}s\")\n                    time.sleep(wait_time)\n            raise RuntimeError(\"This should never happen\")  # Unreachable code\n        return wrapper\n    return decorator\n\nclass CacheManager:\n    def __init__(self, max_size: int = 100):\n        self.cache: Dict[str, Any] = {}\n        self.max_size = max_size\n        self.access_count: Dict[str, int] = {}\n    \n    def get(self, key: str) -> Optional[Any]:\n        if key in self.cache:\n            self.access_count[key] += 1\n            return self.cache[key]\n        return None\n    \n    def set(self, key: str, value: Any) -> None:\n        if len(self.cache) >= self.max_size and key not in self.cache",
    "import json\nimport os\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                    if task_data[\"due_date\"]:\n                        task_data[\"due_date\"] = datetime.fromisoformat(task_data[\"due_date\"])\n                    self.tasks[task_id] = Task(**task_data)\n        except (json.JSONDecodeError, FileNotFoundError):\n            self.tasks = {}\n\n    def _save_tasks(self) -> None:\n        serialized = {}\n        for task_id, task in self.tasks.items():\n            task_dict = task.__dict__.copy()\n            task_dict[\"created_at\"] = task.created_at.isoformat()\n            if task.due_date:\n                task_dict[\"due_date\"] = task.due_date.isoformat()\n            serialized[task_id] = task_dict\n            \n        with open(self.storage_path, \"w\") as f:\n            json.dump(serialized, f, indent=2)\n\n    def add_task(self, title: str, description: str, tags:",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Expense:\n    date: datetime\n    amount: float\n    category: str\n    description: Optional[str] = None\n    \n    def __str__(self) -> str:\n        return f\"{self.date.strftime('%Y-%m-%d')}: ${self.amount:.2f} ({self.category})\"\n\n\nclass ExpenseTracker:\n    def __init__(self, filename: str = \"expenses.csv\"):\n        self.filename = filename\n        self.expenses: List[Expense] = []\n        self._load_expenses()\n        \n    def _load_expenses(self) -> None:\n        if not os.path.exists(self.filename):\n            return\n            \n        with open(self.filename, \"r\", newline=\"\") as file:\n            reader = csv.reader(file)\n            next(reader, None)  # Skip header\n            for row in reader:\n                if len(row) >= 3:\n                    date = datetime.strptime(row[0], \"%Y-%m-%d\")\n                    amount = float(row[1])\n                    category = row[2]\n                    description = row[3] if len(row) > 3 else None\n                    self.expenses.append(Expense(date, amount, category, description))\n    \n    def add_expense(self, amount: float, category: str, description: Optional[str] = None,\n                   date: Optional[datetime] = None) -> Expense:\n        if date is None:\n            date = datetime.now()\n        \n        expense = Expense(date, amount, category, description)\n        self.expenses.append(expense)\n        self._save_expenses()\n        return expense\n    \n    def _save_expenses(self) -> None:\n        with open(self.filename, \"w\", newline=\"\") as file:\n            writer = csv.writer(file)\n            writer.writerow([\"Date\", \"Amount\", \"Category\", \"Description\"])\n            for expense in self.expenses:\n                writer.writerow([",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, with 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n\n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def _generate_id(self) -> int:\n        if not self.tasks:\n            return 1\n        return max(task.id for task in self.tasks) + 1\n\n    def load_tasks(self):\n        if not self.storage_path.exists():\n            self.tasks = []\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.loa",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom enum import Enum, auto\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_system\")\n\nclass ProductCategory(Enum):\n    ELECTRONICS = auto()\n    CLOTHING = auto()\n    BOOKS = auto()\n    FOOD = auto()\n    OTHER = auto()\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    category: ProductCategory\n    price: float\n    quantity: int = 0\n    description: Optional[str] = None\n    tags: List[str] = field(default_factory=list)\n\nclass InventoryManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.products: Dict[str, Product] = {}\n        self._load_inventory()\n    \n    def _load_inventory(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty inventory.\")\n            return\n        \n        try:\n            data = json.loads(self.storage_path.read_text())\n            for product_data in data:\n                product = Product(\n                    id=product_data[\"id\"],\n                    name=product_data[\"name\"],\n                    category=ProductCategory[product_data[\"category\"]],\n                    price=product_data[\"price\"],\n                    quantity=product_data[\"quantity\"],\n                    description=product_data.get(\"description\"),\n                    tags=product_data.get(\"tags\", [])\n                )\n                self.products[product.id] = product\n            logger.info(f\"Loaded {len(self.products)} products from storage\")\n        except Exception as e:\n            logger.error(f\"Failed to load inventory: {e}\")\n    \n    def save_inventory(self) -> None",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, where 5 is highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        new_task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(new_task)\n        self.save_tasks()\n        return new_task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n\n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def _generate_id(self) -> int:\n        return random.randint(1000, 9999)\n\n    def load_tasks(self):\n        if not self.storage_path.exists():\n            self.tasks = []\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum, auto\nfrom abc import ABC, abstractmethod\n\n\nclass CardSuit(Enum):\n    HEARTS = auto()\n    DIAMONDS = auto()\n    CLUBS = auto()\n    SPADES = auto()\n\n\nclass CardRank(Enum):\n    TWO = 2\n    THREE = 3\n    FOUR = 4\n    FIVE = 5\n    SIX = 6\n    SEVEN = 7\n    EIGHT = 8\n    NINE = 9\n    TEN = 10\n    JACK = 11\n    QUEEN = 12\n    KING = 13\n    ACE = 14\n\n\n@dataclass\nclass Card:\n    suit: CardSuit\n    rank: CardRank\n    \n    def __str__(self):\n        return f\"{self.rank.name} of {self.suit.name}\"\n\n\nclass Deck:\n    def __init__(self):\n        self.cards: List[Card] = [\n            Card(suit, rank)\n            for suit in CardSuit\n            for rank in CardRank\n        ]\n        self.shuffle()\n    \n    def shuffle(self):\n        random.shuffle(self.cards)\n    \n    def draw(self) -> Optional[Card]:\n        if not self.cards:\n            return None\n        return self.cards.pop()\n\n\nclass Player(ABC):\n    def __init__(self, name: str):\n        self.name = name\n        self.hand: List[Card] = []\n    \n    def add_card(self, card: Card):\n        self.hand.append(card)\n    \n    @abstractmethod\n    def play_card(self) -> Card:\n        pass\n\n\nclass RandomPlayer(Player):\n    def play_card(self) -> Card:\n        if not self.hand:\n            raise ValueError(\"No cards to play\")\n        card_index = random.randint(0, len(self.hand) - 1)\n        return self.hand.pop(card_index)\n\n\nclass HighestCardPlayer(Player):\n    def play_card(self",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            logger.warning(f\"Task {task_id} not found\")\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        logger.info(f\"Updated task: {task.title}\")\n        return task\n\n    def delete_task(self, task_id: int) -> bool:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    name: str\n    weight: float\n    value: float\n    \n    def value_density(self) -> float:\n        return self.value / self.weight if self.weight > 0 else 0\n\nclass KnapsackSolver(ABC):\n    @abstractmethod\n    def solve(self, items: List[Item], capacity: float) -> List[Item]:\n        pass\n\nclass GreedyKnapsackSolver(KnapsackSolver):\n    def solve(self, items: List[Item], capacity: float) -> List[Item]:\n        logger.info(f\"Solving knapsack problem with {len(items)} items and capacity {capacity}\")\n        \n        # Sort items by value density in descending order\n        sorted_items = sorted(items, key=lambda x: x.value_density(), reverse=True)\n        \n        selected_items = []\n        remaining_capacity = capacity\n        \n        for item in sorted_items:\n            if item.weight <= remaining_capacity:\n                selected_items.append(item)\n                remaining_capacity -= item.weight\n                logger.debug(f\"Added {item.name} to knapsack, remaining capacity: {remaining_capacity}\")\n        \n        total_value = sum(item.value for item in selected_items)\n        logger.info(f\"Selected {len(selected_items)} items with total value {total_value}\")\n        \n        return selected_items\n\ndef generate_random_items(count: int) -> List[Item]:\n    items = []\n    for i in range(count):\n        name = f\"item_{i+1}\"\n        weight = round(random.uniform(0.1, 10.0), 1)\n        value = round(random.uniform(1.0, 100.",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom functools import wraps\nfrom typing import Callable, List, Optional\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# Decorator for timing function execution\ndef timer_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        logger.info(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds to run\")\n        return result\n    return wrapper\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            logger.info(f\"Completed task: {task.name}\")\n            return True\n        return False\n    \n    @timer_decorator\n    def get_high_priority_tasks(self, min_priority: int = 5) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    @timer_decorator\n    def get_stats(self) -> dict:\n        total = len(self.tasks)\n        completed =",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    last_modified: float\n    \n    @property\n    def size_in_mb(self) -> float:\n        return self.size / (1024 * 1024)\n    \n    def __str__(self) -> str:\n        return f\"{os.path.basename(self.path)} ({self.size_in_mb:.2f} MB)\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = root_dir\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        start_time = time.time()\n        \n        with ThreadPoolExecutor() as executor:\n            for root, _, files in os.walk(self.root_dir):\n                file_paths = [os.path.join(root, file) for file in files]\n                if self.extensions:\n                    file_paths = [f for f in file_paths if any(f.endswith(ext) for ext in self.extensions)]\n                \n                # Process files in parallel\n                results = list(executor.map(self._process_file, file_paths))\n                self.files.extend([r for r in results if r is not None])\n        \n        elapsed = time.time() - start_time\n        logger.info(f\"Scan completed in {elapsed:.2f} seconds. Found {len(self.files)} files.\")\n        return self.files\n    \n    def _process_file(self, file_",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_name, task_data in data.items():\n                        due_date = None\n                        if task_data.get('due_date'):\n                            due_date = datetime.fromisoformat(task_data['due_date'])\n                        self.tasks[task_name] = Task(\n                            name=task_name,\n                            priority=task_data['priority'],\n                            completed=task_data['completed'],\n                            due_date=due_date,\n                            tags=task_data.get('tags', [])\n                        )\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n        \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n        \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created task {task_id}: {name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_completed_tasks(self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(\n                            id=task_dict[\"id\"],\n                            title=task_dict[\"title\"],\n                            description=task_dict[\"description\"],\n                            created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                            completed=task_dict[\"completed\"],\n                            tags=task_dict[\"tags\"]\n                        )\n                        self.tasks[task.id] = task\n                        self.next_id = max(self.next_id, task.id + 1)\n                logger.info(f\"Loaded {len(self.",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    modified_time: float\n    \n    @property\n    def name(self) -> str:\n        return os.path.basename(self.path)\n    \n    def __str__(self) -> str:\n        return f\"{self.name} ({self.size} bytes)\"\n\nclass FileAnalyzer:\n    def __init__(self, directory: str, extensions: Optional[List[str]] = None):\n        self.directory = directory\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n    \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.directory}\")\n        self.files = []\n        \n        if not os.path.exists(self.directory):\n            logger.error(f\"Directory not found: {self.directory}\")\n            return self.files\n            \n        for root, _, files in os.walk(self.directory):\n            for file in files:\n                if self._filter_by_extension(file):\n                    path = os.path.join(root, file)\n                    try:\n                        stats = os.stat(path)\n                        self.files.append(FileInfo(\n                            path=path,\n                            size=stats.st_size,\n                            modified_time=stats.st_mtime\n                        ))\n                    except OSError as e:\n                        logger.warning(f\"Error accessing file {path}: {e}\")\n        \n        return self.files\n    \n    def _filter_by_extension(self, filename: str) -> bool:\n        if not self.extensions:\n            return True\n        return any(filename.endswith(ext)",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        return cls(\n            id=data[\"id\"],\n            title=data[\"title\"],\n            description=data[\"description\"],\n            created_at=datetime.fromisoformat(data[\"created_at\"]),\n            completed=data[\"completed\"],\n            tags=data[\"tags\"]\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            if os.path.exists(self.storage_path):\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task.from_dict(task) for task in tasks_data]\n                    logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    isbn: str\n    rating: float = 0.0\n    \n    def __str__(self):\n        return f\"{self.title} by {self.author} ({self.year}) - Rating: {self.rating}/5\"\n\nclass BookRepository:\n    def __init__(self):\n        self.books = {}\n        \n    def add_book(self, book: Book) -> None:\n        self.books[book.isbn] = book\n        logger.info(f\"Added book: {book.title}\")\n        \n    def get_book(self, isbn: str) -> Optional[Book]:\n        return self.books.get(isbn)\n    \n    def get_all_books(self) -> List[Book]:\n        return list(self.books.values())\n    \n    def search_by_author(self, author: str) -> List[Book]:\n        return [book for book in self.books.values() if author.lower() in book.author.lower()]\n\n@lru_cache(maxsize=100)\ndef fetch_book_rating(isbn: str) -> float:\n    \"\"\"Simulates fetching a book rating from an external API\"\"\"\n    try:\n        # This URL doesn't actually work, it's just for demonstration\n        response = requests.get(f\"https://bookratings.example.com/api/{isbn}\", timeout=2)\n        if response.status_code == 200:\n            return response.json().get('rating', 0.0)\n        return 0.0\n    except requests.RequestException:\n        logger.error(f\"Failed to fetch rating for ISBN {isbn}\")\n        return 0.0\n\ndef process_books(repo: BookRepository) -> None:\n    books = repo.",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task '{self.name}' marked as complete\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._ensure_storage_exists()\n        self._load_tasks()\n        \n    def _ensure_storage_exists(self):\n        os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)\n        if not os.path.exists(self.storage_path):\n            with open(self.storage_path, 'w') as f:\n                json.dump([], f)\n    \n    def _load_tasks(self):\n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_dict in tasks_data:\n                task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                if task_dict['completed_at']:\n                    task_dict['completed_at'] = datetime.fromisoformat(task_dict['completed_at'])\n                self.tasks.append(Task(**task_dict))\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_priority_tasks(self, min_priority: int = 2) -> List[Task]:\n        return [task for task in self.tasks \n                if task.priority >= min_priority and not task.complete",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    extension: str\n    \n    @property\n    def filename(self) -> str:\n        return os.path.basename(self.path)\n    \n    def __str__(self) -> str:\n        return f\"{self.filename} ({self.size / 1024:.1f} KB)\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions or ['.txt', '.py', '.md', '.json']\n        logger.info(f\"Initialized analyzer for {self.root_dir}\")\n        \n    @lru_cache(maxsize=100)\n    def get_file_info(self, filepath: str) -> Optional[FileInfo]:\n        try:\n            if not os.path.isfile(filepath):\n                return None\n            \n            _, ext = os.path.splitext(filepath)\n            if self.extensions and ext.lower() not in self.extensions:\n                return None\n                \n            size = os.path.getsize(filepath)\n            return FileInfo(filepath, size, ext.lower())\n        except Exception as e:\n            logger.error(f\"Error processing {filepath}: {e}\")\n            return None\n    \n    def analyze_directory(self) -> List[FileInfo]:\n        all_files = []\n        \n        for root, _, files in os.walk(self.root_dir):\n            with ThreadPoolExecutor(max_workers=10) as executor:\n                file_paths = [os.path.join(root, file) for file in files]",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        due = f\", due: {self.due_date.strftime('%Y-%m-%d')}\" if self.due_date else \"\"\n        return f\"[{status}] {self.name} (priority: {self.priority}{due})\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json_data = []\n            for task in self.tasks:\n                task_dict = {\n                    \"name\": task.name,",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No task storage found, starting with empty task list\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(\"Tasks saved successfully\")\n        except Exception as e:\n            logger.error(",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        logger.info(f\"Added task: {title}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                self.save_tasks()\n                logger.info(f\"Completed task: {task.title}\")\n                return task\n        logger.warning(f\"Task with ID {task_id}",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom pathlib import Path\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.storage_path = storage_path or Path(\"tasks.json\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task {task_id}\")\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks[self.next_id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_pending_tasks(self)",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n            logger.info(f\"",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    name: str\n    size: int\n    modified_time: float\n    is_directory: bool\n    \n    @property\n    def size_formatted(self) -> str:\n        \"\"\"Return human-readable file size\"\"\"\n        for unit in ['B', 'KB', 'MB', 'GB']:\n            if self.size < 1024 or unit == 'GB':\n                return f\"{self.size:.2f} {unit}\"\n            self.size /= 1024\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        \"\"\"Scan directory and return file information\"\"\"\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        \n        if not os.path.exists(self.root_dir):\n            logger.error(f\"Directory not found: {self.root_dir}\")\n            return []\n            \n        with ThreadPoolExecutor() as executor:\n            for root, dirs, files in os.walk(self.root_dir):\n                file_paths = [os.path.join(root, file) for file in files]\n                executor.map(self._process_file, file_paths)\n                \n        return sorted(self.files, key=lambda x: x.size, reverse=True)\n    \n    def _process_file(self, file_path: str) -> None:\n        \"\"\"Process a single file and add to results if it matches criteria\"\"\"\n        #",
    "import json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    completed: bool\n    description: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**item) for item in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")\n    \n    def add_task(self, title: str, description: str = None, tags: List[str] = None) -> Task:\n        task_id = max([task.id for task in self.",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, default=str)\n    \n    def _load_tasks(self) -> None:",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, field, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    \n    def mark_completed(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}\"\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task_id\n    \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: str, task: Task) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id] = task\n            self._save_tasks()\n            return True\n        return False\n    \n    def delete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[tuple[str, Task]]:\n        return [(tid, task) for tid, task in self.tasks.items() \n                if tag in task.tags]\n    \n    def _save_tasks(self):\n        with open(",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    metadata: Dict[str, Any] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if self.metadata is None:\n            self.metadata = {}\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"metadata\": self.metadata\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def _load_tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, updating\")\n        self.tasks[task.name] = task\n        self.save_tasks()\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json_data = {name: {\n                \"name\": task.name,\n                \"description\": task.description,\n                \"priority\": task.priority,\n                \"completed\": task",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[str] = None, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n    \n    def filter_tasks(self, **filters) -> List[Task]:\n        result = self.",
    "import os\nfrom collections import defaultdict\nfrom typing import Dict, List, Set, Tuple\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass FileAnalyzer:\n    def __init__(self, directory: str):\n        self.directory = directory\n        self.extensions: Dict[str, int] = defaultdict(int)\n        self.file_sizes: Dict[str, int] = {}\n        self.largest_files: List[Tuple[str, int]] = []\n        \n    def analyze(self) -> None:\n        \"\"\"Analyze files in the specified directory.\"\"\"\n        logger.info(f\"Analyzing directory: {self.directory}\")\n        \n        if not os.path.exists(self.directory):\n            logger.error(f\"Directory {self.directory} does not exist\")\n            return\n            \n        try:\n            for root, _, files in os.walk(self.directory):\n                for file in files:\n                    full_path = os.path.join(root, file)\n                    self._process_file(full_path)\n                    \n            self._find_largest_files(5)\n            logger.info(\"Analysis complete\")\n        except Exception as e:\n            logger.error(f\"Error during analysis: {e}\")\n    \n    def _process_file(self, file_path: str) -> None:\n        \"\"\"Process a single file.\"\"\"\n        _, ext = os.path.splitext(file_path)\n        ext = ext.lower() if ext else \"no_extension\"\n        \n        try:\n            size = os.path.getsize(file_path)\n            self.extensions[ext] += 1\n            self.file_sizes[file_path] = size\n        except OSError as e:\n            logger.warning(f\"Could not process {file_path}: {e}\")\n    \n    def _find_largest_files(self, count: int) -> None:\n        \"\"\"Find the largest files.\"\"\"\n        self.largest_",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(\"No storage file found, starting with empty task list\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(\"Tasks saved successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) +",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    humidity: int\n    description: str\n    error: Optional[str] = None\n\nclass WeatherService:\n    def __init__(self, api_key: str, base_url: str = \"https://api.example.com/weather\"):\n        self.api_key = api_key\n        self.base_url = base_url\n        \n    def get_weather(self, city: str) -> WeatherData:\n        try:\n            logger.info(f\"Fetching weather data for {city}\")\n            # Simulate API call\n            time.sleep(0.5)\n            \n            # In a real app, you would do:\n            # response = requests.get(\n            #     f\"{self.base_url}?city={city}&api_key={self.api_key}\"\n            # )\n            # response.raise_for_status()\n            # data = response.json()\n            \n            # Simulated response\n            if city.lower() == \"error\":\n                raise requests.RequestException(\"Simulated error\")\n                \n            # Simulate different weather conditions based on city name\n            temp = ord(city[0]) % 30 + 5  # Temperature between 5 and 35\n            humidity = (ord(city[-1]) % 50) + 30  # Humidity between 30 and 80\n            conditions = [\"Sunny\", \"Cloudy\", \"Rainy\", \"Windy\", \"Clear\"]\n            description = conditions[sum(ord(c) for c in city) % len(conditions)]\n            \n            return WeatherData(\n                city=city,\n                temperature=temp,\n                humidity=humidity,\n                description=description\n            )",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    @lru_cache(maxsize=32)\n    def get_high_priority_count(self, threshold: int = 7) -> int:\n        return sum(1 for task in self.tasks if task.priority >= threshold)\n\ndef generate_sample_tasks(count: int) -> List[Task]:\n    return [\n        Task(\n            id=i,\n            name=f\"Task {i}\",\n            priority=random.randint(1, 10)\n        )\n        for i in range(1, count + 1)\n    ]\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add sample tasks\n    for task in generate_sample_tasks(5):\n        manager.add_task(task)\n    \n    # Complete some tasks\n    task = manager.",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file {self.storage_path}",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> Optional[Task]:\n        if 0 <= index < len(self.tasks):\n            task = self.tasks[index]\n            task.complete()\n            self._save_tasks()\n            return task\n        logger.warning(f\"Task index {index} out of range\")\n        return None\n    \n    def list_tasks(self, show_completed: bool = False) -> List[Task]:\n        return [task for task in self.tasks if show_completed or not task.completed]\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([{\n                'title': t.title,\n                'description': t.description,\n                'created_at': t.created_at.isoformat(),",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.max_workers = max_workers\n        self.completed_tasks = set()\n        \n    def process_task(self, task: Task) -> str:\n        logger.info(f\"Starting task {task.name} (ID: {task.id})\")\n        # Simulate work\n        time.sleep(task.duration)\n        result = f\"Task {task.name} completed in {task.duration:.2f}s\"\n        logger.info(result)\n        self.completed_tasks.add(task.id)\n        return result\n    \n    def can_process(self, task: Task) -> bool:\n        return all(dep in self.completed_tasks for dep in task.dependencies)\n    \n    def execute_workflow(self, tasks: List[Task]) -> List[str]:\n        results = []\n        pending_tasks = tasks.copy()\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while pending_tasks:\n                eligible_tasks = [t for t in pending_tasks if self.can_process(t)]\n                if not eligible_tasks:\n                    logger.warning(\"Deadlock detected or no eligible tasks\")\n                    break\n                \n                futures = {executor.submit(self.process_task, task): task for task in eligible_tasks}\n                for future in futures:\n                    results.append(future.result())\n                    pending_",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task_data) for task_data in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No task storage found, starting with empty task list\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(\"Tasks saved successfully\")\n        except Exception as e:\n            logger.error(",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"priority\": self.priority,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: datetime, \n                priority: int = 1, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, \n                   due_date=due_date, priority=priority, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 3  # 1 (highest) to 5 (lowest)\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_id, task_dict in tasks_data.items():\n                task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                self.tasks[task_id] = Task(**task_dict)\n            \n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        tasks_serializable = {}\n        for task_id, task in self.tasks.items():",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import List, Dict, Optional\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            created_at=datetime.now()\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            task.completed_at = datetime.now()\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_all_tasks(self) -> List[Task]:\n        return self.tasks\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            tasks_dict = [\n                {\n                    \"id\": task.id,\n                    \"title\": task.title,\n                    \"description\": task.description,\n                    \"created_at\": task.created_at.isoformat(),\n                    \"completed\": task.completed,\n                    \"",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport os\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    priority: int = 1  # 1-5, 5 being highest\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        self.save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def get_task_by_title(self, title: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.title == title:\n                return task\n        return None\n    \n    def complete_task(self, title: str) -> bool:\n        task = self.get_task_by_title(title)\n        if task and not task.completed:\n            task.complete()",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                task_data = json.load(f)\n                \n            for task_dict in task_data:\n                task = Task(**task_dict)\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        task_list = [vars(task) for task in self.tasks.values()]\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump(task_list, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'due_date': self.due_date.isoformat() if self.due_date else None,\n            'completed': self.completed,\n            'tags': self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_dict in tasks_data:\n                due_date = None\n                if task_dict.get('due_date'):\n                    due_date = datetime.fromisoformat(task_dict['due_date'])\n                \n                task = Task(\n                    id=task_dict['id'],\n                    title=task_dict['title'],\n                    description=task_dict['description'],",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(\"Can only complete tasks that are in progress\")\n        self.status = TaskStatus.DONE\n        logger.info(f\"Task {self.id} completed\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def create_task(self, title: str, description: str) -> Task:\n        task = Task(id=self.next_id, title=title, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Created task: {title}\")\n        return task\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task in self.tasks if task.status == status]\n    \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n\ndef",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n    \n    def get_task(self, task_id:",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(\n                        id=task_dict['id'],\n                        title=task_dict['title'],\n                        description=task_dict['description'],\n                        completed=task_dict['completed'],\n                        created_at=datetime.fromisoformat(task_dict['created_at']),\n                        completed_at=datetime.fromisoformat",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    name: str\n    path: str\n    size: int\n    modified: float\n    \n    @property\n    def size_in_kb(self) -> float:\n        return self.size / 1024\n    \n    def __str__(self) -> str:\n        return f\"{self.name} ({self.size_in_kb:.2f} KB)\"\n\nclass FileAnalyzer:\n    def __init__(self, directory: str, extensions: Optional[List[str]] = None):\n        self.directory = directory\n        self.extensions = extensions or ['.txt', '.py', '.md', '.json']\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.directory}\")\n        \n        if not os.path.exists(self.directory):\n            logger.error(f\"Directory does not exist: {self.directory}\")\n            return []\n        \n        try:\n            with ThreadPoolExecutor() as executor:\n                for root, _, files in os.walk(self.directory):\n                    file_paths = [os.path.join(root, file) for file in files \n                                 if any(file.endswith(ext) for ext in self.extensions)]\n                    self.files.extend(executor.map(self._process_file, file_paths))\n            \n            return sorted(self.files, key=lambda f: f.size, reverse=True)\n        except Exception as e:\n            logger.exception(f\"Error scanning directory: {e}\")\n            return []\n    \n    def _process_file(self, file_path: str) -> FileInfo:\n        # Simulate processing time",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum\nimport random\nfrom functools import wraps\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass FruitType(Enum):\n    APPLE = \"apple\"\n    BANANA = \"banana\"\n    ORANGE = \"orange\"\n    GRAPE = \"grape\"\n\n@dataclass\nclass Fruit:\n    name: str\n    weight: float\n    ripe: bool = False\n    type: FruitType = FruitType.APPLE\n\nclass FruitBasket:\n    def __init__(self, capacity: int = 10):\n        self.fruits: List[Fruit] = []\n        self.capacity = capacity\n    \n    def add_fruit(self, fruit: Fruit) -> bool:\n        if len(self.fruits) >= self.capacity:\n            logger.warning(f\"Basket full, can't add {fruit.name}\")\n            return False\n        self.fruits.append(fruit)\n        logger.info(f\"Added {fruit.name} to basket\")\n        return True\n    \n    def get_ripe_fruits(self) -> List[Fruit]:\n        return [fruit for fruit in self.fruits if fruit.ripe]\n    \n    def get_fruits_by_type(self, fruit_type: FruitType) -> List[Fruit]:\n        return [fruit for fruit in self.fruits if fruit.type == fruit_type]\n    \n    def __len__(self) -> int:\n        return len(self.fruits)\n\ndef timing_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        logger.info(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nimport logging\nfrom pathlib import Path\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    modified: float\n    content_hash: Optional[str] = None\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: List[str] = None):\n        self.root_dir = Path(root_dir)\n        self.extensions = extensions or ['.txt', '.py', '.json']\n        self.results: Dict[str, FileInfo] = {}\n    \n    def scan_directory(self) -> Dict[str, FileInfo]:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        start_time = time.time()\n        \n        with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:\n            paths = [p for p in self.root_dir.rglob('*') if p.is_file() and p.suffix in self.extensions]\n            list(executor.map(self._process_file, paths))\n        \n        logger.info(f\"Scan completed in {time.time() - start_time:.2f} seconds\")\n        logger.info(f\"Found {len(self.results)} matching files\")\n        return self.results\n    \n    def _process_file(self, file_path: Path) -> None:\n        try:\n            stats = file_path.stat()\n            relative_path = str(file_path.relative_to(self.root_dir))\n            self.results[relative_path] = FileInfo(\n                path=relative_path,\n                size=stats.st_size,\n                modified=stats.st_mtime\n            )\n        except Exception as e:\n            logger.error(f\"Error",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"⨯\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if",
    "import os\nimport json\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    priority=t[\"priority\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed=t[\"completed\"],\n                    tags=t.get(\"tags\", [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(\"Task must be in progress before completion\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created task {task_id}: {name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass ItemType(Enum):\n    WEAPON = auto()\n    ARMOR = auto()\n    POTION = auto()\n    TREASURE = auto()\n\n@dataclass\nclass Item:\n    name: str\n    item_type: ItemType\n    value: int\n    weight: float\n    \n    def __str__(self) -> str:\n        return f\"{self.name} ({self.item_type.name}): {self.value} gold, {self.weight} kg\"\n\nclass Inventory:\n    def __init__(self, capacity: float):\n        self.items: List[Item] = []\n        self.capacity = capacity\n        \n    def add_item(self, item: Item) -> bool:\n        current_weight = self.total_weight()\n        if current_weight + item.weight <= self.capacity:\n            self.items.append(item)\n            logger.info(f\"Added {item.name} to inventory\")\n            return True\n        logger.warning(f\"Cannot add {item.name}: exceeds capacity\")\n        return False\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name == item_name:\n                removed = self.items.pop(i)\n                logger.info(f\"Removed {removed.name} from inventory\")\n                return removed\n        logger.warning(f\"Item {item_name} not found in inventory\")\n        return None\n    \n    def total_weight(self) -> float:\n        return sum(item.weight for item in self.items)\n    \n    def total_value(self) -> int:\n        return sum(item.value for item in self.items)\n    \n    def __str__(self) -> str:",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Employee:\n    id: int\n    name: str\n    department: str\n    salary: float\n    hire_date: datetime\n    \n    @property\n    def years_of_service(self) -> float:\n        return (datetime.now() - self.hire_date).days / 365.25\n    \n    def is_eligible_for_promotion(self) -> bool:\n        return self.years_of_service >= 2.0\n\nclass EmployeeManager:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.employees: List[Employee] = []\n        self._load_data()\n    \n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            logger.warning(f\"Data file {self.data_file} not found. Starting with empty dataset.\")\n            return\n        \n        try:\n            with open(self.data_file, 'r', newline='') as csvfile:\n                reader = csv.DictReader(csvfile)\n                for row in reader:\n                    self.employees.append(Employee(\n                        id=int(row['id']),\n                        name=row['name'],\n                        department=row['department'],\n                        salary=float(row['salary']),\n                        hire_date=datetime.strptime(row['hire_date'], '%Y-%m-%d')\n                    ))\n            logger.info(f\"Loaded {len(self.employees)} employees from {self.data_file}\")\n        except Exception as e:\n            logger.error(f\"Error loading data: {e}\")\n    \n    def save_data(self) -> None:",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    completed=t[\"completed\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    tags=t.get(\"tags\", [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1-5, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None, priority: int = 1) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        self.tasks[task_id] = Task(\n            title=title,\n            description=description,\n            tags=tags or [],\n            priority=priority\n        )\n        self.save_tasks()\n        return task_id\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({\n                k",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.results = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return None\n            \n        # Check dependencies\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                logger.warning(f\"Dependency {dep_id} not completed for task {task_id}\")\n                return None\n        \n        logger.info(f\"Processing task: {task.name} (ID: {task_id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        self.results[task_id] = result\n        logger.info(f\"Completed task: {task.name} (ID: {task_id})\")\n        return result\n    \n    def run_all(self) -> dict:\n        with ThreadPoolExecutor",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def remove_tag(self, tag: str):\n        if tag in self.tags:\n            self.tags.remove(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        logger.info(f\"Created new task: {title}\")\n        self.save_tasks()\n        return task",
    "import argparse\nimport csv\nimport logging\nimport os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass SalesRecord:\n    date: str\n    product_id: str\n    quantity: int\n    price: float\n    \n    @property\n    def total_value(self) -> float:\n        return self.quantity * self.price\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.records: List[SalesRecord] = []\n        self.logger = self._setup_logger()\n        \n    def _setup_logger(self) -> logging.Logger:\n        logger = logging.getLogger(\"sales_analyzer\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            self.logger.error(f\"File not found: {self.data_file}\")\n            return\n            \n        try:\n            with open(self.data_file, 'r', newline='') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    record = SalesRecord(\n                        date=row['date'],\n                        product_id=row['product_id'],\n                        quantity=int(row['quantity']),\n                        price=float(row['price'])\n                    )\n                    self.records.append(record)\n            self.logger.info(f\"Loaded {len(self.records)} records\")\n        except Exception as e:\n            self.logger.error(f\"Error loading data: {e}\")\n    \n    def get_total_sales(self) -> float:\n        return sum(record.total_value for record in self.records)\n    \n    def get_sales_by",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n        \n    def get_task_by_name(self, name: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.name == name:\n                return task\n        return None\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport os\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = self._load_tasks()\n    \n    def _load_tasks(self) -> List[Task]:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}. Starting with empty task list.\")\n            return []\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                return [Task(**task) for task in tasks_data]\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            return []\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_data = [task.__dict__ for task in self.tasks]\n                json.dump(tasks_data, f, indent=2)\n            logger.info(f\"Tasks saved to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        new_task = Task(",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        return cls(\n            id=data['id'],\n            title=data['title'],\n            description=data['description'],\n            created_at=datetime.fromisoformat(data['created_at']),\n            completed=data['completed'],\n            tags=data['tags']\n        )\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task.from_dict(task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def remove_tag(self, tag: str) -> None:\n        if tag in self.tags:\n            self.tags.remove(tag)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {title} (ID: {task_id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task with ID: {task_id}\")\n            return True\n        return False\n    \n    def list_tasks(",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                    if task_data[\"completed_at\"]:\n                        task_data[\"completed_at\"] = datetime.fromisoformat(task_data[\"completed_at\"])\n                    self.tasks[task_id] = Task(**task_data)\n\n    def _save_tasks(self) -> None:\n        serializable_tasks = {}\n        for task_id, task in self.tasks.items():\n            task_dict = asdict(task)\n            task_dict[\"created_at\"] = task.created_at.isoformat()\n            if task.completed_at:\n                task_dict[\"completed_at\"] = task.completed_at.isoformat()\n            serializable_tasks[task_id] = task_dict\n        \n        with open(self.",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: str\n    created_at: datetime\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_dict in data:\n                # Convert string dates back to datetime objects\n                task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                if task_dict['completed_at']:\n                    task_dict['completed_at'] = datetime.fromisoformat(task_dict['completed_at'])\n                \n                task = Task(**task_dict)\n                self.tasks[task.id] = task\n                self.next_id = max(self.next_id, task.id + 1)\n            \n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        return None\n    \n    def get_all_tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        \n        if isinstance(self.due_date, str):\n            self.due_date = datetime.fromisoformat(self.due_date)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_manager\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int = 0\n    categories: List[str] = field(default_factory=list)\n    \n    def is_in_stock(self) -> bool:\n        return self.quantity > 0\n    \n    def update_quantity(self, amount: int) -> None:\n        self.quantity += amount\n        if self.quantity < 0:\n            self.quantity = 0\n            logger.warning(f\"Attempted to set negative quantity for {self.name}\")\n\n\nclass InventoryManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.products: Dict[str, Product] = {}\n        self.storage_path = storage_path or Path(\"inventory.json\")\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists, updating\")\n        self.products[product.id] = product\n        logger.info(f\"Added/updated product: {product.name}\")\n        \n    def remove_product(self, product_id: str) -> bool:\n        if product_id in self.products:\n            del self.products[product_id]\n            logger.info(f\"Removed product with ID: {product_id}\")\n            return True\n        logger.warning(f\"Attempted to remove non-existent product ID: {product_id}\")\n        return False\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products.values() if category in p.categories]\n    \n    def save(self)",
    "import logging\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport argparse\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    notes: Optional[str] = None\n\n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path = Path(\"tasks.json\")):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.logger = self._setup_logger()\n        self._load_tasks()\n\n    def _setup_logger(self):\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n\n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            self.logger.info(f\"No task file found at {self.storage_path}\")\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_data in data:\n                    task = Task(**task_data)\n                    self.tasks[task.name] = task\n            self.logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            self.logger.error(f\"Failed to load tasks: {e}\")\n\n    def save(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([vars(task) for task in self.tasks.values()], f, indent=2)\n            self.logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, name: str, description: str, tags: List[str] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(\n            name=name,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[name] = task\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, name: str) -> Task:\n        if name not in self.tasks:\n            raise ValueError(f\"Task with name '{name}' not found\")\n        \n        task = self.tasks[name]\n        task.completed = True\n        task.completed_at = datetime.now()\n        self.save_tasks()\n        return task\n    \n    def delete_task(self, name: str) -> None:\n        if name not in self.tasks:\n            raise ValueError(f\"Task with name '{name}' not found\")\n        \n        del self.tasks[name]\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save_to_file(self, filename: str):\n        with open(filename, 'w') as f:\n            # Convert tasks to dict for JSON serialization\n            tasks_dict = {\n                name: {\n                    \"name\": task.name,\n                    \"description\": task.description,\n                    \"due_date\": task.due_date.isoformat() if task.due_date else None,",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_dict = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in tasks_dict.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to decode JSON from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({str(k): asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        logger.info(f\"Created task: {title} (ID: {task_id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def save(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({\n                str(task",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                for task_dict in tasks_data:\n                    due_date = None\n                    if task_dict.get(\"due_date\"):\n                        due_date = datetime.fromisoformat(task_dict[\"due_date\"])\n                    \n                    self.tasks.append(Task(\n                        name=task_dict[\"name\"],\n                        description=task_dict[\"description\"],\n                        priority=task_dict[\"priority\"],\n                        completed=task_dict[\"",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return True\n        return False",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport logging\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item[\"id\"],\n                            title=item[\"title\"],\n                            description=item[\"description\"],\n                            completed=item[\"completed\"],\n                            created_at=datetime.fromisoformat(item[\"created_at\"]),\n                            tags=item.get(\"tags\", [])\n                        )\n                        for item in data\n                    ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\nclass TaskManager(ABC):\n    @abstractmethod\n    def add_task(self, task: Task) -> None:\n        pass\n    \n    @abstractmethod\n    def get_next_task(self) -> Optional[Task]:\n        pass\n\nclass PriorityTaskManager(TaskManager):\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        self.tasks.sort(key=lambda x: x.priority, reverse=True)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_next_task(self) -> Optional[Task]:\n        incomplete_tasks = [t for t in self.tasks if not t.completed]\n        return incomplete_tasks[0] if incomplete_tasks else None\n    \n    def display_all(self):\n        for task in self.tasks:\n            print(task)\n\ndef main():\n    manager = PriorityTaskManager()\n    \n    # Generate some random tasks\n    task_names = [\"Fix bug\", \"Write tests\", \"Refactor code\", \"Add feature\", \"Update docs\"]\n    \n    for i in range(5):\n        task = Task(\n            id=i+1",
    "import logging\nimport concurrent.futures\nimport random\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.results: Dict[int, str] = {}\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> str:\n        task = self.tasks.get(task_id)\n        if not task:\n            raise ValueError(f\"Task {task_id} not found\")\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                raise ValueError(f\"Dependency {dep_id} not completed for task {task_id}\")\n        \n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Task {task.name} completed successfully\"\n        self.results[task.id] = result\n        return result\n        \n    def process_all_tasks(self) -> Dict[int, str]:\n        with concurrent.futures.ThreadPoolExecutor() as executor:\n            futures = {}\n            processed_tasks = set()\n            \n            while len(processed_tasks) < len(self.tasks):\n                for task_id, task in self.tasks.items():\n                    if task_id in processed_tasks:\n                        continue\n                        \n                    # Check if all",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    CANCELLED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    tags: List[str] = None\n    assigned_to: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[self.next_id] = task\n        self.next_id += 1\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        \n    def add_task(self, name: str, description: str, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        # Validate dependencies\n        if dependencies:\n            for dep_id in dependencies:\n                if dep_id not in self.tasks:\n                    raise ValueError(f\"Dependency task with ID {dep_id} does not exist\")\n        \n        self.tasks[task_id] = Task(task_id, name, description, dependencies=dependencies or [])\n        logger.info(f\"Added task: {name} (ID: {task_id})\")\n        return task_id\n    \n    def update_status(self, task_id: int, status: TaskStatus) -> None:\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task with ID {task_id} does not exist\")\n        \n        self.tasks[task_id].status = status\n        logger.info(f\"Updated task {task_id} status to {status.name}\")\n    \n    def can_execute(self, task_id: int",
    "import argparse\nimport json\nimport logging\nfrom collections import defaultdict\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Tuple\n\nlogging.basicConfig(level=logging.INFO, format=\"%(asctime)s - %(levelname)s - %(message)s\")\nlogger = logging.getLogger(__name__)\n\nclass FileAnalyzer:\n    def __init__(self, directory: str, extensions: Optional[List[str]] = None):\n        self.directory = Path(directory)\n        self.extensions = extensions or [\".txt\", \".py\", \".md\", \".json\"]\n        self.stats = defaultdict(int)\n        \n    def analyze(self) -> Dict[str, int]:\n        \"\"\"Analyze files in the directory and return statistics.\"\"\"\n        if not self.directory.exists():\n            logger.error(f\"Directory {self.directory} does not exist\")\n            return {}\n        \n        try:\n            for ext in self.extensions:\n                files = list(self.directory.glob(f\"**/*{ext}\"))\n                self.stats[ext] = len(files)\n                logger.info(f\"Found {len(files)} files with extension {ext}\")\n                \n                total_lines = 0\n                for file in files:\n                    with open(file, 'r', encoding='utf-8') as f:\n                        lines = f.readlines()\n                        total_lines += len(lines)\n                \n                self.stats[f\"{ext}_lines\"] = total_lines\n                \n            return dict(self.stats)\n        except Exception as e:\n            logger.exception(f\"Error analyzing directory: {e}\")\n            return {}\n    \n    def generate_report(self, output_file: str) -> bool:\n        \"\"\"Generate a JSON report of the analysis.\"\"\"\n        if not self.stats:\n            self.analyze()\n            \n        try:\n            with open(output_file, 'w', encoding='utf-8') as f:\n                json.dump(self.stats, f, indent=2)\n            logger.info(f\"Report saved to {output_file}\")\n            return True\n        except Exception as e:\n            logger.",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except (json.JSONDecodeError, FileNotFoundError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def add_task(self, title, description):\n        task_id = len",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"TaskManager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, task: Task) -> bool:\n        if task.id in self.tasks:\n            self.logger.warning(f\"Task with ID {task.id} already exists\")\n            return False\n        \n        self.tasks[task.id] = task\n        self.logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return True\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task_status(self, task_id: int, status: TaskStatus) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            self.logger.error(f\"Task with ID {task_id} not found\")\n            return False\n        \n        # Check if dependencies are completed\n        if status == TaskStatus.IN_PROGRESS:\n            for dep_id in task.dependencies:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or []\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}. Creating new task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                    self.tasks.append(Task(**task_dict))\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.to_dict()",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    name: str\n    value: float\n    weight: float\n    \n    def value_density(self) -> float:\n        return self.value / self.weight if self.weight > 0 else 0\n\nclass Knapsack:\n    def __init__(self, capacity: float):\n        self.capacity = capacity\n        self.items: List[Item] = []\n        \n    def add_item(self, item: Item) -> bool:\n        current_weight = sum(i.weight for i in self.items)\n        if current_weight + item.weight <= self.capacity:\n            self.items.append(item)\n            logger.info(f\"Added {item.name} to knapsack\")\n            return True\n        return False\n    \n    def total_value(self) -> float:\n        return sum(item.value for item in self.items)\n    \n    def remaining_capacity(self) -> float:\n        return self.capacity - sum(item.weight for item in self.items)\n\n@lru_cache(maxsize=128)\ndef generate_random_item(seed: int) -> Item:\n    random.seed(seed)\n    names = [\"Gold\", \"Silver\", \"Diamond\", \"Ruby\", \"Emerald\", \"Book\", \"Coin\", \"Artifact\"]\n    return Item(\n        name=f\"{random.choice(names)}-{seed}\",\n        value=round(random.uniform(1, 100), 2),\n        weight=round(random.uniform(0.1, 10), 2)\n    )\n\ndef greedy_fill(knapsack: Knapsack, available_items: List[Item]) -> None:\n    # Sort items by value density (value/weight) in descending order\n    sorted_",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        return False\n    \n    def list_tasks(self, show_completed: bool = False) -> List[Task]:\n        return [t for t in sorted(self.tasks, key=lambda x: x.priority, reverse=True) \n                if show_completed or not t.completed]\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Task Manager CLI\")\n    parser.add_argument('--demo', action='store",
    "import random\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    completion_date: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n\n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.next_id += 1\n        self.tasks.append(task)\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task and not task.completed:\n            task.completed = True\n            task.completion_date = time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            return True\n        return False\n\n    def get_pending_tasks(self, sort_by_priority: bool = False) -> List[Task]:\n        pending = [task for task in self.tasks if not task.completed]\n        if sort_by_priority:\n            return sorted(pending, key=lambda t: t.priority, reverse=True)\n        return pending\n\n    def get_completed_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.completed]\n\n    def __str__(self) -> str:\n        return f\"TaskManager with {len(self.tasks)} tasks ({len(self.get_pending_tasks())} pending)\"\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    tasks = [\n        (\"Fix login bug\", 3),\n        (\"Update documentation\", 1),\n        (\"Refactor database module\", 2),",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(**task_dict)\n                self.tasks[task.id] = task\n            \n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self):\n        try:\n            tasks_data = [task.__dict__ for task in self.tasks.values()]\n            with open(self.storage_path, 'w') as f:\n                json.dump(tasks_data, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def ad",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, with 5 being highest\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if not 1 <= self.priority <= 5:\n            raise ValueError(\"Priority must be between 1 and 5\")\n    \n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> Task:\n        self.tasks.append(task)\n        self._save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        for i, task in enumerate(self.tasks):\n            if task.id == task_id:\n                del self.tasks[i]\n                self._save_tasks()\n                return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_all_tasks(self) -> List",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.to_dict() for task in self.tasks.values()], f, indent=2)",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional, Dict, Any\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    notes: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n            \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error",
    "import logging\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport concurrent.futures\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = {int(id): Task(**task_data) for id, task_data in data.items()}\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                serialized = {str(id): asdict(task) for id, task in self.tasks.items()}\n                json.dump(serialized, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n            return False\n    \n    def add_task(self,",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item[\"id\"],\n                            title=item[\"title\"],\n                            description=item[\"description\"],\n                            completed=item[\"completed\"],\n                            created_at=datetime.fromisoformat(item[\"created_at\"]),\n                            completed_at=datetime.fromisoformat(item[\"completed_at\"]) if item[\"completed_at\"] else None\n                        )\n                        for item",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    subtasks: List[\"Task\"] = field(default_factory=list)\n    \n    def mark_completed(self, recursive: bool = True) -> None:\n        self.completed = True\n        if recursive:\n            for subtask in self.subtasks:\n                subtask.mark_completed(recursive=True)\n    \n    def add_subtask(self, task: \"Task\") -> None:\n        self.subtasks.append(task)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, overwriting\")\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            return True\n        logger.warning(f\"Task '{task_name}' not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save(self) -> None:\n        try:\n            with open(self.storage_path",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport os\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n        if isinstance(self.completed_at, str) and self.completed_at:\n            self.completed_at = datetime.fromisoformat(self.completed_at)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                try:\n                    tasks_data = json.load(f)\n                    for task_dict in tasks_data:\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n                except json.JSONDecodeError:\n                    print(\"Error loading tasks, starting with empty task list\")\n\n    def save_tasks(self):\n        tasks_data = [self._task_to_dict(task) for task in self.tasks.values()]\n        with open(self.storage_path, \"w\") as f:\n            json.dump(tasks_data, f, indent=2, default=str)\n\n    def _task_to_dict(self, task: Task) -> dict:\n        return {\n            \"id\": task.id,\n            \"title\": task.title,\n            \"description\": task.description,\n            \"created_at\": task.created_at.isoformat(),\n            \"completed\": task.",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return self.due_date and not self.completed and self.due_date < datetime.now()\n\n    def complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n\n    def add_task(self, title, description, due_date=None, tags=None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            due_date=due_date,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def delete_task(self, task_id) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            return True\n        return False\n\n    def find_tasks_by_tag(self, tag) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n\n    def export_to_json(self, filename) -> None:\n        with open(filename, 'w') as f:\n            tasks_dict = {\n                str(task_id):",
    "import os\nimport json\nimport logging\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field, asdict\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    due_date: Optional[datetime] = None\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_file = storage_file\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.title}\")\n        self._save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_file, \"w\") as f:\n            json_data = [asdict(",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or []\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}, creating new task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                self.tasks.append(Task(**task_dict))\n            \n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.to_dict() for task in self.",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def load_tasks(self",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('inventory_system')\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    stock: int\n    category: str\n\nclass InventoryManager:\n    def __init__(self):\n        self.products: List[Product] = []\n        self.next_id = 1\n        logger.info(\"Inventory manager initialized\")\n    \n    def add_product(self, name: str, price: float, stock: int, category: str) -> Product:\n        product = Product(id=self.next_id, name=name, price=price, stock=stock, category=category)\n        self.products.append(product)\n        self.next_id += 1\n        logger.info(f\"Added product: {product.name}\")\n        return product\n    \n    def find_product(self, product_id: int) -> Optional[Product]:\n        for product in self.products:\n            if product.id == product_id:\n                return product\n        return None\n    \n    def update_stock(self, product_id: int, quantity: int) -> bool:\n        product = self.find_product(product_id)\n        if not product:\n            logger.error(f\"Product with ID {product_id} not found\")\n            return False\n        \n        if product.stock + quantity < 0:\n            logger.warning(f\"Cannot update stock for {product.name}. Insufficient inventory.\")\n            return False\n        \n        product.stock += quantity\n        logger.info(f\"Updated stock for {product.name} to {product.stock}\")\n        return True\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products if p.category == category]\n\nif __name__ == \"__main__\":\n    inventory",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n        self.storage_path = storage_path or Path(\"tasks.json\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added new task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, include_completed: bool = True) -> List[Task]:\n        if include_completed:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save(self) -> None:\n        with open(self.storage_path",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass CardSuit(Enum):\n    HEARTS = auto()\n    DIAMONDS = auto()\n    CLUBS = auto()\n    SPADES = auto()\n\nclass CardRank(Enum):\n    ACE = 1\n    TWO = 2\n    THREE = 3\n    FOUR = 4\n    FIVE = 5\n    SIX = 6\n    SEVEN = 7\n    EIGHT = 8\n    NINE = 9\n    TEN = 10\n    JACK = 11\n    QUEEN = 12\n    KING = 13\n\n@dataclass\nclass Card:\n    rank: CardRank\n    suit: CardSuit\n    \n    def __str__(self) -> str:\n        return f\"{self.rank.name} of {self.suit.name}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards: List[Card] = [\n            Card(rank, suit)\n            for suit in CardSuit\n            for rank in CardRank\n        ]\n        self.shuffle()\n        \n    def shuffle(self) -> None:\n        random.shuffle(self.cards)\n        logger.info(\"Deck has been shuffled\")\n        \n    def draw(self) -> Optional[Card]:\n        if not self.cards:\n            logger.warning(\"Cannot draw from an empty deck\")\n            return None\n        card = self.cards.pop()\n        logger.debug(f\"Drew card: {card}\")\n        return card\n\nclass Player:\n    def __init__(self, name: str):\n        self.name = name\n        self.hand: List[Card] = []\n        \n    def add_card(self, card: Card) -> None:\n        self.hand.append(card)\n        \n    def play_card(self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    notes: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n        return True\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        self.tasks[task_name].completed = True\n        logger.info(f\"Marked task as completed: {task_name}\")\n        self._save_tasks()\n        return True\n    \n    def get_pending_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        pending = [task for task in self.tasks.values() \n                  if not task.completed]\n        \n        if tag:\n            pending = [task for task in pending if tag in task.tags]\n            \n        return sorted(pending, key=lambda x: x.priority, reverse=True)",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        serialize",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = Path(storage_path)\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def filter_tasks(self, completed: Optional[bool] = None, tag: Optional[str] = None) -> List[Task]:\n        filtered = self.tasks\n        \n        if completed is not None:\n            filtered = [task for task in filtered if task.completed == completed]\n        \n        if tag:\n            filtered = [task for task in filtered if tag in (task.tags or [])]\n            \n        return filtered\n    \n    def save",
    "import json\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except json.JSONDecodeError:\n            logger.error(\"Failed to parse tasks file\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.__dict__ for task in self.tasks.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        result = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            result[\"due_date\"] = self.due_date.isoformat()\n        return result\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = []\n                for task_dict in data:\n                    due_date = None\n                    if \"due_date\" in task_dict:\n                        due_date = datetime.fromisoformat(task_dict[\"due_date\"])\n                    self.tasks.append(Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        completed=task_dict[\"completed\"],\n                        due_date=due_date,\n                        tags=task_dict.get(\"tags\", [])\n                    ))\n            logger",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n\n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self._logger = logging.getLogger(__name__)\n\n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        self._logger.info(f\"Added task: {task.name} (priority: {task.priority})\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task and not task.completed:\n            task.complete()\n            self._logger.info(f\"Completed task: {task.name}\")\n            return True\n        return False\n\n    def get_pending_tasks(self, sort_by_priority: bool = False) -> List[Task]:\n        pending = [task for task in self.tasks if not task.completed]\n        if sort_by_priority:\n            return sorted(pending, key=lambda x: x.priority, reverse=True)\n        return pending\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Task Manager CLI\")\n    parser.add_argument(\"--debug\", action=\"store_true\", help=\"Enable debug logging\")\n    args = parser.parse_args()\n\n    log_level = logging.DEBUG if args.debug else logging.INFO\n    logging.basicConfig(level=log_level, format=\"%(asctime)s - %(level",
    "import time\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport threading\nimport queue\n\n\n@dataclass\nclass Task:\n    id: int\n    priority: int\n    description: str\n    completed: bool = False\n    created_at: float = time.time()\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.task_queue = queue.PriorityQueue()\n        self.lock = threading.Lock()\n        self.next_id = 1\n\n    def add_task(self, description: str, priority: int = 5) -> Task:\n        with self.lock:\n            task = Task(id=self.next_id, priority=priority, description=description)\n            self.next_id += 1\n            self.tasks.append(task)\n            self.task_queue.put((priority, task.id, task))\n            return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        with self.lock:\n            for task in self.tasks:\n                if task.id == task_id:\n                    return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_next_task(self) -> Optional[Task]:\n        try:\n            _, _, task = self.task_queue.get_nowait()\n            if not task.completed:\n                return task\n            return self.get_next_task()\n        except queue.Empty:\n            return None\n\n\ndef worker(task_manager: TaskManager, worker_id: int):\n    while True:\n        task = task_manager.get_next_task()\n        if not task:\n            print(f\"Worker {worker_id}: No tasks available\")\n            break\n            \n        print(f\"Worker {worker_id}: Processing task {task.id} - {task.description}\")\n        # Simulate work\n        time.sleep(random.uniform(0.5",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, KeyError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks],",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_system\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int = 0\n    categories: List[str] = field(default_factory=list)\n    \n    def is_in_stock(self) -> bool:\n        return self.quantity > 0\n    \n    def update_quantity(self, amount: int) -> None:\n        self.quantity += amount\n        logger.info(f\"Updated quantity for {self.name}: {self.quantity}\")\n\n\nclass InventoryManager:\n    def __init__(self, data_file: str = \"inventory.json\"):\n        self.data_file = data_file\n        self.products: Dict[str, Product] = {}\n        self.load_inventory()\n    \n    def load_inventory(self) -> None:\n        try:\n            with open(self.data_file, \"r\") as f:\n                data = json.load(f)\n                for item in data:\n                    self.products[item[\"id\"]] = Product(**item)\n            logger.info(f\"Loaded {len(self.products)} products from inventory\")\n        except FileNotFoundError:\n            logger.warning(f\"Inventory file {self.data_file} not found, starting with empty inventory\")\n    \n    def save_inventory(self) -> None:\n        with open(self.data_file, \"w\") as f:\n            json.dump([vars(p) for p in self.products.values()], f, indent=2)\n        logger.info(\"Inventory saved to file\")\n    \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product {product.id} already exists, updating instead\")",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    name: str\n    value: float\n    weight: float\n\n    def __post_init__(self):\n        if self.weight <= 0:\n            raise ValueError(\"Weight must be positive\")\n        if self.value < 0:\n            raise ValueError(\"Value cannot be negative\")\n\n\nclass Inventory:\n    def __init__(self, capacity: float):\n        self.capacity = capacity\n        self.items: List[Item] = []\n        self.current_weight = 0\n    \n    def add_item(self, item: Item) -> bool:\n        if self.current_weight + item.weight <= self.capacity:\n            self.items.append(item)\n            self.current_weight += item.weight\n            logger.info(f\"Added {item.name} to inventory\")\n            return True\n        logger.warning(f\"Cannot add {item.name}: exceeds capacity\")\n        return False\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name == item_name:\n                removed = self.items.pop(i)\n                self.current_weight -= removed.weight\n                logger.info(f\"Removed {removed.name} from inventory\")\n                return removed\n        logger.warning(f\"Item {item_name} not found in inventory\")\n        return None\n    \n    def total_value(self) -> float:\n        return sum(item.value for item in self.items)\n\n\nclass InventoryStrategy(ABC):\n    @abstractmethod\n    def optimize(self, items: List[Item], inventory: Inventory) -> None:\n        pass\n\n\nclass GreedyValueStrategy(InventoryStrategy):\n    def optimize(self, items: List[",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: str\n    size: int\n    extension: str\n    is_hidden: bool\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extension_stats: Dict[str, int] = {}\n        self.total_files = 0\n        self.hidden_files = 0\n        \n    def analyze(self, max_workers: int = 4) -> List[FileStats]:\n        \"\"\"Analyze files in the directory using multiple threads.\"\"\"\n        all_files = []\n        \n        logger.info(f\"Starting analysis of {self.root_dir}\")\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            for root, _, files in os.walk(self.root_dir):\n                file_paths = [os.path.join(root, file) for file in files]\n                results = executor.map(self._process_file, file_paths)\n                all_files.extend(filter(None, results))\n        \n        self._calculate_stats(all_files)\n        return all_files\n    \n    def _process_file(self, file_path: str) -> Optional[FileStats]:\n        try:\n            filename = os.path.basename(file_path)\n            is_hidden = filename.startswith('.')\n            _, extension = os.path.splitext(filename)\n            extension = extension.lower()[1:] if extension else \"no_extension\"\n            \n            size = os.path.getsize(file_path)\n            \n            return FileStats(\n                path=file_path,\n                size=size,\n                extension=extension,\n                is_hidden",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task with name '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, only_active: bool = False) -> List[Task]:\n        if only_active:\n            return [task for task in self.tasks.values() if not task.completed]\n        return list(self.tasks.values())\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json_data = {",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: datetime\n    tags: List[str] = field(default_factory=list)\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists, updating\")\n        self.tasks[task.id] = task\n        self.save_tasks()\n    \n    def remove_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]",
    "import json\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                \n            for task_data in data:\n                task_data[\"due_date\"] = datetime.fromisoformat(task_data[\"due_date\"])",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    name: str\n    value: float\n    weight: float\n\nclass Inventory:\n    def __init__(self):\n        self.items: List[Item] = []\n    \n    def add_item(self, item: Item) -> None:\n        self.items.append(item)\n        logger.info(f\"Added {item.name} to inventory\")\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name == item_name:\n                removed = self.items.pop(i)\n                logger.info(f\"Removed {removed.name} from inventory\")\n                return removed\n        logger.warning(f\"Item {item_name} not found in inventory\")\n        return None\n    \n    def total_value(self) -> float:\n        return sum(item.value for item in self.items)\n    \n    def total_weight(self) -> float:\n        return sum(item.weight for item in self.items)\n\nclass Character(ABC):\n    def __init__(self, name: str, health: int):\n        self.name = name\n        self.health = health\n        self.inventory = Inventory()\n    \n    @abstractmethod\n    def attack(self) -> int:\n        pass\n    \n    def take_damage(self, damage: int) -> None:\n        self.health -= damage\n        logger.info(f\"{self.name} took {damage} damage, health: {self.health}\")\n\nclass Player(Character):\n    def __init__(self, name: str):\n        super().__init__(name, health=100)\n    \n    def attack(self) -> int:\n        damage = random.randint(10, 20",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n        if isinstance(self.completed_at, str) and self.completed_at:\n            self.completed_at = datetime.fromisoformat(self.completed_at)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                tasks_dict = json.load(f)\n                for task_id, task_data in tasks_dict.items():\n                    self.tasks[int(task_id)] = Task(**task_data)\n\n    def save_tasks(self):\n        tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n        with open(self.storage_path, \"w\") as f:\n            json.dump(tasks_dict, f, default=str, indent=2)\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({name: task.__dict__ for name, task in self.tasks",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None, \n                 due_date: Optional[datetime] = None) -> Task:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or [],\n            due_date=due_date\n        )\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump(",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n        \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_task(self, task_name: str) -> Optional[Task]:\n        return self.tasks.get(task_name)\n    \n    def get_tasks_by_priority(self, min_priority: int = 0) -> List[Task]:\n        return sorted(\n            [task for task in self.tasks.values() if task.priority >= min_priority],\n            key=lambda x: x.priority,\n            reverse=True\n        )\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json_data = {\n                name: {\n                    \"name\": task.name,\n                    \"description\": task.description,\n                    \"priority\": task.priority,\n                    \"created_at\": task.created_at.isoformat(),\n                    \"completed\": task",
    "import csv\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport os\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    description: str\n    category: str\n    transaction_id: str\n\n\nclass ExpenseTracker:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n\n    def _load_transactions(self):\n        if not os.path.exists(self.file_path):\n            with open(self.file_path, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerow(['date', 'amount', 'description', 'category', 'transaction_id'])\n            return\n\n        with open(self.file_path, 'r', newline='') as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    description=row['description'],\n                    category=row['category'],\n                    transaction_id=row['transaction_id']\n                ))\n\n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_transactions()\n\n    def _save_transactions(self):\n        with open(self.file_path, 'w', newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow(['date', 'amount', 'description', 'category', 'transaction_id'])\n            for t in self.transactions:\n                writer.writerow([\n                    t.date.strftime('%Y-%m-%d'),\n                    t.amount,\n                    t.description,\n                    t.category,\n                    t.transaction_id\n                ])\n\n    def get_total_by_category(self, category: Optional[str] = None):\n        if category",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, name: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, description=description, tags=tags or [])\n        self.tasks[name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {name}\")\n        return task\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, only_active: bool = False) -> List[Task]:\n        if only_active:\n            return [task for task in self.tasks.values() if not task.completed]\n        return list(self.tasks.values())\n    \n    def _save_tasks(self):\n        with open(self.storage_",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    notes: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            logger.info(f\"Marked task as completed: {task_name}\")\n            self._save_tasks()\n            return True\n        logger.warning(f\"Task not found: {task_name}\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        now = datetime.now()\n        return [task for task in self.get_pending_tasks() \n                if task.due_date < now]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({name: self._task_to_dict(task) \n                      for name, task",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    priority: int = 0\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def __post_init__(self):\n        if self.priority < 0 or self.priority > 5:\n            raise ValueError(\"Priority must be between 0 and 5\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task_id\n    \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: str, **kwargs) -> bool:\n        if task_id not in self.tasks:\n            return False\n        \n        task = self.tasks[task_id]\n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self._save_tasks()\n        return True\n    \n    def delete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(\n                            id=task_dict['id'],\n                            title=task_dict['title'],\n                            description=task_dict['description'],\n                            created_at=datetime.fromisoformat(task_dict['created_at']),\n                            completed=task_dict['completed'],\n                            tags=task_dict['tags']\n                        )\n                        self.tasks[task.id] = task\n                        self.next_id = max(self.next_id, task.id + 1)\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n\n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            tasks_data = []\n            for task in self.tasks.values():\n                task_dict = {\n                    'id': task.id,\n                    'title': task.title,\n                    'description': task.description,\n                    'created_at': task.created_at.isoformat(),\n                    'completed': task.completed,\n                    'tags': task.tags\n                }\n                tasks_data.",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport json\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_data in data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_data[\"completed_",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def remove_tag(self, tag: str) -> None:\n        if tag in self.tags:\n            self.tags.remove(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n            \n        with open(self.storage_path, 'r') as f:\n            data = json.load(f)\n            \n        for task_id, task_data in data.items():\n            task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n            self.tasks[task_id] = Task(**task_data)\n    \n    def save_tasks(self) -> None:\n        data = {}\n        for task_id, task in self.tasks.items():\n            task_dict = task.__dict__.copy()\n            task_dict['created_at'] = task.created_at.isoformat()\n            data[task_id] = task_dict\n            \n        with open(self.storage_path, 'w') as f:\n            json.dump(data, f, indent=2)\n    \n    def add_task(self, task_id: str, task: Task) -> None:\n        if task_id in self.tasks:",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        \n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        self.tasks[task_id] = Task(\n            id=task_id,\n            name=name,\n            priority=priority,\n            dependencies=dependencies or []\n        )\n        logger.info(f\"Added task '{name}' with ID {task_id}\")\n        return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        task = self.tasks[task_id]\n        task.completed = True\n        logger.info(f\"Completed task '{task.name}'\")\n        return True\n    \n    def get_next_task(self) -> Optional[Task]:\n        available_tasks = [\n            task for task in self.tasks.values() \n            if not task.completed and all(\n                dep_id not in self.tasks or self.tasks[dep_id].completed \n                for dep_id in task.dependencies\n            )\n        ]\n        \n        if not available_tasks:\n            return None\n            \n        return max(available",
    "import logging\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport time\n\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    humidity: int\n    description: str\n    error: Optional[str] = None\n\n\nclass WeatherService:\n    def __init__(self, api_key: str):\n        self.api_key = api_key\n        self.base_url = \"https://api.example.com/weather\"\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"weather_service\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def get_weather(self, city: str) -> WeatherData:\n        try:\n            self.logger.info(f\"Fetching weather data for {city}\")\n            params = {\"city\": city, \"api_key\": self.api_key}\n            \n            # Simulating API request with potential delay\n            time.sleep(0.5)  # Simulating network delay\n            \n            # Simulate API response for demo purposes\n            if city.lower() == \"error\":\n                raise requests.RequestException(\"API error\")\n                \n            # Mock response data\n            mock_data = {\n                \"temperature\": 22.5 if city != \"cold\" else 5.0,\n                \"humidity\": 65,\n                \"description\": \"Sunny\" if city != \"rainy\" else \"Heavy rain\"\n            }\n            \n            return WeatherData(\n                city=city,\n                temperature=mock_data[\"temperature\"],\n                humidity=mock_data[\"humidity\"],\n                description=mock_data[\"description\"]\n            )\n        except Exception as e:\n            self.logger.error(f\"Error fetching weather for {city}: {str(e)}\")",
    "from dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nimport logging\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            logger.warning(f\"Task with ID {task_id} not found\")\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self._save_tasks()\n        logger.info(f\"Updated task {task_id}\")\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                    completed=task_dict[\"completed\"],\n                    tags=task_dict[\"tags\"]\n                )\n                self.tasks[task.id] = task\n                \n            logger.info(f\"Loaded {len(self.tasks)} tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, show_completed: bool = False) -> List[Task]:\n        return [task for task in self.tasks.values() \n                if show_completed or not task.completed]\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(\"No task file found, starting with empty task list\")\n            return",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    completed: bool = False\n    \n    def execute(self) -> bool:\n        logger.info(f\"Executing task {self.id}: {self.name} (priority: {self.priority})\")\n        try:\n            time.sleep(self.duration)  # Simulate work\n            self.completed = True\n            logger.info(f\"Task {self.id} completed successfully\")\n            return True\n        except Exception as e:\n            logger.error(f\"Task {self.id} failed: {str(e)}\")\n            return False\n\n\nclass TaskManager:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: List[Task] = []\n        self.max_workers = max_workers\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.debug(f\"Added task {task.id} to queue\")\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return sorted(\n            [task for task in self.tasks if not task.completed],\n            key=lambda x: x.priority,\n            reverse=True\n        )\n    \n    def process_all(self) -> None:\n        pending = self.get_pending_tasks()\n        if not pending:\n            logger.info(\"No tasks to process\")\n            return\n            \n        logger.info(f\"Processing {len(pending)} tasks with {self.max_workers} workers\")\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            executor.map(lambda task: task.execute(), pending)\n\n\nif __name__ == \"__main__\":",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, name: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, description=description, tags=tags or [])\n        self.tasks[name] = task\n        self._save_tasks()\n        return task\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def delete_task(self, name: str) -> bool:\n        if name in self.tasks:\n            del self.tasks[name]\n            self._save_tasks()\n            return True\n        return False\n    \n    def list_tasks(self, filter_completed: bool = None) -> List[Task]:\n        if filter_completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == filter_completed]\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump({\n                name: {\n                    \"name\": task.name,\n                    \"description\":",
    "import json\nimport os\nfrom collections import defaultdict\nfrom typing import Dict, List, Optional, Set, Tuple\n\n\nclass LibraryManager:\n    def __init__(self, storage_path: str = \"library_data.json\"):\n        self.storage_path = storage_path\n        self.books: Dict[str, Dict] = {}\n        self.patrons: Dict[str, Dict] = {}\n        self.load_data()\n\n    def load_data(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.books = data.get('books', {})\n                    self.patrons = data.get('patrons', {})\n            except json.JSONDecodeError:\n                print(\"Error loading data. Starting with empty library.\")\n\n    def save_data(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({'books': self.books, 'patrons': self.patrons}, f, indent=2)\n\n    def add_book(self, isbn: str, title: str, author: str, quantity: int = 1) -> bool:\n        if isbn in self.books:\n            self.books[isbn]['quantity'] += quantity\n        else:\n            self.books[isbn] = {\n                'title': title,\n                'author': author,\n                'quantity': quantity,\n                'checked_out': set()\n            }\n        self.save_data()\n        return True\n\n    def register_patron(self, patron_id: str, name: str) -> bool:\n        if patron_id in self.patrons:\n            return False\n        self.patrons[patron_id] = {\n            'name': name,\n            'books': set()\n        }\n        self.save_data()\n        return True\n\n    def checkout_book(self, isbn: str, patron_id: str) -> bool:\n        if (isbn not in self.books or \n            patron_id not in self.pat",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n        \n    def add_task(self, task: Task):\n        self.tasks[task.id] = task\n        \n    def execute_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n            \n        # Check dependencies\n        for dep_id in task.dependencies:\n            if dep_id not in self.tasks or not self.tasks[dep_id].completed:\n                return f\"Task {task_id} waiting for dependencies\"\n                \n        # Simulate work\n        time.sleep(task.duration)\n        task.completed = True\n        result = f\"Task {task.name} (ID: {task.id}) completed\"\n        self.results[task_id] = result\n        return result\n        \n    def run_parallel(self, max_workers=3):\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = {executor.submit(self.execute_task, task_id): task_id \n                      for task_id in self.tasks}\n            \n            for future in futures:\n                task_id = futures[future]\n                try:\n                    result = future.result()\n                    if result:\n                        print(result)\n                except Exception as e:\n                    print(f\"Task {task_id} failed with error: {e}\")\n\n\nif __name__ == \"__main__\":\n    scheduler = TaskScheduler()\n    \n    # Create some tasks with dependencies\n    tasks = [\n        Task(1, \"Initialize\",",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = Path(storage_path)\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def load_tasks(self) -> None",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None, priority: int = 1) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or [],\n            priority=priority\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        if task_id in self.tasks:\n            self.tasks[",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        if not self.tasks:\n            return None\n        return max(\n            [t for t in self.tasks if not t.completed], \n            key=lambda x: x.priority, \n            default=None\n        )\n    \n    def __str__(self) -> str:\n        return f\"TaskManager with {len(self.tasks)} tasks\"\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_file = storage_file\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n    \n    def get_task_by_name(self, name: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.name == name:\n                return task\n        return None\n    \n    def filter_tasks(self, completed: Optional[bool] = None, \n                    min_priority: Optional[int] = None) -> List[Task]:\n        filtered = self.tasks\n        \n        if completed is not None:\n            filtered = [t for t in filtered if t.completed == completed]\n        \n        if min_priority is not None:\n            filtered = [t for t in filtered if t.priority >= min_priority]\n            \n        return filtered\n    \n    def save_tasks(self) -> None:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.results = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def execute_task(self, task_id: int) -> Optional[float]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task ID {task_id} not found\")\n            return None\n            \n        # Check dependencies\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                logger.warning(f\"Dependency {dep_id} not completed for task {task_id}\")\n                return None\n                \n        logger.info(f\"Executing task: {task.name} (ID: {task_id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = random.random() * 100  # Generate some result\n        self.results[task_id] = result\n        logger.info(f\"Task {task.name} completed with result: {result:.2f}\")\n        return result\n    \n    def process_all(self) -> dict:\n        with ThreadPoolExecutor(max_workers=self.max_workers",
    "import time\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Callable\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[str] = None\n    \n    def __post_init__(self):\n        self.dependencies = self.dependencies or []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        self.observers: List[Callable[[Task], None]] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def complete_task(self, name: str) -> bool:\n        task = self.get_task(name)\n        if not task:\n            logger.warning(f\"Task '{name}' not found\")\n            return False\n            \n        for dep_name in task.dependencies:\n            dep_task = self.get_task(dep_name)\n            if dep_task and not dep_task.completed:\n                logger.warning(f\"Cannot complete '{name}': dependency '{dep_name}' not completed\")\n                return False\n        \n        task.mark_complete()\n        self._notify_observers(task)\n        return True\n    \n    def add_observer(self, observer: Callable[[Task], None]) -> None:\n        self.observers.append(observer)\n        \n    def _notify_observers(self, task: Task) -> None:\n        for observer in self.observers:",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n        self.save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, '",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport os\nfrom pathlib import Path\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        return self\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, only_active: bool = False) -> List[Task]:\n        if only_active:\n            return [task for task in self.tasks.values() if not task.completed]\n        return list(self.tasks.values())\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({\n                name: {\n                    \"name\": task.name,\n                    \"priority\": task.priority,\n                    \"created_at\": task.created_at.isoformat",
    "import logging\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport os\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n            \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.title}\")\n        self.save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n        \n    def save_tasks(self) -> None:\n        # Convert tasks to dictionaries with string dates\n        tasks_data = []\n        for task in self.tasks:\n            task_dict = asdict(task)\n            task_dict['created_at'] = task_dict['created_at'].isoformat()\n            tasks_data.append(task",
    "import os\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n        \n    def get_task_by_name(self, name: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.name == name:\n                return task\n        return None\n        \n    def filter_tasks(self, completed: Optional[bool] = None, tag: Optional[str] = None) -> List[Task]:\n        filtered = self.tasks\n        \n        if completed is not None:\n            filtered = [task for task in",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id =",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    metadata: Dict[str, Any] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if self.metadata is None:\n            self.metadata = {}\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"metadata\": self.metadata\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def get_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nfrom collections import defaultdict\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: datetime\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return self.due_date < datetime.now() and not self.completed\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self._save_tasks()\n    \n    def remove_task(self, task_name: str) -> Optional[Task]:\n        if task_name in self.tasks:\n            task = self.tasks.pop(task_name)\n            self._save_tasks()\n            return task\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_priority_summary(self) -> Dict[int, int]:\n        summary = defaultdict(int)\n        for task in self.tasks.values():\n            summary[task.priority] += 1\n        return dict(summary)\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        with open(self.storage_path, 'r') as f:\n            data = json.load(f)\n            for task_dict in data:\n                task_dict['due_date'] = datetime.fromisoformat(task_dict['due_date'])\n                task = Task(**",
    "import logging\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> str:\n        logger.info(f\"Starting task {self.name} (ID: {self.id})\")\n        time.sleep(self.duration)  # Simulate work\n        self.result = f\"Result of task {self.name}\"\n        logger.info(f\"Completed task {self.name} (ID: {self.id})\")\n        return self.result\n\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 4):\n        self.tasks = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def are_dependencies_met(self, task_id: int) -> bool:\n        task = self.tasks[task_id]\n        return all(self.tasks[dep_id].result is not None for dep_id in task.dependencies)\n    \n    def execute_all(self) -> dict:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            pending = list(self.tasks.keys())\n            futures = {}\n            \n            while pending:\n                for task_id in pending[:]:\n                    if self.are_dependencies_met(task_id):\n                        task = self.tasks[task_id]\n                        futures[executor.submit(task.execute)] = task_id\n                        pending.remove(task",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport argparse\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.logger = self._setup_logger()\n        self._load_tasks()\n\n    def _setup_logger(self):\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n\n    def _load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data.get('tasks', []):\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n                    self.next_id = data.get('next_id', 1)\n                self.logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                self.logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({\n                    'tasks': [task.__dict__ for task in self.tasks.values()],\n                    'next_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:",
    "import os\nfrom datetime import datetime\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.tasks = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n    \n    def load_tasks(self) -> None:",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n\n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n\n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    tasks = [\n        (\"Finish project proposal\", 4),\n        (\"Buy groceries\", 2),\n        (\"Call client\", 3),\n        (\"Update resume\", 2),\n        (\"Pay bills\", 4)\n    ]\n    \n    for name, priority in tasks:\n        manager.add_task(name, priority)\n    \n    # Complete random tasks\n    for _ in range(2):\n        if manager.tasks:\n            random_task = random.choice(manager.tasks)\n            manager.complete_task(random_task.id)\n    \n    # Display pending high priority tasks\n    high_priority = manager.get_high_priority_tasks()",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    completed: bool = False\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n\n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n\n        # Check dependencies\n        if task.dependencies:\n            for dep_id in task.dependencies:\n                if dep_id not in self.results:\n                    return None\n\n        # Simulate work\n        print(f\"Starting task {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)\n        result = f\"Task {task.name} completed with priority {task.priority}\"\n        task.completed = True\n        self.results[task_id] = result\n        return result\n\n    def run_tasks(self, max_workers: int = 3) -> dict:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while len(self.results) < len(self.tasks):\n                pending_tasks = [\n                    task_id for task_id, task in self.tasks.items()\n                    if task_id not in self.results\n                ]\n                \n                # Submit all tasks that can be executed\n                futures = {\n                    executor.submit(self.process_task, task_id): task_id\n                    for task_id in pending_tasks\n                }\n                \n                time.sleep(0.5)  # Prevent CPU spinning\n                \n        return self.results\n\n\nif __name__ == \"__main__\":\n    scheduler = TaskScheduler()\n    \n    # Create some tasks with dependencies\n    tasks = [\n        Task(id=",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: '{task.name}'\")\n        return True\n        \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n            \n        self.tasks[task_name].complete()\n        self._save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self):",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Completed task: {self.name}\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n        \n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json_data = [\n                {\n                    \"name\": t.name,\n                    \"priority\": t.priority,\n                    \"completed\": t.completed,\n                    \"created_at\": t.created_at.isoformat(),\n                    \"tags\": t.tags\n                } for t in self.tasks",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        if not self.tasks:\n            return None\n        return max(self.tasks, key=lambda x: x.priority if not x.completed else -1)\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        return False\n\n@lru_cache(maxsize=100)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef main():\n    manager = TaskManager()\n    \n    # Generate some random tasks\n    for i in range(5):\n        manager.add_task(Task(\n            id=i,\n            name=f\"Task {i}\",\n            priority=random.randint(1, 10",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom typing import Dict, List, Optional\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n\n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def assign_task(self, task_id: int, assignee: str) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            logger.warning(f\"Cannot assign: Task {task_id} not found\")\n            return False\n        \n        task.assigned_to = assignee\n        task.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {task_id} assigned to {assignee}\")\n        return True\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            logger.warning(f\"",
    "import csv\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    \n    def apply_discount(self, percentage: float) -> float:\n        \"\"\"Apply discount and return new price\"\"\"\n        if not 0 <= percentage <= 100:\n            raise ValueError(\"Discount must be between 0 and 100\")\n        return round(self.price * (1 - percentage / 100), 2)\n\n\nclass Inventory:\n    def __init__(self):\n        self.products: Dict[int, Product] = {}\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists. Updating.\")\n        self.products[product.id] = product\n        logger.info(f\"Added product: {product.name}\")\n        \n    def get_product(self, product_id: int) -> Optional[Product]:\n        return self.products.get(product_id)\n    \n    def filter_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products.values() if p.category == category]\n    \n    def export_to_csv(self, filepath: Path) -> None:\n        try:\n            with open(filepath, 'w', newline='') as csvfile:\n                writer = csv.writer(csvfile)\n                writer.writerow(['ID', 'Name', 'Price', 'Category', 'In Stock'])\n                for product in self.products.values():\n                    writer.writerow([\n                        product.id, \n                        product.name, \n                        product.price,",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.info(f\"Tag '{tag}' added to task '{self.title}'\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"New task created: '{title}'\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, include_completed: bool = True) -> List[Task]:\n        if include_complete",
    "import os\nimport json\nfrom dataclasses import dataclass, field, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, only_active: bool = False) -> List[Task]:\n        if only_active:\n            return [task for task in self.tasks.values() if not task.completed]\n        return list(self.tasks.values())\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            # Convert datetime objects to strings for JSON serialization\n            serializable_tasks = {\n                name: {**asdict(",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_system\")\n\n\nclass ProductCategory(Enum):\n    ELECTRONICS = auto()\n    CLOTHING = auto()\n    BOOKS = auto()\n    FOOD = auto()\n\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: ProductCategory\n    stock: int = 0\n\n\nclass InventoryManager:\n    def __init__(self):\n        self.products: List[Product] = []\n        self.next_id = 1\n        logger.info(\"Inventory manager initialized\")\n    \n    def add_product(self, name: str, price: float, category: ProductCategory, stock: int = 0) -> Product:\n        product = Product(id=self.next_id, name=name, price=price, category=category, stock=stock)\n        self.products.append(product)\n        self.next_id += 1\n        logger.info(f\"Added product: {product.name}\")\n        return product\n    \n    def find_product(self, product_id: int) -> Optional[Product]:\n        for product in self.products:\n            if product.id == product_id:\n                return product\n        logger.warning(f\"Product with ID {product_id} not found\")\n        return None\n    \n    def update_stock(self, product_id: int, quantity: int) -> bool:\n        product = self.find_product(product_id)\n        if not product:\n            return False\n        \n        product.stock += quantity\n        logger.info(f\"Updated stock for {product.name}: {product.stock}\")\n        return True\n    \n    def get_products_by_category(self, category: ProductCategory) -> List[Product]:\n        return [p for p in self.products if p.category == category]\n\n\nif __name",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    completed=task_dict[\"completed\"],\n                    tags=task_dict[\"tags\"]\n                )\n                self.tasks[task.id] = task\n            logger.info(f\"Loade",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, default=str)\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, with 5 being highest priority\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_priority(self, min_priority: int = 1) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def load_tasks(self):\n        if self.storage_path.exists():\n            with open(self.storage_path, \"r\") as f",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return asdict(self)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed=t[\"completed\"],\n                    completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            \n    def save_tasks(self) -> None:\n        try:",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def get_task_by_name(self, name: str) -> Optional[Task]:\n        for task in self.tasks:\n            if task.name == name:\n                return task\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def save_tasks(self)",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, user: str) -> None:\n        self.assigned_to = user\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {user}\")\n    \n    def complete(self) -> None:\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def fail(self) -> None:\n        self.status = TaskStatus.FAILED\n        logger.info(f\"Task {self.id} marked as failed\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created new task: {task.name} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return",
    "import os\nimport json\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self.save_tasks()\n            logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n            return self.tasks[task_id]\n        logger.warning(f\"Task ID {task_id} not found\")\n        return None\n    \n    def",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: str\n    size: int\n    extension: str\n    is_hidden: bool\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str):\n        self.root_dir = os.path.abspath(root_dir)\n        self._stats_cache = {}\n    \n    @lru_cache(maxsize=100)\n    def get_extension(self, filename: str) -> str:\n        _, ext = os.path.splitext(filename)\n        return ext.lower()[1:] if ext else \"no_extension\"\n    \n    def is_hidden(self, path: str) -> bool:\n        return os.path.basename(path).startswith('.')\n    \n    def analyze_file(self, file_path: str) -> FileStats:\n        try:\n            size = os.path.getsize(file_path)\n            extension = self.get_extension(file_path)\n            hidden = self.is_hidden(file_path)\n            return FileStats(file_path, size, extension, hidden)\n        except Exception as e:\n            logger.error(f\"Error analyzing {file_path}: {e}\")\n            return FileStats(file_path, 0, \"\", False)\n    \n    def analyze_directory(self, max_workers: int = 4) -> Dict[str, List[FileStats]]:\n        results: Dict[str, List[FileStats]] = {}\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = []\n            \n            for root, _, files in os.walk(self.root_dir):\n                for file in files:\n                    file_path = os.path.join",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: datetime, tags: List[str] = None) -> Task:\n        next_id = max([task.id for task in self.tasks], default=0) + 1\n        task = Task(id=next_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional, Dict, Any\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"due_date\": self.due_date\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**item) for item in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.info(f\"Tag '{tag}' added to task '{self.name}'\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        due_date = None\n                        if task_data.get('due_date'):\n                            due_date = datetime.fromisoformat(task_data['due_date'])\n                        self.tasks[task_id] = Task(\n                            name=task_data['name'],\n                            description=task_data['description'],\n                            due_date=due_date,\n                            completed=task_data['completed'],\n                            tags=task_data['tags']\n                        )\n                logger.info(f\"Loaded {len(",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.debug(f\"Added tag '{tag}' to task {self.id}\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            self.tasks = []\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = max([t.id for t in self.tasks],",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, overwriting\")\n        self.tasks[task.name] = task\n        self._save_tasks()\n        \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = self._load_tasks()\n        self.next_id = max([task.id for task in self.tasks], default=0) + 1\n        \n    def _load_tasks(self) -> List[Task]:\n        if not os.path.exists(self.storage_path):\n            return []\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            tasks = []\n            for task_data in tasks_data:\n                if task_data.get(\"due_date\"):\n                    task_data[\"due_date\"] = datetime.fromisoformat(task_data[\"due_date\"])\n                tasks.append(Task(**task_data))\n                \n            return tasks\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            return []\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                tasks_data = [asdict(task) for task in self.tasks]\n                for task_data in tasks_data:\n                    if task_data[\"due_date\"]:\n                        task_data[\"due_date\"] = task_data[\"due_date\"].i",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    @lru_cache(maxsize=32)\n    def get_priority_stats(self) -> dict:\n        if not self.tasks:\n            return {\"min\": 0, \"max\": 0, \"avg\": 0}\n        priorities = [task.priority for task in self.tasks]\n        return {\n            \"min\": min(priorities),\n            \"max\": max(priorities),\n            \"avg\": sum(priorities) / len(priorities)\n        }\n        \n    def get_sorted_tasks(self, by_priority: bool = True) -> List[Task]:\n        return sorted(self.tasks, key=lambda x: x.priority if by_priority else x.id)\n    \n    def __len__(self) -> int:\n        return len(self.tasks)\n\ndef main():\n    manager = TaskManager()",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}. Creating new task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_id, task_dict in tasks_data.items():\n                # Convert string dates to datetime objects\n                created_at = datetime.fromisoformat(task_dict[\"created_at\"])\n                due_date = datetime.fromisoformat(task_dict[\"due_date\"]) if task_dict.get(\"due_date\") else None\n                \n                self.tasks[task_id] = Task(\n                    id=task_id,\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    created_at=created_at,\n                    completed=task_dict[\"completed\"],\n                    tags=task_dict[\"tags\"],\n                    due_date=due_date\n                )\n            logger.info(f\"Loaded {len(self",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >=",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, worker: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task {self.id}: not in PENDING state\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = worker\n        logger.info(f\"Task {self.id} started by {worker}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task {self.id}: not in IN_PROGRESS state\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name} (ID: {task.id})\")",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks = []\n        self._load_tasks()\n\n    def _load_tasks(self):\n        try:\n            if self.storage_path.exists():\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                    logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            else:\n                logger.warning(f\"Storage file {self.storage_path} not found\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        new_task = Task(id=task_id, title=title, description=description,",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return\n        self.tasks[task.name] = task\n        logger.info(f\"Task '{task.name}' added\")\n        self._save_tasks()\n    \n    def remove_task(self, task_name: str) -> Optional[Task]:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return None\n        task = self.tasks.pop(task_name)\n        logger.info(f\"Task '{task_name}' removed\")\n        self._save_tasks()\n        return task\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_manager\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int = 0\n    tags: List[str] = field(default_factory=list)\n    \n    def is_in_stock(self) -> bool:\n        return self.quantity > 0\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"price\": self.price,\n            \"quantity\": self.quantity,\n            \"tags\": self.tags\n        }\n\nclass InventoryManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.products: Dict[str, Product] = {}\n        self.storage_path = storage_path or Path(\"inventory.json\")\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists, updating instead\")\n        self.products[product.id] = product\n        logger.info(f\"Added/updated product: {product.name}\")\n    \n    def remove_product(self, product_id: str) -> bool:\n        if product_id in self.products:\n            del self.products[product_id]\n            logger.info(f\"Removed product with ID: {product_id}\")\n            return True\n        logger.warning(f\"Product with ID {product_id} not found\")\n        return False\n    \n    def get_low_stock_products(self, threshold: int = 5) -> List[Product]:\n        return [p for p in self.products.values() if 0 < p.quantity <= threshold]",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus\n    created_at: float\n    completed_at: Optional[float] = None\n    \n    def complete(self) -> None:\n        self.status = TaskStatus.COMPLETED\n        self.completed_at = time.time()\n    \n    def fail(self) -> None:\n        self.status = TaskStatus.FAILED\n        \n    def start(self) -> None:\n        self.status = TaskStatus.IN_PROGRESS\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        \n    def create_task(self, name: str, description: str) -> Task:\n        task = Task(\n            id=self.next_id,\n            name=name,\n            description=description,\n            status=TaskStatus.PENDING,\n            created_at=time.time()\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task in self.tasks if task.status == status]\n    \n    def process_pending_tasks(self) -> int:\n        pending_tasks = self.get_tasks_by_status(TaskStatus.PENDING)\n        processed = 0\n        \n        for task in pending_tasks:\n            task.start()\n            # Simulate processing\n            if random.random() < 0.8:  # 80% success rate",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n\n\nclass Inventory:\n    def __init__(self):\n        self.products: Dict[int, Product] = {}\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists, updating instead\")\n        self.products[product.id] = product\n        logger.info(f\"Added product: {product.name}\")\n        \n    def remove_product(self, product_id: int) -> Optional[Product]:\n        if product_id not in self.products:\n            logger.error(f\"Product with ID {product_id} not found\")\n            return None\n        product = self.products.pop(product_id)\n        logger.info(f\"Removed product: {product.name}\")\n        return product\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products.values() if p.category == category]\n    \n    def get_available_products(self) -> List[Product]:\n        return [p for p in self.products.values() if p.in_stock]\n    \n    def apply_discount(self, category: str, discount_percent: float) -> int:\n        count = 0\n        for product in self.products.values():\n            if product.category == category:\n                product.price *= (1 - discount_percent / 100)\n                count += 1\n        logger.info(f\"Applied {discount_percent}% discount to {count} products in {category}\")\n        return count\n\n\ndef main():\n    inventory = Inventory",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.next_id = 1\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self._save_tasks()\n            logger.info(f\"Completed task ID: {task_id}\")\n            return True\n        logger.warning(f\"Task ID {task_id} not found\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w",
    "import csv\nimport argparse\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\n\n@dataclass\nclass Transaction:\n    date: str\n    amount: float\n    category: str\n    description: str\n\n\nclass ExpenseTracker:\n    def __init__(self):\n        self.transactions: List[Transaction] = []\n        \n    def load_from_csv(self, filename: str) -> None:\n        try:\n            with open(filename, 'r', newline='') as file:\n                reader = csv.DictReader(file)\n                for row in reader:\n                    self.transactions.append(\n                        Transaction(\n                            date=row['date'],\n                            amount=float(row['amount']),\n                            category=row['category'],\n                            description=row['description']\n                        )\n                    )\n        except FileNotFoundError:\n            print(f\"File {filename} not found.\")\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n    \n    def save_to_csv(self, filename: str) -> None:\n        with open(filename, 'w', newline='') as file:\n            writer = csv.DictWriter(file, fieldnames=['date', 'amount', 'category', 'description'])\n            writer.writeheader()\n            for transaction in self.transactions:\n                writer.writerow(transaction.__dict__)\n    \n    def get_total_by_category(self) -> Dict[str, float]:\n        totals = defaultdict(float)\n        for transaction in self.transactions:\n            totals[transaction.category] += transaction.amount\n        return dict(totals)\n    \n    def find_transactions(self, category: Optional[str] = None, min_amount: Optional[float] = None) -> List[Transaction]:\n        results = []\n        for transaction in self.transactions:\n            if (category is None or transaction.category == category) and \\\n               (min_amount is None or transaction.amount >= min_amount):\n                results.append(transaction)\n        return results\n\n\ndef",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = self._load_tasks()\n\n    def _load_tasks(self) -> Dict[str, Dict]:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return {}\n        return {}\n\n    def _save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump(self.tasks, f, indent=2)\n\n    def add_task(self, title: str, description: str, due_date: Optional[str] = None,\n                 priority: int = 1, tags: List[str] = None) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}\"\n        self.tasks[task_id] = {\n            \"title\": title,\n            \"description\": description,\n            \"created_at\": datetime.now().isoformat(),\n            \"due_date\": due_date,\n            \"priority\": priority,\n            \"tags\": tags or [],\n            \"completed\": False\n        }\n        self._save_tasks()\n        return task_id\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id][\"completed\"] = True\n            self.tasks[task_id][\"completed_at\"] = datetime.now().isoformat()\n            self._save_tasks()\n            return True\n        return False\n\n    def get_task(self, task_id: str) -> Optional[Dict]:\n        return self.tasks.get(task_id)\n\n    def filter_tasks(self, completed: Optional[bool] = None, \n                    priority: Optional[int] = None,\n                    tag: Optional[str",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n        \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump(\n                [\n                    {\n                        \"name\": t.name,\n                        \"description\": t.description,",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= 4]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nimport threading\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.lock = threading.Lock()\n        self._load_tasks()\n        \n        # Start auto-save thread\n        self.running = True\n        self.auto_save_thread = threading.Thread(target=self._auto_save)\n        self.auto_save_thread.daemon = True\n        self.auto_save_thread.start()\n    \n    def _auto_save(self):\n        while self.running:\n            time.sleep(30)  # Save every 30 seconds\n            with self.lock:\n                self._save_tasks()\n                logger.info(\"Auto-saved tasks\")\n    \n    def add_task(self, task: Task) -> None:\n        with self.lock:\n            self.tasks[task.id] = task\n            self._save_tasks()\n    \n    def complete_task(self, task_id: str) -> bool:\n        with self.lock:\n            if task_id in self.tasks:\n                self.tasks[task_id].completed = True\n                self._save_tasks()\n                return True\n            return False\n    \n    def get_overdue_tasks(self) -> List[Task]:",
    "from dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.completed_tasks: List[int] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def can_execute(self, task: Task) -> bool:\n        return all(dep_id in self.completed_tasks for dep_id in task.dependencies)\n    \n    def execute_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n            \n        if not self.can_execute(task):\n            return f\"Task {task.name} (ID: {task.id}) cannot be executed yet, waiting for dependencies\"\n            \n        print(f\"Executing task: {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        self.completed_tasks.append(task.id)\n        return f\"Task {task.name} (ID: {task.id}) completed in {task.duration:.2f}s\"\n    \n    def execute_all(self, max_workers: int = 3) -> None:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while len(self.completed_tasks) < len(self.tasks):\n                executable_tasks = [\n                    task_id for task_id, task in self.tasks.items() \n                    if task_id not in self.completed_tasks and self.can_execute(task)\n                ]\n                \n                if not executable_tasks:\n                    if len(",
    "from dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nimport os\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: datetime, tags: List[str] = None) -> Task:\n        task_id = max([t.id for t in self.tasks], default=0) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            logger.warning(f\"Task {task_id} not found\")\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        logger.info(f\"Updated task {task_id}\")\n        self.save_tasks()\n        return task\n    \n    def delete_task(self, task_i",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    genres: List[str]\n    rating: Optional[float] = None\n    \n    def __post_init__(self):\n        if self.rating is not None and (self.rating < 0 or self.rating > 5):\n            raise ValueError(\"Rating must be between 0 and 5\")\n\nclass Library:\n    def __init__(self, name: str):\n        self.name = name\n        self.books: List[Book] = []\n        \n    def add_book(self, book: Book) -> None:\n        self.books.append(book)\n        logger.info(f\"Added book: {book.title} by {book.author}\")\n    \n    def find_by_author(self, author: str) -> List[Book]:\n        return [book for book in self.books if book.author.lower() == author.lower()]\n    \n    def find_by_genre(self, genre: str) -> List[Book]:\n        return [book for book in self.books if genre.lower() in [g.lower() for g in book.genres]]\n    \n    def save_to_file(self, filepath: Path) -> None:\n        with open(filepath, 'w') as f:\n            books_dict = [\n                {\n                    \"title\": book.title,\n                    \"author\": book.author,\n                    \"year\": book.year,\n                    \"genres\": book.genres,\n                    \"rating\": book.rating\n                }\n                for book in self.books\n            ]\n            json.dump(books_dict, f, indent=2)\n        logger.info(f\"Library saved to {filepath}\")\n    \n    @classmethod\n    def load_from_file(cls, name: str, filepath",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            raise ValueError(f\"Task with name '{task.name}' already exists\")\n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump(\n                {\n                    name: {",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n        \n    def save_tasks(self) -> None:\n        with open(self.storage",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Marked task {task_id} as completed\")\n            self.save_tasks()\n            return True\n        logger.warning(f\"Task {task_id} not found\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _generate_id(self) -> int:\n        return random.randint(1000, 9999)\n    \n    def save_tasks(self) -> None:\n        try:",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self.save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, show_completed: bool = False) -> List[Task]:\n        return [task for task in self.tasks.values() \n                if show_completed or not task.completed]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump({name: task.__dict__ for name, task in self.",
    "import os\nimport logging\nimport argparse\nfrom typing import List, Dict, Any, Optional\nfrom dataclasses import dataclass\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    filename: str\n    size: int\n    extension: str\n    path: str\n\ndef get_file_stats(filepath: str) -> Optional[FileStats]:\n    try:\n        if os.path.isfile(filepath):\n            filename = os.path.basename(filepath)\n            size = os.path.getsize(filepath)\n            _, extension = os.path.splitext(filename)\n            return FileStats(\n                filename=filename,\n                size=size,\n                extension=extension.lower(),\n                path=os.path.abspath(filepath)\n            )\n        return None\n    except Exception as e:\n        logger.error(f\"Error processing {filepath}: {e}\")\n        return None\n\ndef scan_directory(directory: str) -> List[FileStats]:\n    results = []\n    \n    if not os.path.exists(directory):\n        logger.error(f\"Directory {directory} does not exist\")\n        return results\n    \n    with ThreadPoolExecutor() as executor:\n        futures = []\n        for root, _, files in os.walk(directory):\n            for file in files:\n                filepath = os.path.join(root, file)\n                futures.append(executor.submit(get_file_stats, filepath))\n        \n        for future in futures:\n            result = future.result()\n            if result:\n                results.append(result)\n    \n    return results\n\ndef analyze_files(files: List[FileStats]) -> Dict[str, Any]:\n    if not files:\n        return {\"error\": \"No files found\"}\n    \n    total_size = sum(file.size for file in files)\n    extensions = {}\n    \n    for file in files:\n        if file.extension in extensions",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> bool:\n        logger.info(f\"Starting task {self.name} (ID: {self.id})\")\n        try:\n            time.sleep(self.duration)\n            success = random.random() > 0.2  # 80% success rate\n            status = \"completed\" if success else \"failed\"\n            logger.info(f\"Task {self.name} {status}\")\n            return success\n        except Exception as e:\n            logger.error(f\"Error executing task {self.name}: {e}\")\n            return False\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.max_workers = max_workers\n        self.completed_tasks = set()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n    \n    def can_execute(self, task: Task) -> bool:\n        return all(dep_id in self.completed_tasks for dep_id in task.dependencies)\n    \n    def run(self) -> bool:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.completed_tasks) < len(self.tasks):\n                pending_tasks = [\n                    task for task_id, task in self.tasks.items()\n                    if task_id not in self.completed_tasks and self.can_execute(task)",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.next_id = 1\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Marked task {task_id} as completed\")\n        self._save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    completed: bool = False\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        if task.dependencies is None:\n            task.dependencies = []\n\n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n\n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                return None\n\n        # Simulate task execution\n        print(f\"Processing task {task.name} (ID: {task.id})...\")\n        time.sleep(task.duration)\n        result = f\"Task {task.name} completed with priority {task.priority}\"\n        task.completed = True\n        self.results[task_id] = result\n        return result\n\n    def run_scheduler(self, max_workers: int = 3) -> dict:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while len(self.results) < len(self.tasks):\n                eligible_tasks = [\n                    t for t in self.tasks.values()\n                    if t.id not in self.results and all(\n                        dep in self.results for dep in t.dependencies\n                    )\n                ]\n                \n                if not eligible_tasks:\n                    time.sleep(0.1)\n                    continue\n                \n                # Sort by priority (higher is more important)\n                eligible_tasks.sort(key=lambda t: -t.priority)\n                \n                futures = {\n                    executor.submit(self.process_task, task.id): task.id\n                    for task",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.title}\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, priority=priority, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n\n    def load_tasks(self):\n        if self.storage_path.exists():\n            with open(self.storage_path, \"r\") as f:\n                data",
    "from typing import List, Optional\nimport logging\nimport time\nfrom dataclasses import dataclass\nfrom functools import wraps\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n# Decorator for timing function execution\ndef timing_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        logger.info(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    @timing_decorator\n    def get_sorted_tasks(self, reverse: bool = False) -> List[Task]:\n        return sorted(self.tasks, key=lambda x: x.priority, reverse=reverse)\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            logger.info(f\"Completed task: {task.name}\")\n            return True\n        return False\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some tasks\n    manager.add_task",
    "import os\nimport json\nimport logging\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n    \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def get_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def _task_to_dict(self, task: Task) -> Dict:\n        return {\n            \"name\": task.name,\n            \"priority\": task.priority,\n            \"completed\": task.completed,\n            \"created_at\": task.created_at.isoformat(),\n            \"tags\": task.tags",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, starting fresh\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_id, task_data in data.items():\n                due_date = None\n                if task_data.get('due_date'):\n                    due_date = datetime.fromisoformat(task_data['due_date'])\n                \n                self.tasks[task_id] = Task(\n                    id=task_id,\n                    title=task_data['title'],\n                    description=task_data['description'],\n                    due_date=due_date,\n                    completed=task_data['completed'],\n                    tags=task_data.get('tags', [])\n                )\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        data = {}\n        for task_id,",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def remove_tag(self, tag: str) -> None:\n        if tag in self.tags:\n            self.tags.remove(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists and will be updated\")\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            return True\n        logger.warning(f\"Task '{task_name}' not found\")\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save(self) -> None:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_path = Path(storage_file)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    for task_dict in tasks_data:\n                        task = Task(\n                            id=task_dict[\"id\"],\n                            title=task_dict[\"title\"],\n                            description=task_dict[\"description\"],\n                            completed=task_dict[\"completed\"],\n                            tags=task_dict[\"tags\"]\n                        )\n                        self.tasks[task.id] = task\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([task.to_dict() for task in self.tasks.values()], f, indent=2)\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = random.randint(1000, 9999)\n        while task_id in self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int = 0\n    completed: bool = False\n    dependencies: List[str] = field(default_factory=list)\n    metadata: Dict[str, str] = field(default_factory=dict)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {\n                        task_id: Task(**task_data)\n                        for task_id, task_data in data.items()\n                    }\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, IOError) as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({\n                    task_id: task.__dict__\n                    for task_id, task in self.tasks.items()\n                }, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except IOError as e:\n            logger.error",
    "import logging\nimport random\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            description=description,\n            priority=priority,\n            tags=tags or []\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Added task: {task.description}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.description}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def get_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\ndef",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport requests\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass ApiResult:\n    success: bool\n    data: Optional[Dict] = None\n    error: Optional[str] = None\n\nclass DataFetcher:\n    def __init__(self, base_url: str, timeout: int = 10):\n        self.base_url = base_url\n        self.timeout = timeout\n        self.session = requests.Session()\n    \n    def fetch_data(self, endpoint: str, params: Dict = None) -> ApiResult:\n        url = f\"{self.base_url}/{endpoint}\"\n        try:\n            response = self.session.get(url, params=params, timeout=self.timeout)\n            response.raise_for_status()\n            return ApiResult(success=True, data=response.json())\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching data from {url}: {str(e)}\")\n            return ApiResult(success=False, error=str(e))\n\nclass DataProcessor:\n    def __init__(self, fetcher: DataFetcher, max_workers: int = 5):\n        self.fetcher = fetcher\n        self.max_workers = max_workers\n    \n    def process_items(self, items: List[str]) -> Dict[str, ApiResult]:\n        results = {}\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            future_to_item = {\n                executor.submit(self.fetcher.fetch_data, item): item \n                for item in items\n            }\n            \n            for future in future_to_item:\n                item = future_to_item[future]\n                try:\n                    results[item] = future.result()\n                except Exception as",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self._next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self._next_id, name=name, priority=priority)\n        self.tasks.append(task)\n        self._next_id += 1\n        logger.debug(f\"Added task: {task}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task {task_id}: {task.name}\")\n            return task\n        return None\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with id {task_id} not found\")\n        return None\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    task_data = [\n        (\"Complete project proposal\", 4),\n        (\"Buy groceries",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        logger.info(f\"New task created: '{title}' (ID: {task_id})\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, filter_completed: bool = False) -> List[Task]:\n        tasks = list(self.tasks.values())\n        if filter_completed:\n            tasks = [task for task in tasks if not task.completed]\n        return tasks\n    \n    def save_tasks(self) ->",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        completed=task_dict[\"completed\"],\n                        created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_dict[\"completed_at\"]) if task_dict[\"completed_at\"] else None\n                    )\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            data = []\n            for task in self.tasks.values():\n                task_dict = {",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= 4]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    notes: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        self.tasks[task_name].completed = True\n        logger.info(f\"Marked task as completed: {task_name}\")\n        self.save_tasks()\n        return True\n    \n    def get_pending_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        result = [task for task in self.tasks.values() if not task.completed]\n        \n        if tag:\n            result = [task for task in result if tag in task.tags]\n            \n        return sorted(result, key=lambda x: x.priority, reverse=True)\n    \n    def save_",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n\n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        return cls(\n            id=data[\"id\"],\n            title=data[\"title\"],\n            description=data[\"description\"],\n            completed=data.get(\"completed\", False),\n            tags=data.get(\"tags\", [])\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.next_id = 1\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        self.next_id += 1\n        self.save_tasks()\n        return task\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n        \n    def complete_task(self,",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: str):\n        self.station_id = station_id\n        self.location = location\n        self.temperature_readings: List[float] = []\n        self.humidity_readings: List[float] = []\n        \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n        \n    def average_temperature(self) -> float:\n        if not self.temperature_readings:\n            return 0.0\n        return sum(self.temperature_readings) / len(self.temperature_readings)\n    \n    def average_humidity(self) -> float:\n        if not self.humidity_readings:\n            return 0.0\n        return sum(self.humidity_readings) / len(self.humidity_readings)\n    \n    def __str__(self) -> str:\n        return f\"Station {self.station_id} at {self.location}\"\n\n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n        \n    def add_station(self, station: WeatherStation) -> None:\n        self.stations[station.station_id] = station\n        \n    def get_station(self, station_id: str) -> WeatherStation:\n        return self.stations.get(station_id)\n    \n    def stations_by_temperature(self) -> List[Tuple[str, float]]:\n        return sorted(\n            [(s.location, s.average_temperature()) for s in self.stations.values()],\n            key=lambda x: x[1],\n            reverse=True\n        )\n\n\n# Sample usage\ndef simulate_weather_data():\n    network = WeatherNetwork()\n    \n    # Create stations\n    stations = [\n        WeatherStation(\"S001\", \"New York\"),\n        WeatherStation(\"S002\", \"Los Angeles\"),\n        WeatherStation(\"S003\", \"Chicago\"),",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    priority: Optional[int] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n            \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task):\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def load_tasks(self):\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file {self.storage_path} not found\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Task '{task.name}' added successfully\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, only_active: bool = False) -> List[Task]:\n        if only_active:\n            return [task for task in self.tasks.values() if not task.completed]\n        return list(self.tasks.values())\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger",
    "import json\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1  # 1 (low) to 5 (high)\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"○\"\n        due = f\", due: {self.due_date.strftime('%Y-%m-%d')}\" if self.due_date else \"\"\n        return f\"[{status}] {self.name} (Priority: {self.priority}{due}) - {self.description}\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def remove_task(self, name: str) -> bool:\n        if name in self.tasks:\n            del self.tasks[name]\n            logger.info(f\"Removed task: {name}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"{status} {self.name} (Priority: {self.priority}) - Due: {self.due_date.strftime('%Y-%m-%d')}\"\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            logger.info(f\"Marked task as complete: {task_name}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        next_id = max([t.id for t in self.tasks], default=0) + 1\n        task = Task(id=next_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return True\n        return False\n    \n    def get_tasks(self, include_complete",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                    self.tasks[task_id] = Task(**task_data)\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            data = {",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_complete(self):\n        self.completed = True\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                        if task_data[\"due_date\"]:\n                            task_data[\"due_date\"] = datetime.fromisoformat(task_data[\"due_date\"])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self):\n        serialized = {}\n        for task_id, task in self.tasks.items():\n            task_dict = asdict(task)\n            task_dict[\"created_at\"] = task.created_at.isoformat()\n            if task.due_date:\n                task_dict[\"due_date\"] = task.due_date.isoformat()\n            serialized[task_id] = task_dict",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int = 1\n    completed: bool = False\n    dependencies: List[str] = field(default_factory=list)\n    metadata: Dict = field(default_factory=dict)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {\n                        task_id: Task(**task_data)\n                        for task_id, task_data in data.items()\n                    }\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({\n                    task_id: {\n                        \"id\": task.id,\n                        \"name\": task.name,\n                        \"priority\": task.priority,\n                        \"completed\": task.completed,\n                        \"dependencies\": task.dependencies,\n                        \"metadata\": task.metadata\n                    }\n                    for task_",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    completed: bool = False\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n\n    def add_task(self, task: Task):\n        self.tasks[task.id] = task\n\n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n\n        # Check dependencies\n        if task.dependencies:\n            for dep_id in task.dependencies:\n                if dep_id not in self.results:\n                    return f\"Task {task_id} waiting for dependency {dep_id}\"\n\n        # Simulate work\n        time.sleep(task.duration / 10)  # Scale down for demo\n        result = f\"Completed task {task.name} with priority {task.priority}\"\n        task.completed = True\n        self.results[task_id] = result\n        return result\n\n    def run_tasks_parallel(self, max_workers=4):\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            futures = {executor.submit(self.process_task, task_id): task_id for task_id in self.tasks}\n            for future in futures:\n                task_id = futures[future]\n                try:\n                    result = future.result()\n                    print(f\"Task {task_id}: {result}\")\n                except Exception as e:\n                    print(f\"Task {task_id} failed with error: {e}\")\n\n\nif __name__ == \"__main__\":\n    scheduler = TaskScheduler()\n    \n    # Create some sample tasks\n    tasks = [\n        Task(1, \"Initialize system\", 2.0, 1),\n        Task(2, \"Load configuration\", 1.5, 2, [1]),",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        if not self.due_date or self.completed:\n            return False\n        return datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold and not task.completed]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n        \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f)\n    \n    def load_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    \n    def apply_discount(self, percentage: float) -> float:\n        \"\"\"Apply discount to product price\"\"\"\n        return self.price * (1 - percentage / 100)\n\nclass Inventory:\n    def __init__(self):\n        self.products: List[Product] = []\n        \n    def add_product(self, product: Product) -> None:\n        self.products.append(product)\n        logger.info(f\"Added product: {product.name}\")\n        \n    def get_product(self, product_id: int) -> Optional[Product]:\n        for product in self.products:\n            if product.id == product_id:\n                return product\n        return None\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products if p.category == category]\n    \n    @lru_cache(maxsize=128)\n    def get_average_price(self, category: str) -> float:\n        products = self.get_products_by_category(category)\n        if not products:\n            return 0.0\n        return sum(p.price for p in products) / len(products)\n\ndef main():\n    inventory = Inventory()\n    \n    # Add some sample products\n    categories = [\"Electronics\", \"Books\", \"Clothing\", \"Food\"]\n    \n    for i in range(10):\n        product = Product(\n            id=i,\n            name=f\"Product {i}\",\n            price=random.uniform(10.0, 100.0),\n            category=random.choice(categories),\n            in_",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                self.save_tasks()\n                logger.info(f\"Completed task: {task.title}\")\n                return True\n        return False\n    \n    def get_tasks(self, complete",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, name: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, description=description, tags=tags or [])\n        self.tasks[name] = task\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, name: str) -> Task:\n        if name not in self.tasks:\n            raise ValueError(f\"Task '{name}' not found\")\n        \n        self.tasks[name].complete()\n        self._save_tasks()\n        return self.tasks[name]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_data in data:\n                task = Task(\n                    name=task_data['name",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    extension: str\n    \n    @property\n    def name(self) -> str:\n        return os.path.basename(self.path)\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions or ['.txt', '.py', '.md', '.json']\n        logger.info(f\"Initialized analyzer for {self.root_dir}\")\n        \n    @lru_cache(maxsize=128)\n    def get_file_info(self, filepath: str) -> Optional[FileInfo]:\n        try:\n            if not os.path.isfile(filepath):\n                return None\n            \n            _, ext = os.path.splitext(filepath)\n            if self.extensions and ext.lower() not in self.extensions:\n                return None\n                \n            size = os.path.getsize(filepath)\n            return FileInfo(filepath, size, ext.lower())\n        except Exception as e:\n            logger.error(f\"Error processing {filepath}: {e}\")\n            return None\n    \n    def analyze_directory(self) -> List[FileInfo]:\n        if not os.path.exists(self.root_dir):\n            logger.warning(f\"Directory {self.root_dir} does not exist\")\n            return []\n        \n        all_files = []\n        for root, _, files in os.walk(self.root_dir):\n            file_paths = [os.path.join(root, f) for f in files]\n            all_files.extend(file_paths)",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            logger.info(f\"Deleted task {task_id}\")\n            return True\n        return False",
    "import os\nimport json\nimport logging\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=item[\"id\"],\n                    title=item[\"title\"],\n                    description=item[\"description\"],\n                    completed=item[\"completed\"],\n                    created_at=datetime.fromisoformat(item[\"created_at\"]),\n                    completed_at=datetime.fromisoformat(item[\"completed_at\"]) if",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        completed=t[\"completed\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                    )\n                    for t in tasks_data\n                ]\n                logger.info(f\"Loaded {len(self.tasks)}",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    description: Optional[str] = None\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (Priority: {self.priority})\"\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n    \n    def save(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def load(self) -> None:\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file not found: {self.storage_path}\")\n            return\n            \n        with open(self.storage",
    "import csv\nimport os\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom typing import Dict, List, Tuple\n\nclass SalesAnalyzer:\n    def __init__(self, data_dir: str):\n        self.data_dir = data_dir\n        self.sales_data = []\n        self.loaded_files = set()\n    \n    def load_sales_data(self) -> None:\n        \"\"\"Load all CSV sales data files from the data directory.\"\"\"\n        for filename in os.listdir(self.data_dir):\n            if filename.endswith('.csv') and filename not in self.loaded_files:\n                file_path = os.path.join(self.data_dir, filename)\n                try:\n                    with open(file_path, 'r', newline='') as f:\n                        reader = csv.DictReader(f)\n                        for row in reader:\n                            row['date'] = datetime.strptime(row['date'], '%Y-%m-%d')\n                            row['amount'] = float(row['amount'])\n                            self.sales_data.append(row)\n                    self.loaded_files.add(filename)\n                except Exception as e:\n                    print(f\"Error loading {filename}: {e}\")\n    \n    def get_sales_by_product(self) -> Dict[str, float]:\n        \"\"\"Return total sales amount by product.\"\"\"\n        sales_by_product = defaultdict(float)\n        for sale in self.sales_data:\n            sales_by_product[sale['product']] += sale['amount']\n        return dict(sales_by_product)\n    \n    def get_monthly_sales(self) -> Dict[str, float]:\n        \"\"\"Return total sales by month.\"\"\"\n        monthly_sales = defaultdict(float)\n        for sale in self.sales_data:\n            month_key = sale['date'].strftime('%Y-%m')\n            monthly_sales[month_key] += sale['amount']\n        return dict(monthly_sales)\n    \n    def get_top_products(self, n: int = 5) -> List[Tuple[str, float]]:\n        \"\"\"Return",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Transaction:\n    id: str\n    amount: float\n    timestamp: datetime\n    category: str\n    description: Optional[str] = None\n    \n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"amount\": self.amount,\n            \"timestamp\": self.timestamp.isoformat(),\n            \"category\": self.category,\n            \"description\": self.description\n        }\n\n\nclass BudgetTracker:\n    def __init__(self):\n        self.transactions: List[Transaction] = []\n        \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        \n    def get_transactions_by_category(self, category: str) -> List[Transaction]:\n        return [t for t in self.transactions if t.category == category]\n    \n    def get_total_by_category(self, category: str) -> float:\n        return sum(t.amount for t in self.get_transactions_by_category(category))\n    \n    def get_transactions_in_period(self, start: datetime, end: datetime) -> List[Transaction]:\n        return [t for t in self.transactions if start <= t.timestamp <= end]\n    \n    def export_to_json(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            json.dump([t.to_dict() for t in self.transactions], f, indent=2)\n    \n    def import_from_json(self, filename: str) -> None:\n        with open(filename, 'r') as f:\n            data = json.load(f)\n            self.transactions = [\n                Transaction(\n                    id=item[\"id\"],\n                    amount=item[\"amount\"],\n                    timestamp=datetime.fromisoformat(item[\"timestamp\"]),\n                    category=item[\"category\"],\n                    description=item[\"description\"]\n                )\n                for item in data\n            ]\n\n\n# Sample usage\nif __",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        completed=t[\"completed\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                    ) for t in tasks_data\n                ]\n                logger.info",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    CANCELLED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus\n    priority: int\n    tags: List[str]\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        self.logger = logging.getLogger(__name__)\n\n    def add_task(self, title, description, priority=1, tags=None):\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            status=TaskStatus.PENDING,\n            priority=priority,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.logger.info(f\"Created task {task.id}: {task.title}\")\n        return task.id\n\n    def update_status(self, task_id, new_status):\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task {task_id} not found\")\n        self.tasks[task_id].status = new_status\n        self.logger.info(f\"Updated task {task_id} status to {new_status.name}\")\n\n    def assign_task(self, task_id, person):\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task {task_id} not found\")\n        self.tasks[task_id].assigned_to = person\n        self.logger.info(f\"Assigned task {task_id} to {person}\")\n\n    def get_task(self, task_id):\n        return self.tasks.get(task_id)\n\n    def get_tasks_by_status(self, status):\n        return [task for task in self.",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def list_tasks(self, completed: Optional[bool] = None, tag: Optional[str] = None) -> List[Task]:\n        filtered_tasks = self.tasks.values()\n        \n        if completed is not None:\n            filtered_tasks = [t for t in filtered_tasks if t.completed == completed]\n            \n        if tag:\n            filtered_tasks = [t for t in filtered_tasks if tag in t.tags]\n            \n        return sorted(filtered_tasks, key=lambda x: x.created_at)\n\n    def save_tasks(self) -> None:\n        with open(self.storage_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = Path(storage_path)\n        self.load_tasks()\n\n    def add_task(self, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, description=description, priority=priority, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n\n    def _generate_id(self) -> int:\n        existing_ids = {task.id for task in self.tasks}\n        new_id = random.randint(1000, 9999)\n        while new_id in existing_ids:\n            new_id = random.randint(1000, 9999)\n        return new_id\n\n    def save_tasks(self):\n        with open(self.storage_path",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: str):\n        self.station_id = station_id\n        self.location = location\n        self.temperature_readings: List[float] = []\n        self.humidity_readings: List[float] = []\n        \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n        \n    def avg_temperature(self) -> float:\n        return sum(self.temperature_readings) / len(self.temperature_readings) if self.temperature_readings else 0\n        \n    def avg_humidity(self) -> float:\n        return sum(self.humidity_readings) / len(self.humidity_readings) if self.humidity_readings else 0\n    \n    def __str__(self) -> str:\n        return f\"Station {self.station_id} ({self.location})\"\n\n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n        \n    def add_station(self, station: WeatherStation) -> None:\n        self.stations[station.station_id] = station\n        \n    def get_station(self, station_id: str) -> WeatherStation:\n        return self.stations.get(station_id)\n    \n    def generate_report(self) -> Dict[str, Dict[str, float]]:\n        report = {}\n        for station_id, station in self.stations.items():\n            report[station_id] = {\n                \"avg_temp\": station.avg_temperature(),\n                \"avg_humidity\": station.avg_humidity()\n            }\n        return report\n    \n    def hottest_station(self) -> Tuple[str, float]:\n        if not self.stations:\n            return \"\", 0.0\n        \n        hottest = max(self.stations.items(), \n                      key=lambda x: x[1].avg_temperature())\n        return hot",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def create_task(self, description: str) -> Task:\n        task = Task(id=self.next_id, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Created task {task.id}: {description}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [t for t in self.tasks if t.status == TaskStatus.PENDING]\n    \n    def get_completed_tasks(self) -> List[Task]:",
    "import logging\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item['id'],\n                            title=item['title'],\n                            description=item['description'],\n                            completed=item['completed'],\n                            created_at=datetime.fromisoformat(item['created_at']),\n                            completed_at=datetime.fromisoformat(item['completed_at']) if item['completed_at'] else None\n                        )\n                        for item in data\n                    ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([\n                    {\n                        'id': task.id,\n                        'title': task.title,",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def get_all_tasks(self) -> List[Task]:\n        return sorted(self.tasks, key=lambda x: (-x.priority, x.completed))\n\n    def load_tasks(self):\n        if self.storage_path.exists():\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.loa",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in data.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_file}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_file, 'w') as f:\n                json.dump({str(k): asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_file}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\nimport argparse\n\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_path = Path(storage_file)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting empty\")\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] =",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        if not self.due_date or self.completed:\n            return False\n        return datetime.now() > self.due_date\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, updating\")\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.error(f\"Task '{task_name}' not found\")\n            return False\n        self.tasks[task_name].completed = True\n        logger.info(f\"Marked task as completed: {task_name}\")\n        self.save_tasks()\n        return True\n        \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int = 1\n    completed: bool = False\n    dependencies: List[int] = field(default_factory=list)\n    metadata: Dict = field(default_factory=dict)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = {\n                        int(task_id): Task(**task_data)\n                        for task_id, task_data in data.items()\n                    }\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, IOError) as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump({\n                    str(task_id): {\n                        \"id\": task.id,\n                        \"name\": task.name,\n                        \"priority\": task.priority,\n                        \"completed\": task.completed,\n                        \"dependencies\": task.dependencies,\n                        \"metadata\": task.metadata\n                    }\n                    for task_id,",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                    completed=task_dict[\"completed\"],\n                    tags=task_dict[\"tags\"]\n                )\n                self.tasks[task.id] = task\n            \n            logger.info(f\"Loaded {len(",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple, Set\n\n\nclass GraphNode:\n    def __init__(self, value: str):\n        self.value = value\n        self.neighbors: List[GraphNode] = []\n    \n    def add_neighbor(self, node: 'GraphNode') -> None:\n        if node not in self.neighbors:\n            self.neighbors.append(node)\n            node.neighbors.append(self)\n    \n    def __repr__(self) -> str:\n        return f\"Node({self.value})\"\n\n\nclass SocialNetwork:\n    def __init__(self):\n        self.users: Dict[str, GraphNode] = {}\n        \n    def add_user(self, name: str) -> None:\n        if name not in self.users:\n            self.users[name] = GraphNode(name)\n    \n    def add_friendship(self, user1: str, user2: str) -> None:\n        if user1 in self.users and user2 in self.users:\n            self.users[user1].add_neighbor(self.users[user2])\n    \n    def get_friends(self, user: str) -> List[str]:\n        if user in self.users:\n            return [node.value for node in self.users[user].neighbors]\n        return []\n    \n    def suggest_friends(self, user: str, max_suggestions: int = 3) -> List[str]:\n        if user not in self.users:\n            return []\n        \n        current_friends: Set[str] = set(self.get_friends(user))\n        friend_counts: Dict[str, int] = defaultdict(int)\n        \n        for friend in self.users[user].neighbors:\n            for friend_of_friend in friend.neighbors:\n                fof_name = friend_of_friend.value\n                if fof_name != user and fof_name not in current_friends:\n                    friend_counts[fof_name] += 1\n        \n        suggestions = sorted(friend_counts.items(), key=lambda x: (-x[1], x[0]))",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n\n\nclass TaskProcessor:\n    def __init__(self):\n        self.tasks = {}\n        self.results = {}\n    \n    def add_task(self, task: Task):\n        self.tasks[task.id] = task\n    \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            return None\n            \n        # Check dependencies\n        if task.dependencies:\n            for dep_id in task.dependencies:\n                if dep_id not in self.results:\n                    return f\"Task {task_id} waiting for dependency {dep_id}\"\n        \n        # Simulate processing time\n        time.sleep(task.duration)\n        result = f\"Completed task {task.name} (ID: {task_id}, Priority: {task.priority})\"\n        self.results[task_id] = result\n        return result\n    \n    def process_all(self, max_workers=4):\n        pending = list(self.tasks.keys())\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while pending:\n                # Process tasks in priority order\n                pending.sort(key=lambda x: self.tasks[x].priority, reverse=True)\n                futures = {executor.submit(self.process_task, task_id): task_id for task_id in pending}\n                \n                still_pending = []\n                for future in futures:\n                    task_id = futures[future]\n                    result = future.result()\n                    if \"waiting\" in str(result):\n                        still_pending.append(task_id)\n                \n                pending = still_pending\n                if pending:\n                    time.sleep(0.1)  # Avoid busy waiting\n\n\nif __name__ == \"__main__\":\n    processor =",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    completed: bool = False\n    result: Optional[str] = None\n\nclass TaskProcessor:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def process_task(self, task: Task) -> Task:\n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        task.completed = True\n        task.result = f\"Result for task {task.id}\"\n        return task\n    \n    def process_all_tasks(self, max_workers: int = 4) -> List[Task]:\n        # Sort tasks by priority (higher number = higher priority)\n        sorted_tasks = sorted(self.tasks, key=lambda t: t.priority, reverse=True)\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            # Submit all tasks to the executor\n            future_to_task = {executor.submit(self.process_task, task): task for task in sorted_tasks}\n            \n            # Process results as they complete\n            completed_tasks = []\n            for future in future_to_task:\n                completed_task = future.result()\n                completed_tasks.append(completed_task)\n        \n        return completed_tasks\n\nif __name__ == \"__main__\":\n    processor = TaskProcessor()\n    \n    # Create some random tasks\n    for",
    "from dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nimport os\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def to_dict(self) -> Dict:\n        result = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            result[\"due_date\"] = self.due_date.isoformat()\n        return result\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks.append(task)\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int)",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Marked task {task_id} as completed\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.title}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, default=str)\n    \n    def load_tasks(self) ->",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n                \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            serialized = {\n                task_id: {\n                    **task.__dict__,\n                    'created_at': task.created_at.isoformat()\n                } for task_id, task in self.tasks.items()\n            }\n            json.dump(serialized, f, indent=2)\n            \n    def add_task(self, task_id: str, task: Task) -> bool:\n        if task_id in self.tasks:\n            return False\n        self.tasks[task_id] = task\n        self._",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        self.tasks[task_name].completed = True\n        logger.info(f\"Marked task as completed: {task_name}\")\n        self.save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(\"No task file found, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n\n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n\n    def mark_complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        return self\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_dict in tasks_data:\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        completed=task_dict[\"completed\"],\n                        created_at=datetime.fromisoformat(task_dict[\"created_at\"]) if task_dict[\"created_at\"] else None,\n                        completed_at=datetime.fromisoformat(task_dict[\"completed_at\"]) if task_dict[\"completed_at\"] else None\n                    )",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    priority: int = 1\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            data = json.loads(self.storage_path.read_text())\n            for task_dict in data:\n                task = Task(**task_dict)\n                self.tasks[task.name] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        task_list = [vars(task) for task in self.tasks.values()]\n        try:\n            self.storage_path.write_text(json.dumps(task_list, indent=2))\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists. Overwriting.\")\n        self.tasks[",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> bool:\n        logger.info(f\"Starting task {self.id}: {self.name}\")\n        time.sleep(self.duration)  # Simulate work\n        self.completed = True\n        logger.info(f\"Completed task {self.id}: {self.name}\")\n        return True\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def get_ready_tasks(self) -> List[Task]:\n        ready_tasks = []\n        for task_id, task in self.tasks.items():\n            if task.completed:\n                continue\n                \n            dependencies_met = all(\n                self.tasks[dep_id].completed \n                for dep_id in task.dependencies \n                if dep_id in self.tasks\n            )\n            \n            if dependencies_met:\n                ready_tasks.append(task)\n                \n        return ready_tasks\n    \n    def execute_all(self) -> None:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while not all(task.completed for task in self.tasks.values()):\n                ready_tasks = self.get_ready_tasks()\n                if not ready_tasks:\n                    time.sleep",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5 scale\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if not 1 <= self.priority <= 5:\n            raise ValueError(\"Priority must be between 1 and 5\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def filter_tasks(self, completed: Optional[bool",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, worker_name: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task {self.id}: not in PENDING state\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = worker_name\n        logger.info(f\"Task {self.id} started by {worker_name}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task {self.id}: not in IN_PROGRESS state\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"New task created: {task.name} (ID: {",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_completed_tasks(self) -> List",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 3  # 1 = highest, 5 = lowest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n\n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        now = datetime.now()\n        return [task for task in self.tasks.values() \n                if not task.completed and task.due_date < now]\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_dict in data:\n                task_dict['due_date'] = datetime.fromisoformat(task_dict['due_date'])\n                task = Task(**task_dict)\n                self.tasks[task.name] = task\n        except (json.JSONDecodeError, KeyError) as e:\n            print(f\"Error loading tasks: {e}\")\n\n    def",
    "import os\nimport json\nfrom datetime import datetime\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, starting fresh\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed=t[\"completed\"],\n                    tags=t[\"tags\"]\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        self.tasks[task_name].completed = True\n        logger.info(f\"Marked task as completed: {task_name}\")\n        self.save_tasks()\n        return True\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({name: task.__dict__ for name, task in self.tasks.items()}, f, default=str",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            self.tasks = []\n            for task_dict in data.get('tasks', []):\n                task = Task(\n                    id=task_dict['id'],\n                    title=task_dict['title'],\n                    description=task_dict['description'],\n                    completed=task_dict['completed'],\n                    created_at=datetime.fromisoformat(task_dict",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n\n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, description=description, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n\n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending = self.get_pending_tasks()\n        if not pending:\n            return None\n        return max(pending, key=lambda t: t.priority)\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    tasks = [\n        (\"Fix critical bug in authentication\", 5),\n        (\"Update documentation\", 2),\n        (\"Refactor database layer\", 3),\n        (\"Add new feature\", 4),\n        (\"Write tests\", 3),\n    ]\n    \n    for desc, priority in tasks:\n        manager.add_task(desc, priority)\n    \n    # Complete random tasks\n    for _ in range(2):\n        task_id = random.randint(1, len(tasks))\n        manager.complete_task(task_id)\n    \n    # Print pending tasks\n    print(\"Pending",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def __str__(self) -> str:\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (Priority: {self.priority}) - {self.description}\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def remove_task(self, task_name: str) -> Optional[Task]:\n        for i, task in enumerate(self.tasks):\n            if task.name == task_name:\n                removed_task = self.tasks.pop(i)\n                logger.info(f\"Removed task: {removed_task.name}\")\n                self.save_tasks()\n                return removed_task\n        logger.warning(f\"Task not found: {task_name}\")\n        return None\n    \n    def get_tasks_by_tag(self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_data in data:\n                        task = Task(\n                            id=task_data['id'],\n                            title=task_data['title'],\n                            description=task_data['description'],\n                            created_at=datetime.fromisoformat(task_data['created_at']),\n                            completed=task_data['completed'],\n                            tags=task_data['tags']\n                        )\n                        self.tasks[task.id] = task\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5 scale\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def get_all_tasks(self) -> List[Task]:\n        return sorted(self.tasks, key=lambda x: (x.completed, -x.priority))\n\n    def load_tasks(self):\n        if self.storage_path.exists():\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f",
    "import os\nimport logging\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: str\n    size: int\n    extension: str\n    is_hidden: bool\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, excluded_dirs: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.excluded_dirs = excluded_dirs or ['.git', 'node_modules', '__pycache__']\n        \n    @lru_cache(maxsize=100)\n    def get_extension(self, filename: str) -> str:\n        return os.path.splitext(filename)[1].lower()[1:] or \"no_extension\"\n    \n    def is_hidden(self, path: str) -> bool:\n        return os.path.basename(path).startswith('.')\n    \n    def should_exclude(self, path: str) -> bool:\n        dirname = os.path.basename(path)\n        return dirname in self.excluded_dirs or self.is_hidden(path)\n    \n    def analyze_file(self, filepath: str) -> FileStats:\n        try:\n            size = os.path.getsize(filepath)\n            extension = self.get_extension(filepath)\n            is_hidden = self.is_hidden(filepath)\n            return FileStats(filepath, size, extension, is_hidden)\n        except Exception as e:\n            logger.error(f\"Error analyzing {filepath}: {e}\")\n            return FileStats(filepath, 0, \"error\", False)\n    \n    def scan_directory(self) -> Dict[str, List[FileStats]]:\n        results: Dict[str, List[FileStats]] = {}\n        \n        with ThreadPoolExecut",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        return cls(\n            id=data[\"id\"],\n            title=data[\"title\"],\n            description=data[\"description\"],\n            created_at=datetime.fromisoformat(data[\"created_at\"]),\n            completed=data[\"completed\"],\n            tags=data.get(\"tags\", [])\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [Task.from_dict(task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except FileNotFoundError:\n            logger.warning(f\"No task file found at {self.storage_path}\")\n        except json.JSONDecodeError:\n            logger.error(f\"Invalid JSON in {self.storage_path}\")\n    \n    def save_",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                    self.tasks[task_id] = Task(**task_data)\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            tasks_dict = {\n                task_id: {**task.__dict__, 'created_at': task.created_at.isoformat()}\n                for task_id, task in self.tasks.items()\n            }\n            with open(self.storage_path, 'w') as f:\n                json",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom datetime import datetime\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    metadata: Dict[str, Any] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'name': self.name,\n            'priority': self.priority,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or [],\n            'metadata': self.metadata or {}\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Task':\n        return cls(\n            id=data['id'],\n            name=data['name'],\n            priority=data['priority'],\n            created_at=datetime.fromisoformat(data['created_at']),\n            completed=data['completed'],\n            tags=data['tags'],\n            metadata=data['metadata']\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task.from_dict(task_data) for task_data in data]\n                logger.info(f\"",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport requests\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"weather_service\")\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    conditions: str\n    humidity: Optional[int] = None\n    wind_speed: Optional[float] = None\n\nclass WeatherService:\n    def __init__(self, api_key: str, base_url: str):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.cache: Dict[str, WeatherData] = {}\n    \n    def get_weather(self, city: str) -> Optional[WeatherData]:\n        if city in self.cache:\n            logger.info(f\"Cache hit for {city}\")\n            return self.cache[city]\n        \n        logger.info(f\"Fetching weather data for {city}\")\n        try:\n            response = requests.get(\n                f\"{self.base_url}/weather\",\n                params={\"q\": city, \"appid\": self.api_key, \"units\": \"metric\"},\n                timeout=5\n            )\n            response.raise_for_status()\n            data = response.json()\n            \n            weather = WeatherData(\n                city=city,\n                temperature=data[\"main\"][\"temp\"],\n                conditions=data[\"weather\"][0][\"description\"],\n                humidity=data[\"main\"][\"humidity\"],\n                wind_speed=data[\"wind\"][\"speed\"]\n            )\n            self.cache[city] = weather\n            return weather\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching weather for {city}: {e}\")\n            return None\n\ndef get_multiple_weather(cities: List[str]) -> Dict[str, WeatherData]:\n    # Use environment variable or a default key (not recommended for production)\n    api_key = os.",
    "import os\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Set\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    extension: str\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions: Dict[str, int] = defaultdict(int)\n        self.large_files: List[FileInfo] = []\n        self.empty_dirs: List[str] = []\n        self.size_threshold = 1024 * 1024  # 1MB\n        \n    def analyze(self) -> None:\n        logger.info(f\"Starting analysis of {self.root_dir}\")\n        try:\n            for dirpath, dirnames, filenames in os.walk(self.root_dir):\n                if not filenames and not dirnames:\n                    self.empty_dirs.append(dirpath)\n                    continue\n                \n                for filename in filenames:\n                    full_path = os.path.join(dirpath, filename)\n                    try:\n                        file_size = os.path.getsize(full_path)\n                        _, ext = os.path.splitext(filename)\n                        ext = ext.lower()\n                        \n                        self.extensions[ext] += 1\n                        \n                        if file_size > self.size_threshold:\n                            self.large_files.append(\n                                FileInfo(full_path, file_size, ext)\n                            )\n                    except (PermissionError, FileNotFoundError) as e:\n                        logger.error(f\"Error accessing {full_path}: {e}\")\n            \n            logger.info(f\"Analysis complete. Found {len(self.large_files)} large files\")\n        except Exception as e:\n            logger.exception(f\"Analysis failed: {e",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to parse {self.storage_path}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) +",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    # Convert string dates to datetime objects\n                    created_at = datetime.fromisoformat(task_data['created_at'])\n                    due_date = datetime.fromisoformat(task_data['due_date']) if task_data.get('due_date') else None\n                    \n                    self.tasks[task_id] = Task(\n                        id=task_id,\n                        name=task_data['name'],\n                        created_at=created_at,\n                        completed=task_data['completed'],\n                        tags=task_data['tags'],\n                        due_date=due_date\n                    )\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    transaction_id: str\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n\n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description'],\n                    transaction_id=row['transaction_id']\n                ))\n\n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self._save_data()\n\n    def _save_data(self) -> None:\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=[\n                'date', 'amount', 'category', 'description', 'transaction_id'\n            ])\n            writer.writeheader()\n            for transaction in self.transactions:\n                writer.writerow({\n                    'date': transaction.date.strftime('%Y-%m-%d'),\n                    'amount': transaction.amount,\n                    'category': transaction.category,\n                    'description': transaction.description,\n                    'transaction_id': transaction.transaction_id\n                })\n\n    def get_summary_by_category(self) -> Dict[str, float]:\n        summary = {}\n        for transaction in self.transactions:\n            if transaction.category not in summary",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n        if isinstance(self.completed_at, str) and self.completed_at:\n            self.completed_at = datetime.fromisoformat(self.completed_at)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                for task_id, task_data in tasks_data.items():\n                    self.tasks[int(task_id)] = Task(**task_data)\n\n    def save_tasks(self) -> None:\n        serializable_tasks = {\n            task_id: {k: v.isoformat() if isinstance(v, datetime) else v \n                      for k, v in asdict(task).items()}\n            for task_id, task in self.tasks.items()\n        }\n        with open(self.storage_path, \"w\") as f:\n            json.dump(serializable_tasks, f, indent=2)\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >=",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except (json.JSONDecodeError, IOError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No task storage found, starting with empty task list\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except IOError",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[str] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.logger = logging.getLogger(__name__)\n        \n        if self.storage_path.exists():\n            self.load_tasks()\n    \n    def add_task(self, name: str, priority: int, dependencies: List[str] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task '{name}' already exists\")\n        \n        for dep in dependencies or []:\n            if dep not in self.tasks:\n                raise ValueError(f\"Dependency '{dep}' does not exist\")\n        \n        task = Task(name=name, priority=priority, dependencies=dependencies)\n        self.tasks[name] = task\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, name: str) -> None:\n        if name not in self.tasks:\n            raise ValueError(f\"Task '{name}' does not exist\")\n        \n        self.tasks[name].completed = True\n        self.save_tasks()\n    \n    def get_next_tasks(self) -> List[Task]:\n        available_tasks = []\n        \n        for task in self.tasks.values():\n            if task.completed:\n                continue\n                \n            dependencies_completed = all(\n                self.tasks[dep].completed for dep in task.dependencies\n            )\n            \n            if dependencies_completed:\n                available_tasks.append(task)\n        \n        return sorted(available_tasks, key=lambda t: t.priority, reverse=True)\n    \n    def save_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        logger.info(f\"Adding task: {task.name}\")\n        self.tasks.append(task)\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending = self.get_pending_tasks()\n        if not pending:\n            return None\n        return max(pending, key=lambda t: t.priority)\n\n@lru_cache(maxsize=100)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef main():\n    manager = TaskManager()\n    \n    # Create some sample tasks\n    for i in range(10):\n        priority = random.randint(1, 5)\n        manager.add_task(Task(id=i, name=f\"Task {i}\", priority=priority))\n    \n    # Process tasks by priority\n    while True:\n        task = manager.get_highest_priority",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    tasks_dict = json.load(f)\n                    for task_id, task_data in tasks_dict.items():\n                        self.tasks[int(task_id)] = Task(**task_data)\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_file}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_file, 'w') as f:\n                tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n                json.dump(tasks",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"TaskManager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, task: Task) -> int:\n        task_id = len(self.tasks)\n        self.tasks.append(task)\n        self.logger.info(f\"Added task '{task.name}' with ID {task_id}\")\n        return task_id\n    \n    def get_next_task(self) -> Optional[int]:\n        eligible_tasks = []\n        \n        for task_id, task in enumerate(self.tasks):\n            if task.status != TaskStatus.PENDING:\n                continue\n                \n            dependencies_met = all(\n                self.tasks[dep_id].status == TaskStatus.COMPLETED\n                for dep_id in task.dependencies\n            )\n            \n            if dependencies_met:\n                eligible_tasks.append((task_id, task.priority))\n        \n        if not eligible_tasks:\n            return None\n            \n        # Sort by priority (higher number = higher priority)\n        eligible_tasks.sort(key=lambda x: x[1], reverse",
    "import logging\nimport concurrent.futures\nimport random\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    difficulty: int\n    description: str\n    completed: bool = False\n    result: Optional[str] = None\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.max_workers = max_workers\n    \n    def process_task(self, task: Task) -> Task:\n        logger.info(f\"Processing task {task.id}: {task.description}\")\n        # Simulate work based on difficulty\n        processing_time = task.difficulty * random.uniform(0.5, 1.5)\n        time.sleep(processing_time)\n        \n        task.completed = True\n        task.result = f\"Completed in {processing_time:.2f}s\"\n        return task\n    \n    def process_tasks_parallel(self, tasks: List[Task]) -> List[Task]:\n        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Submit all tasks to the executor\n            future_to_task = {\n                executor.submit(self.process_task, task): task for task in tasks\n            }\n            \n            # Process results as they complete\n            results = []\n            for future in concurrent.futures.as_completed(future_to_task):\n                original_task = future_to_task[future]\n                try:\n                    processed_task = future.result()\n                    results.append(processed_task)\n                except Exception as e:\n                    logger.error(f\"Task {original_task.id} failed: {e}\")\n                    original_task.result = f\"Failed: {str(e)}\"\n                    results.append(original_task)\n            \n            return results\n\nif __name__ == \"__main__\":",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    completed=t[\"completed\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"complete",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    id: int\n    name: str\n    value: float\n    tags: List[str]\n\nclass Inventory:\n    def __init__(self):\n        self.items = {}\n        logger.info(\"Inventory initialized\")\n        \n    def add_item(self, item: Item) -> None:\n        self.items[item.id] = item\n        logger.info(f\"Added item: {item.name} (ID: {item.id})\")\n        \n    def remove_item(self, item_id: int) -> Optional[Item]:\n        if item_id in self.items:\n            item = self.items.pop(item_id)\n            logger.info(f\"Removed item: {item.name} (ID: {item.id})\")\n            return item\n        logger.warning(f\"Attempted to remove non-existent item ID: {item_id}\")\n        return None\n    \n    def find_items_by_tag(self, tag: str) -> List[Item]:\n        return [item for item in self.items.values() if tag in item.tags]\n    \n    @lru_cache(maxsize=32)\n    def calculate_total_value(self) -> float:\n        return sum(item.value for item in self.items.values())\n\ndef generate_random_items(count: int) -> List[Item]:\n    names = [\"Sword\", \"Shield\", \"Potion\", \"Scroll\", \"Gem\", \"Amulet\", \"Ring\"]\n    tags = [\"weapon\", \"defense\", \"magic\", \"valuable\", \"rare\", \"common\"]\n    \n    return [\n        Item(\n            id=i,\n            name=f\"{random.choice(['Ancient', 'Rusty', 'Shiny",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags or []\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed=t[\"completed\"],\n                        tags=t.get(\"tags\", [])\n                    )\n                    for t in tasks_data\n                ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.logger = self._setup_logger()\n        self._load_tasks()\n\n    def _setup_logger(self) -> logging.Logger:\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n\n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            self.logger.info(f\"No tasks file found at {self.storage_path}\")\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                    self.tasks[task_id] = Task(**task_data)\n            self.logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            self.logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self) -> None:\n        try:\n            task_dict = {}\n            for task_id, task in self.tasks.items():",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id: int = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime, \n                priority: int, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            priority=priority,\n            tags=tags\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(**task_dict)\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            tasks_data = [task.__dict__ for task in self.tasks.values()]\n            with open(self.storage_path, \"w\") as f:\n                json.dump(tasks_data, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except IOError as e:\n            logger.error(f\"Failed to save tasks: {e}\")",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n\n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                tasks_dict = json.load(f)\n                for task_id, task_data in tasks_dict.items():\n                    self.tasks[int(task_id)] = Task(**task_data)\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            tasks_dict = {task_id: asdict(task) for task_id, task in self.tasks.items()}\n            json.dump(tasks_dict, f, indent=2)\n\n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.tasks.get(task_id)\n        if task:\n            task.completed = True\n            task.completed_at = datetime.now().isoformat()\n            self.save_tasks()\n        return task\n\n    def get_tasks(self",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        self.dependencies = self.dependencies or []\n    \n    def execute(self) -> bool:\n        logger.info(f\"Executing task {self.name} (ID: {self.id})\")\n        try:\n            time.sleep(self.duration)  # Simulate work\n            return True\n        except Exception as e:\n            logger.error(f\"Error executing task {self.name}: {e}\")\n            return False\n\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.completed_tasks = set()\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def can_execute(self, task: Task) -> bool:\n        return all(dep in self.completed_tasks for dep in task.dependencies)\n        \n    def run(self) -> None:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.completed_tasks) < len(self.tasks):\n                pending_tasks = [\n                    task for task_id, task in self.tasks.items()\n                    if task_id not in self.completed_tasks and self.can_execute(task)\n                ]\n                \n                if not pending_tasks:\n                    logger.warning(\"Deadlock detected or all tasks completed\")\n                    break\n                    \n                # Sort by priority (higher number = higher priority)\n                pending_",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        result = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            result[\"due_date\"] = self.due_date.isoformat()\n        return result\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                \n            self.tasks = []\n            for task_dict in data:\n                due_date = None\n                if \"due_date\" in task_dict:\n                    due_date = datetime.fromisoformat(task_dict[\"due_date\"])\n                \n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n        \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_completed_tasks(self) ->",
    "import random\nfrom typing import List, Optional\nfrom dataclasses import dataclass\nfrom collections import defaultdict\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self):\n        self._tasks = {}\n        self._tags = defaultdict(set)\n        self._next_id = 1\n    \n    def add_task(self, name: str, priority: int = 1, tags: Optional[List[str]] = None) -> Task:\n        task = Task(id=self._next_id, name=name, priority=priority)\n        self._tasks[task.id] = task\n        self._next_id += 1\n        \n        if tags:\n            for tag in tags:\n                self._tags[tag].add(task.id)\n        \n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self._tasks.get(task_id)\n        if task:\n            return task.complete()\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [self._tasks[task_id] for task_id in self._tags.get(tag, set())]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self._tasks.values() \n                if task.priority >= min_priority and not task.completed]\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    # Add some tasks with tags\n    manager.add_task(\"Fix login bug\", 4, [\"bug\", \"frontend\"])\n    manager.add_task(\"Update documentation\", 2, [\"docs\"])\n    manager.add_task(\"Refactor authentication\", 3, [\"backend\", \"security\"])\n    manager.add_task(\"Deploy to production\", 5, [\"devops\"])\n    \n    # Complete a random task",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> Optional[Task]:\n        if 0 <= index < len(self.tasks):\n            task = self.tasks[index]\n            task.complete()\n            self.save_tasks()\n            return task\n        logger.warning(f\"Task index {index} out of range\")\n        return None\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task_data) for task_data in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task = Task(name=name, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_index: int) -> bool:\n        if 0 <= task_index < len(self.tasks):\n            self.tasks[task_index].complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            self.tasks = []\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = []\n                for task_data in data:\n                    task = Task(\n                        name=task_data[\"name",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        data = data.copy()\n        data[\"created_at\"] = datetime.fromisoformat(data[\"created_at\"])\n        return cls(**data)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task.from_dict(t) for t in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        \n    def to_dict(self):\n        return asdict(self)\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n            except (json.JSONDecodeError, FileNotFoundError):\n                self.tasks = []\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n    \n    def add_task(self, title, description):\n        task = Task(title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index):\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_pending_tasks(self):\n        return [task for task in self.tasks if not task.completed]",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport time\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        \n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        self.tasks[task_id] = Task(\n            id=task_id,\n            name=name,\n            priority=priority,\n            dependencies=dependencies or []\n        )\n        return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            return False\n        self.tasks[task_id].completed = True\n        return True\n    \n    def get_available_tasks(self) -> List[Task]:\n        result = []\n        for task in self.tasks.values():\n            if task.completed:\n                continue\n            \n            dependencies_completed = True\n            for dep_id in task.dependencies:\n                if dep_id in self.tasks and not self.tasks[dep_id].completed:\n                    dependencies_completed = False\n                    break\n                    \n            if dependencies_completed:\n                result.append(task)\n                \n        return sorted(result, key=lambda t: t.priority, reverse=True)\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some tasks\n    task1 = manager.add_task(\"Setup project\", 3)\n    task2 = manager.add_task(\"Write tests\", 2, [task1])\n    task3 = manager.add_task(\"Implement core features\", 3, [task1])\n    task4",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def save_tasks(self):",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, FileNotFoundError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No task file found, starting with empty task list\")\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: '{name}' with priority {priority}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Task added: {task.name} (ID: {task.id})\")\n        return task\n    \n    def assign_task(self, task_id: int, assignee: str) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.assigned_to = assignee\n            task.status = TaskStatus.IN_PROGRESS\n            logger.info(f\"Task {task.id} assigned to {assignee}\")\n            return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.status = TaskStatus.COMPLETED\n            logger.info(f\"Task {task.id} marked as completed\")\n            return True\n        return False\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags or []\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed=t[\"completed\"],\n                        tags=t.get(\"tags\", [])\n                    )\n                    for t in tasks_data\n                ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n\n    def save_tasks(self) -> None:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n\n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n\n    def add_task(self, name: str, description: str, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        # Validate dependencies\n        if dependencies:\n            for dep_id in dependencies:\n                if dep_id not in self.tasks:\n                    logger.warning(f\"Dependency {dep_id} not found, ignoring\")\n                    dependencies.remove(dep_id)\n        \n        self.tasks[task_id] = Task(task_id, name, description, dependencies=dependencies or [])\n        logger.info(f\"Added task: {name} with ID: {task_id}\")\n        return task_id\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.warning(f\"Task with ID {task_id} not found\")\n        return task\n    \n    def process_tasks(self) -> List[Task]:\n        completed_tasks = []\n        \n        for task_id, task in self.tasks",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n    \n    def add_task(self, title: str, description: str, due_date=None, tags=None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            tags=tags\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added new task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task {task_id}\")\n            return True\n        return False\n    \n    def get_incomplete_tasks",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task ID {task_id} not found\")\n            return None\n            \n        # Check dependencies\n        for dep_id in task.dependencies:\n            dep_task = self.tasks.get(dep_id)\n            if not dep_task or not dep_task.completed:\n                logger.warning(f\"Dependencies not met for task {task.name}\")\n                return None\n        \n        logger.info(f\"Processing task: {task.name}\")\n        time.sleep(task.duration)  # Simulate work\n        task.completed = True\n        return f\"Completed task: {task.name}\"\n    \n    def run_all(self) -> List[str]:\n        results = []\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while not all(task.completed for task in self.tasks.values()):\n                futures = []\n                for task_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus\n    assigned_to: Optional[str] = None\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def is_blocked(self) -> bool:\n        return self.status == TaskStatus.BLOCKED\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, title: str, description: str, \n                dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            status=TaskStatus.TODO,\n            dependencies=dependencies\n        )\n        \n        self.tasks[task_id] = task\n        logger.info(f\"Task {task_id} added: {title}\")\n        return task_id\n    \n    def assign_task(self, task_id: int, assignee: str) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Cannot assign task {task_id}: Task not found\")\n            return False",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=item['id'],\n                    title=item['title'],\n                    description=item['description'],\n                    completed=item['completed'],\n                    created_at=datetime.fromisoformat(item['created_at']),\n                    completed_at=datetime.fromisoformat(item['completed_at']) if item['completed_at",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task {task_id}\")\n            return True\n        return False\n    \n    def export_tasks(self, filename: str) -> None:\n        data = {\n            task_id:",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id: int = 1\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task with ID: {task_id}\")\n            return True\n        return False\n    \n    def list_tasks(self, tag_filter: Optional[str] = None) ->",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except (json.JSONDecodeError, FileNotFoundError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n                self.tasks = []\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def add_task(self",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added new task: '{task.name}'\")\n        self.save_tasks()\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump({name: task.__dict__ for name, task in self.tasks",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    description: str\n    category: str\n    transaction_id: str\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n\n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    description=row['description'],\n                    category=row['category'],\n                    transaction_id=row['transaction_id']\n                ))\n\n    def save_data(self):\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=[\n                'date', 'amount', 'description', 'category', 'transaction_id'\n            ])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'description': t.description,\n                    'category': t.category,\n                    'transaction_id': t.transaction_id\n                })\n\n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self.save_data()\n\n    def get_total_by_category(self, category: Optional[str] = None):\n        if category:\n            return sum(t.amount for t in self.transactions if t.category == category)\n        return {\n            cat",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task with name '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def delete_task(self, name: str) -> bool:\n        if name in self.tasks:\n            del self.tasks[name]\n            self._save_tasks()\n            logger.info(f\"Deleted task: {name}\")\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\nif __name__ == \"__main__\":\n    manager = TaskManager()",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].complete()\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, worker: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task {self.id}: not in PENDING state\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = worker\n        logger.info(f\"Task {self.id} started by {worker}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task {self.id}: not in IN_PROGRESS state\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created new task: {task.name} (ID: {task.id})\")",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = 'tasks.json'):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import os\nfrom typing import Dict, List, Optional\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nimport json\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    last_modified: float\n    file_type: str\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, exclude_dirs: Optional[List[str]] = None):\n        self.root_dir = Path(root_dir)\n        self.exclude_dirs = exclude_dirs or ['.git', 'venv', '__pycache__']\n        self.stats_by_type: Dict[str, List[FileStats]] = {}\n        \n    def analyze(self) -> Dict[str, List[FileStats]]:\n        logger.info(f\"Starting analysis of {self.root_dir}\")\n        start_time = time.time()\n        \n        try:\n            self._scan_directory(self.root_dir)\n            logger.info(f\"Analysis completed in {time.time() - start_time:.2f} seconds\")\n            return self.stats_by_type\n        except Exception as e:\n            logger.error(f\"Error during analysis: {e}\")\n            raise\n    \n    def _scan_directory(self, directory: Path) -> None:\n        for item in directory.iterdir():\n            if item.is_dir():\n                if item.name not in self.exclude_dirs:\n                    self._scan_directory(item)\n            else:\n                self._process_file(item)\n    \n    def _process_file(self, file_path: Path) -> None:\n        file_type = file_path.suffix.lstrip('.') or 'unknown'\n        \n        try:\n            stats = FileStats(\n                path=file_path,\n                size=file_path.stat().st_size,\n                last_modified=file",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task '{self.title}' marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task) for task in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport os\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task_data) for task_data in data]\n            except json.JSONDecodeError:\n                print(f\"Error loading tasks from {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Transaction:\n    date: datetime\n    description: str\n    amount: float\n    category: str\n    transaction_id: Optional[str] = None\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n    \n    def _load_transactions(self):\n        if not os.path.exists(self.data_file):\n            logger.info(f\"Creating new expense tracker file: {self.data_file}\")\n            return\n        \n        try:\n            with open(self.data_file, 'r', newline='') as file:\n                reader = csv.DictReader(file)\n                self.transactions = [\n                    Transaction(\n                        date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                        description=row['description'],\n                        amount=float(row['amount']),\n                        category=row['category'],\n                        transaction_id=row['transaction_id']\n                    )\n                    for row in reader\n                ]\n            logger.info(f\"Loaded {len(self.transactions)} transactions\")\n        except Exception as e:\n            logger.error(f\"Error loading transactions: {e}\")\n    \n    def add_transaction(self, transaction: Transaction):\n        transaction.transaction_id = f\"TX{datetime.now().strftime('%Y%m%d%H%M%S')}\"\n        self.transactions.append(transaction)\n        self._save_transactions()\n        return transaction\n    \n    def _save_transactions(self):\n        try:\n            with open(self.data_file, 'w',",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.max_workers = max_workers\n        self.completed_tasks: Dict[int, Task] = {}\n        \n    def process_task(self, task: Task) -> str:\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Task {task.name} completed successfully\"\n        self.completed_tasks[task.id] = task\n        return result\n        \n    def can_process(self, task: Task) -> bool:\n        return all(dep_id in self.completed_tasks for dep_id in task.dependencies)\n    \n    def process_tasks(self, tasks: List[Task]) -> Dict[int, str]:\n        results = {}\n        pending_tasks = tasks.copy()\n        \n        while pending_tasks:\n            eligible_tasks = [task for task in pending_tasks if self.can_process(task)]\n            \n            if not eligible_tasks:\n                logger.warning(\"Dependency deadlock detected or invalid dependencies\")\n                break\n                \n            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n                future_to_task = {\n                    executor.submit(self.process_task, task): task for task in eligible_tasks\n                }\n                \n                for future in future_to_task:\n                    task =",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file {self.storage_path} not found, creating new task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                self.tasks = {int(id): Task(**data) for id, data in tasks_data.items()}\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_dict = {str(id): asdict(task) for id, task in self.tasks.items()}\n                json.dump(tasks_dict, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except IOError",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass WeatherData:\n    city: str\n    temperature: float\n    humidity: int\n    description: str\n    wind_speed: float\n\nclass WeatherService:\n    def __init__(self, api_key: str, base_url: str = \"https://api.example.com/weather\"):\n        self.api_key = api_key\n        self.base_url = base_url\n        self.session = requests.Session()\n    \n    def get_weather(self, city: str) -> Optional[WeatherData]:\n        try:\n            logger.info(f\"Fetching weather data for {city}\")\n            # Simulate API call\n            time.sleep(0.5)  # Simulate network delay\n            \n            # In a real app, you'd use:\n            # response = self.session.get(\n            #     f\"{self.base_url}?city={city}&api_key={self.api_key}\"\n            # )\n            \n            # Simulated response\n            mock_data = {\n                \"London\": (15.2, 78, \"Cloudy\", 12.5),\n                \"New York\": (22.1, 65, \"Sunny\", 8.2),\n                \"Tokyo\": (28.5, 70, \"Clear\", 5.8),\n                \"Sydney\": (26.3, 60, \"Partly cloudy\", 14.3),\n                \"Paris\": (18.7, 82, \"Rainy\", 10.1)\n            }\n            \n            if city not in mock_data:\n                return None\n                \n            temp, humidity, desc, wind = mock_data[city]\n            return WeatherData(city, temp, humidity, desc, wind)\n            \n        except Exception as e",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.results = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> str:\n        task = self.tasks[task_id]\n        logger.info(f\"Starting task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate occasional failures\n        if random.random() < 0.1:\n            logger.error(f\"Task {task.name} failed!\")\n            raise Exception(f\"Task {task.name} failed\")\n            \n        result = f\"Completed {task.name} in {task.duration:.2f}s\"\n        logger.info(result)\n        return result\n    \n    def execute_all(self) -> dict:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Find tasks with no dependencies\n            ready_tasks = [\n                task_id for task_id, task in self.tasks.items() \n                if not task.dependencies\n            ]\n            \n            # Process tasks in order of dependencies\n            while ready_tasks:\n                futures = {\n                    executor.submit(self.process_task",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n\n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_data in data:\n                        if 'due_date' in task_data and task_data['due_date']:\n                            task_data['due_date'] = datetime.fromisoformat(task_data['due_date'])\n                        self.tasks.append(Task(**task_data))\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n\n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_data = []\n                for task in self.tasks:\n                    task_dict = asdict(task)\n                    if task_dict['due_date']:\n                        task_dict['due_date'] = task_dict['due_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    id: int\n    name: str\n    value: float\n    \n    def __str__(self) -> str:\n        return f\"Item(id={self.id}, name={self.name}, value=${self.value:.2f})\"\n\nclass Inventory(ABC):\n    @abstractmethod\n    def add_item(self, item: Item) -> None:\n        pass\n    \n    @abstractmethod\n    def remove_item(self, item_id: int) -> Optional[Item]:\n        pass\n    \n    @abstractmethod\n    def list_items(self) -> List[Item]:\n        pass\n\nclass SimpleInventory(Inventory):\n    def __init__(self):\n        self.items = {}\n        logger.info(\"Created new inventory\")\n        \n    def add_item(self, item: Item) -> None:\n        self.items[item.id] = item\n        logger.info(f\"Added {item}\")\n        \n    def remove_item(self, item_id: int) -> Optional[Item]:\n        if item_id in self.items:\n            item = self.items.pop(item_id)\n            logger.info(f\"Removed {item}\")\n            return item\n        logger.warning(f\"Failed to remove item with id {item_id}: not found\")\n        return None\n    \n    def list_items(self) -> List[Item]:\n        return list(self.items.values())\n\ndef main():\n    inventory = SimpleInventory()\n    \n    # Add some random items\n    for i in range(5):\n        item = Item(\n            id=i,\n            name=f\"Item-{chr(65+i)}\",\n            value=round(random.uniform(10.0, 100.0), 2)",
    "import argparse\nimport csv\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\n\n@dataclass\nclass SalesRecord:\n    date: str\n    product_id: str\n    quantity: int\n    unit_price: float\n    \n    @property\n    def total_price(self) -> float:\n        return self.quantity * self.unit_price\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_file: Path):\n        self.data_file = data_file\n        self.records: List[SalesRecord] = []\n        self.logger = logging.getLogger(__name__)\n        \n    def load_data(self) -> None:\n        self.logger.info(f\"Loading data from {self.data_file}\")\n        try:\n            with open(self.data_file, 'r', newline='') as csvfile:\n                reader = csv.DictReader(csvfile)\n                for row in reader:\n                    record = SalesRecord(\n                        date=row['date'],\n                        product_id=row['product_id'],\n                        quantity=int(row['quantity']),\n                        unit_price=float(row['unit_price'])\n                    )\n                    self.records.append(record)\n            self.logger.info(f\"Loaded {len(self.records)} records\")\n        except Exception as e:\n            self.logger.error(f\"Failed to load data: {e}\")\n            raise\n    \n    def get_total_sales(self) -> float:\n        return sum(record.total_price for record in self.records)\n    \n    def get_sales_by_product(self) -> dict:\n        result = {}\n        for record in self.records:\n            if record.product_id not in result:\n                result[record.product_id] = 0\n            result[record.product_id] += record.total_price\n        return result\n    \n    def find_best_selling_product(self) -> Optional[str]:\n        sales_by_product = self.get_sales_by_product()\n        if not",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def apply_discount(self, percentage: float) -> float:\n        return self.price * (1 - percentage / 100)\n\n\nclass Inventory:\n    def __init__(self, data_file: str = \"inventory.json\"):\n        self.data_file = data_file\n        self.products: Dict[int, Product] = {}\n        self._load_inventory()\n    \n    def _load_inventory(self) -> None:\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, 'r') as f:\n                    data = json.load(f)\n                    for item in data:\n                        self.products[item['id']] = Product(**item)\n                logger.info(f\"Loaded {len(self.products)} products from inventory\")\n            except Exception as e:\n                logger.error(f\"Error loading inventory: {e}\")\n        else:\n            logger.warning(f\"Inventory file {self.data_file} not found\")\n    \n    def save(self) -> None:\n        with open(self.data_file, 'w') as f:\n            json.dump([asdict(p) for p in self.products.values()], f, indent=2)\n        logger.info(\"Inventory saved to file\")\n    \n    def add_product(self, product: Product)",
    "import os\nimport json\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\n\nclass FileAnalyzer:\n    def __init__(self, directory: str):\n        self.directory = directory\n        self.results = defaultdict(int)\n        self.errors = []\n\n    def analyze(self) -> Dict[str, int]:\n        \"\"\"Analyze files in the directory and count by extension.\"\"\"\n        try:\n            for root, _, files in os.walk(self.directory):\n                for file in files:\n                    _, ext = os.path.splitext(file)\n                    if ext:\n                        self.results[ext.lower()] += 1\n                    else:\n                        self.results[\"no_extension\"] += 1\n            return dict(self.results)\n        except Exception as e:\n            self.errors.append(str(e))\n            return {}\n\n    def get_errors(self) -> List[str]:\n        return self.errors\n\n\nclass AnalysisManager:\n    def __init__(self):\n        self.analyses = {}\n        \n    def run_analysis(self, directory: str) -> Optional[Dict[str, int]]:\n        if not os.path.exists(directory):\n            return None\n            \n        analyzer = FileAnalyzer(directory)\n        results = analyzer.analyze()\n        \n        timestamp = datetime.now().isoformat()\n        self.analyses[timestamp] = {\n            \"directory\": directory,\n            \"results\": results,\n            \"errors\": analyzer.get_errors()\n        }\n        \n        return results\n        \n    def save_report(self, filename: str) -> bool:\n        try:\n            with open(filename, 'w') as f:\n                json.dump(self.analyses, f, indent=2)\n            return True\n        except Exception:\n            return False\n\n\nif __name__ == \"__main__\":\n    manager = AnalysisManager()\n    \n    # Analyze current directory\n    results = manager.run_analysis(\".\")\n    \n    if results:\n        print(f\"Found {sum(results.values())} files\")\n        for ext, count",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> bool:\n        logger.info(f\"Starting task {self.name} (ID: {self.id})\")\n        try:\n            time.sleep(self.duration)\n            success = random.random() > 0.2  # 20% chance of failure\n            status = \"completed\" if success else \"failed\"\n            logger.info(f\"Task {self.name} {status}\")\n            return success\n        except Exception as e:\n            logger.error(f\"Error executing task {self.name}: {e}\")\n            return False\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def can_execute(self, task_id: int, completed: List[int]) -> bool:\n        task = self.tasks.get(task_id)\n        if not task:\n            return False\n        return all(dep in completed for dep in task.dependencies)\n    \n    def execute_all(self) -> List[int]:\n        completed = []\n        failed = []\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(completed) + len(failed) < len(self.tasks):\n                pending = []\n                \n                for task_id, task",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    completion_time: Optional[float] = None\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_next_task(self) -> Optional[Task]:\n        pending_tasks = [t for t in self.tasks if t.status == TaskStatus.PENDING]\n        if not pending_tasks:\n            return None\n        return max(pending_tasks, key=lambda t: t.priority)\n    \n    def process_tasks(self, max_tasks: int = 5):\n        processed = 0\n        while processed < max_tasks:\n            next_task = self.get_next_task()\n            if not next_task:\n                logger.info(\"No more pending tasks\")\n                break\n                \n            logger.info(f\"Processing task: {next_task.name}\")\n            next_task.status = TaskStatus.IN_PROGRESS\n            \n            try:\n                # Simulate work\n                processing_time = random.uniform(0.1, 0.5)\n                time.",
    "import os\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Set, Tuple\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    extension: str\n    \n    @property\n    def name(self) -> str:\n        return os.path.basename(self.path)\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str):\n        self.root_dir = os.path.abspath(root_dir)\n        self.files: List[FileInfo] = []\n        self.extension_counts: Dict[str, int] = defaultdict(int)\n        self.total_size = 0\n        \n    def scan_directory(self) -> None:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        try:\n            for root, _, files in os.walk(self.root_dir):\n                for filename in files:\n                    full_path = os.path.join(root, filename)\n                    try:\n                        file_size = os.path.getsize(full_path)\n                        _, extension = os.path.splitext(filename)\n                        extension = extension.lower()\n                        \n                        file_info = FileInfo(full_path, file_size, extension)\n                        self.files.append(file_info)\n                        self.extension_counts[extension] += 1\n                        self.total_size += file_size\n                    except OSError as e:\n                        logger.error(f\"Error accessing {full_path}: {e}\")\n        except Exception as e:\n            logger.error(f\"Error scanning directory: {e}\")\n            \n    def get_largest_files(self, n: int = 5) -> List[FileInfo]:\n        return sorted(self.files, key=lambda x: x.size, reverse=True)[:n]\n    \n    def get_extension_summary",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: Optional[str] = None, tags: List[str] = None) -> Task:\n        due_date_obj = datetime.fromisoformat(due_date) if due_date else None\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date_obj, tags=tags or [])\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            return None\n        \n        for key, value in kwargs.items():\n            if key == 'due_date' and value and isinstance(value, str):\n                value = datetime.fromisoformat(value)\n            setattr(task, key, value)\n        \n        self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def add_task(self, description: str, priority: int) -> Task:\n        task = Task(id=self.next_id, description=description, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task}\")\n            return task\n        return None\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def get_priority_tasks(self, min_priority: int) -> List[Task]:\n        return [task for task in self.tasks \n                if task.priority >= min_priority and not task.completed]\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    for i in range(5):\n        priority = random.randint(1, 10)\n        manager.add_task(f\"Sample task #{i+1}\", priority)\n    \n    # Complete a random task\n    random_id = random.randint(1, 5)\n    manager.complete_task",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json_data = {name: {\n                \"name\":",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Starting task {task.name} (ID: {task.id})\")\n        \n        # Wait for dependencies to complete\n        for dep_id in task.dependencies:\n            if dep_id in self.tasks and self.tasks[dep_id].result is None:\n                logger.warning(f\"Task {task.name} waiting for dependency {dep_id}\")\n                return None\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Generate a result\n        task.result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        logger.info(f\"Completed task {task.name} with result: {task.result}\")\n        return task.result\n    \n    def run_all(self) -> Dict[int, Any]:\n        remaining_tasks = set(self.tasks.keys())\n        results = {}\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        return None\n    \n    def get_all_tasks(self) -> List[Task]:\n        return self.tasks",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task with ID {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Marked task {task_id} as completed\")",
    "import random\nfrom typing import List, Dict, Tuple\nfrom collections import defaultdict\nimport time\n\n\nclass Task:\n    def __init__(self, name: str, priority: int, duration: float):\n        self.name = name\n        self.priority = priority\n        self.duration = duration\n        self.completed = False\n    \n    def execute(self) -> None:\n        print(f\"Executing task: {self.name} (Priority: {self.priority})\")\n        time.sleep(self.duration)\n        self.completed = True\n        print(f\"Completed task: {self.name}\")\n    \n    def __repr__(self) -> str:\n        return f\"Task(name='{self.name}', priority={self.priority}, duration={self.duration})\"\n\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks: Dict[int, List[Task]] = defaultdict(list)\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.priority].append(task)\n    \n    def get_next_task(self) -> Task:\n        if not self.tasks:\n            return None\n        \n        highest_priority = max(self.tasks.keys())\n        task = self.tasks[highest_priority].pop(0)\n        \n        if not self.tasks[highest_priority]:\n            del self.tasks[highest_priority]\n            \n        return task\n    \n    def run(self, max_tasks: int = None) -> List[Task]:\n        completed_tasks = []\n        tasks_executed = 0\n        \n        while self.tasks and (max_tasks is None or tasks_executed < max_tasks):\n            task = self.get_next_task()\n            task.execute()\n            completed_tasks.append(task)\n            tasks_executed += 1\n            \n        return completed_tasks\n\n\ndef generate_random_tasks(count: int) -> List[Task]:\n    task_names = [\"Data processing\", \"File backup\", \"API request\", \"Database query\", \n                 \"Image conversion\", \"Email sending\", \"Report generation\"]\n    \n    return [\n        Task(",
    "import csv\nimport logging\nimport os\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import List, Optional\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    id: Optional[int] = None\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str = \"expenses.csv\"):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self.logger = self._setup_logger()\n        self._load_data()\n\n    def _setup_logger(self):\n        logger = logging.getLogger(\"expense_tracker\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n\n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            self.logger.info(f\"No data file found at {self.data_file}, starting fresh\")\n            return\n\n        try:\n            with open(self.data_file, \"r\", newline=\"\") as file:\n                reader = csv.reader(file)\n                next(reader)  # Skip header\n                for i, row in enumerate(reader, 1):\n                    if len(row) >= 4:\n                        date = datetime.strptime(row[0], \"%Y-%m-%d\")\n                        amount = float(row[1])\n                        category = row[2]\n                        description = row[3]\n                        self.transactions.append(\n                            Transaction(date, amount, category, description, i)\n                        )\n            self.logger.info(f\"Loaded {len(self.transactions)} transactions\")\n        except Exception as e:\n            self.logger.error(f\"Error loading data: {e}\")\n\n    def add_transaction(self, transaction: Transaction):\n        transaction.id = len(self.transactions) + 1\n        self.transactions.",
    "import os\nimport json\nimport logging\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        logger.info(f\"Created task: {task.title} (ID: {task.id})\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n        self.save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save_tasks(self) -> None:\n        with",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                        if task_data['completed_at']:\n                            task_data['completed_at'] = datetime.fromisoformat(task_data['completed_at'])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, FileNotFoundError):\n                pass\n\n    def _save_tasks(self) -> None:\n        serialized_tasks = {}\n        for task_id, task in self.tasks.items():\n            task_dict = asdict(task)\n            task_dict['created_at'] = task.created_at.isoformat()\n            if task.completed_at:\n                task_dict['completed_at'] = task.completed_at.isoformat",
    "import os\nimport json\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Tuple\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = self._load_tasks()\n        \n    def _load_tasks(self) -> Dict[str, List[Dict]]:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                print(f\"Error loading tasks from {self.storage_path}\")\n                return defaultdict(list)\n        return defaultdict(list)\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump(self.tasks, f, indent=2)\n    \n    def add_task(self, category: str, title: str, description: str, due_date: Optional[str] = None) -> bool:\n        task = {\n            \"id\": self._generate_id(),\n            \"title\": title,\n            \"description\": description,\n            \"due_date\": due_date,\n            \"created_at\": datetime.now().isoformat(),\n            \"completed\": False\n        }\n        self.tasks[category].append(task)\n        self._save_tasks()\n        return True\n    \n    def _generate_id(self) -> str:\n        return datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    \n    def complete_task(self, category: str, task_id: str) -> bool:\n        for task in self.tasks[category]:\n            if task[\"id\"] == task_id:\n                task[\"completed\"] = True\n                task[\"completed_at\"] = datetime.now().isoformat()\n                self._save_tasks()\n                return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Tuple[str, Dict",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Task':\n        return cls(\n            id=data['id'],\n            title=data['title'],\n            description=data['description'],\n            created_at=datetime.fromisoformat(data['created_at']),\n            completed=data['completed'],\n            tags=data['tags']\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task.from_dict(task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_dict = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in tasks_dict.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_dict = {str(k): asdict(v) for k, v in self.tasks.items()}\n                json.dump(tasks_dict, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self._save_tasks()\n    \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, default=str)\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: datetime, tags: List[str] = None) -> Task:\n        task_id = max([t.id for t in self.tasks], default=0) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t['id'],\n                    title=t['title'],\n                    description=t['description'],\n                    completed=t['completed'],\n                    created_at=datetime.fromisoformat(t['created_at']),\n                    completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> bool:\n        logger.info(f\"Starting task {self.name} (ID: {self.id})\")\n        try:\n            time.sleep(self.duration)\n            success = random.random() > 0.2  # 80% success rate\n            status = \"completed\" if success else \"failed\"\n            logger.info(f\"Task {self.name} {status} after {self.duration:.2f}s\")\n            return success\n        except Exception as e:\n            logger.error(f\"Error executing task {self.name}: {e}\")\n            return False\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.completed = set()\n        self.max_workers = max_workers\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n    \n    def can_execute(self, task: Task) -> bool:\n        return all(dep_id in self.completed for dep_id in task.dependencies)\n    \n    def run(self) -> bool:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.completed) < len(self.tasks):\n                pending_tasks = [\n                    task for task_id, task in self.tasks.items()\n                    if task_id not in self.completed and self.can_execute",
    "import json\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(\n                            id=task_dict[\"id\"],\n                            title=task_dict[\"title\"],\n                            description=task_dict[\"description\"],\n                            created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                            completed=task_dict[\"completed\"],\n                            tags=task_dict[\"tags\"]\n                        )\n                        self.tasks[task.id] = task\n                        self.next_id = max(self.next_id, task.id + 1)",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        task_dict = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            task_dict[\"due_date\"] = self.due_date.isoformat()\n        return task_dict\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n        \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data.get(\"tasks\", []):\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        completed=task_dict[\"completed\"],\n                        tags=task_dict.get(\"tags\", [])\n                    )\n                    if \"due_date\" in task_dict and task_dict[\"due_",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: str):\n        self.station_id = station_id\n        self.location = location\n        self.temperature_readings: List[float] = []\n        self.humidity_readings: List[float] = []\n        \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n        \n    def average_temperature(self) -> float:\n        if not self.temperature_readings:\n            return 0.0\n        return sum(self.temperature_readings) / len(self.temperature_readings)\n    \n    def average_humidity(self) -> float:\n        if not self.humidity_readings:\n            return 0.0\n        return sum(self.humidity_readings) / len(self.humidity_readings)\n    \n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n        \n    def add_station(self, station: WeatherStation) -> None:\n        self.stations[station.station_id] = station\n        \n    def get_station(self, station_id: str) -> WeatherStation:\n        return self.stations.get(station_id)\n    \n    def regional_average(self, location: str) -> Tuple[float, float]:\n        stations = [s for s in self.stations.values() if s.location == location]\n        if not stations:\n            return 0.0, 0.0\n        \n        avg_temp = sum(s.average_temperature() for s in stations) / len(stations)\n        avg_humid = sum(s.average_humidity() for s in stations) / len(stations)\n        return avg_temp, avg_humid\n    \n    def generate_report(self) -> Dict[str, Dict[str, Tuple[float, float]]]:\n        report = defaultdict(dict)\n        for station in self.stations.values():",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"□\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n\ndef main",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in data.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, IOError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({str(k): asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except IOError",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        self.next_id += 1\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        data = data.copy()\n        if \"created_at\" in data and isinstance(data[\"created_at\"], str):\n            data[\"created_at\"] = datetime.fromisoformat(data[\"created_at\"])\n        return cls(**data)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            logger.warning(f\"Task with ID {task.id} already exists, updating\")\n        self.tasks[task.id] = task\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id not in self.tasks:",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1-5 scale\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        try:\n            with open(self.storage_file, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict['due_date'] = datetime.fromisoformat(task_dict['due_date'])\n                    self.tasks[task_dict['id']] = Task(**task_dict)\n        except (FileNotFoundError, json.JSONDecodeError):\n            self.tasks = {}\n\n    def _save_tasks(self):\n        with open(self.storage_file, 'w') as f:\n            tasks_list = []\n            for task in self.tasks.values():\n                task_dict = task.__dict__.copy()\n                task_dict['due_date'] = task_dict['due_date'].isoformat()\n                tasks_list.append(task_dict)\n            json.dump(tasks_list, f, indent=2)\n\n    def add_task(self, title: str, description: str, due_date: datetime,\n                tags: List[str] = None, priority: int = 1) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            tags=tags or [],\n            priority=priority\n        )\n        self",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"☐\"\n        due = f\", due: {self.due_date.strftime('%Y-%m-%d')}\" if self.due_date else \"\"\n        return f\"[{status}] {self.name} (priority: {self.priority}{due})\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return sorted(\n            [task for task in self.tasks if not task.completed],\n            key=lambda x: x.priority, reverse=True\n        )\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json_data = []\n            for task in self.tasks:\n                task_dict = {\n                    'name': task.name,\n                    'priority': task.priority,\n                    'completed': task.completed,\n                    'due_date': task.due_date.iso",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        return self\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({name: vars(task) for name, task in self.tasks.items()}, f, indent=2)\n        logger.info(f\"Tasks saved to {self.storage_path}\")\n    \n    def load(self) -> bool:\n        try:\n            if self",
    "import os\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def to_dict(self) -> Dict:\n        return {\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags,\n            'priority': self.priority\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_title: str) -> bool:\n        for task in self.tasks:\n            if task.title == task_title:\n                task.completed = True\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Wait for dependencies to complete\n        for dep_id in task.dependencies:\n            if dep_id in self.tasks and self.tasks[dep_id].result is None:\n                raise ValueError(f\"Dependency {dep_id} not completed before task {task_id}\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Generate result\n        result = f\"Result of task {task.name}: {random.randint(1, 100)}\"\n        task.result = result\n        logger.info(f\"Completed task {task.name} (ID: {task.id})\")\n        return result\n    \n    def execute_all(self) -> Dict[int, Any]:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Sort tasks by dependencies\n            sorted_tasks = self._sort_tasks_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    completed: bool = False\n    description: Optional[str] = None\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.id}: {self.title}\"\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self._load_tasks()\n        \n    def add_task(self, title: str, description: Optional[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self._save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def list_tasks(self, show_completed: bool = True) -> List[Task]:\n        if show_completed:\n            return self.tasks\n        return [task for task in self.tasks if not task.completed]\n    \n    def _save_tasks(self):\n        data = [\n            {\n                \"id\": task.id,\n                \"title\": task.title,\n                \"completed\": task.completed,\n                \"description\": task.description",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: str):\n        self.station_id = station_id\n        self.location = location\n        self.temperature_readings: List[float] = []\n        self.humidity_readings: List[float] = []\n    \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n    \n    def average_temperature(self) -> float:\n        return sum(self.temperature_readings) / len(self.temperature_readings) if self.temperature_readings else 0\n    \n    def average_humidity(self) -> float:\n        return sum(self.humidity_readings) / len(self.humidity_readings) if self.humidity_readings else 0\n    \n    def __str__(self) -> str:\n        return f\"Station {self.station_id} at {self.location}\"\n\n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n    \n    def add_station(self, station: WeatherStation) -> None:\n        self.stations[station.station_id] = station\n    \n    def get_station(self, station_id: str) -> WeatherStation:\n        return self.stations.get(station_id)\n    \n    def regional_averages(self) -> Dict[str, Tuple[float, float]]:\n        region_data = defaultdict(lambda: ([], []))\n        \n        for station in self.stations.values():\n            temps, humids = region_data[station.location]\n            temps.extend(station.temperature_readings)\n            humids.extend(station.humidity_readings)\n        \n        return {\n            location: (\n                sum(temps) / len(temps) if temps else 0,\n                sum(humids) / len(humids) if humids else 0\n            )\n            for location, (temps, humids) in region_data",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskPriority(Enum):\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n    CRITICAL = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: TaskPriority\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, description: str, priority: TaskPriority) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        self.logger.info(f\"Added task {task_id}: {description} ({priority.name})\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.logger.info(f\"Completed task {task_id}: {task.description}\")\n            return task\n        return None\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        self.logger.warning(f\"Task {task_id} not found\")\n        return None\n    \n    def get_tasks_by_priority(self, priority: TaskPriority) -> List[Task]:",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def mark_complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task '{self.title}' marked as complete\")\n    \n    def to_dict(self):\n        return {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed=t[\"completed\"],\n                    completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                )\n                for t in tasks_data",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: datetime, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags or [])\n        self.tasks[task_id] = task\n        self.save_tasks()\n        logger.info(f\"Added task: {title} (ID: {task_id})\")\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return None\n        \n        self.tasks[task_id].completed = True\n        self.save_tasks()\n        logger.info(f\"Marked task {task_id} as completed\")",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n        \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n        \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def create_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created task {task_id}: {name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_task_by_i",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.title}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.storage_path = storage_path or Path(\"tasks.json\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added new task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task {task_id}\")\n            return True\n        return False\n    \n    def save(",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return self.due_date and not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, file_path: str = \"tasks.json\"):\n        self.file_path = file_path\n        self.tasks = []\n        self.load_tasks()\n\n    def load_tasks(self):\n        try:\n            with open(self.file_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [\n                    Task(\n                        id=item[\"id\"],\n                        title=item[\"title\"],\n                        description=item[\"description\"],\n                        created_at=datetime.fromisoformat(item[\"created_at\"]),\n                        due_date=datetime.fromisoformat(item[\"due_date\"]) if item[\"due_date\"] else None,\n                        completed=item[\"completed\"],\n                        tags=item[\"tags\"]\n                    )\n                    for item in data\n                ]\n        except (FileNotFoundError, json.JSONDecodeError):\n            self.tasks = []\n\n    def save_tasks(self):\n        with open(self.file",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.id}: {self.name} (priority: {self.priority})\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n        \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task}\")\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def get_sorted_tasks(self, by_priority: bool = False) -> List[Task]:\n        if by_priority:\n            return sorted(self.tasks, key=lambda t: (-t.priority, t.id))\n        return sorted(self.tasks, key=lambda t: t.id)\n    \n    def get_stats(self) -> dict:\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks if task.completed)\n        return {\n            \"",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    id: int\n    name: str\n    value: float\n    category: str\n    \n    def __post_init__(self):\n        self.value = round(self.value, 2)\n    \n    def display(self) -> str:\n        return f\"{self.name} (${self.value:.2f})\"\n\n\nclass Inventory:\n    def __init__(self):\n        self.items: List[Item] = []\n        \n    def add_item(self, item: Item) -> None:\n        self.items.append(item)\n        logger.info(f\"Added item: {item.display()}\")\n        \n    def remove_item(self, item_id: int) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.id == item_id:\n                removed = self.items.pop(i)\n                logger.info(f\"Removed item: {removed.display()}\")\n                return removed\n        logger.warning(f\"Item with id {item_id} not found\")\n        return None\n    \n    def get_by_category(self, category: str) -> List[Item]:\n        return [item for item in self.items if item.category == category]\n    \n    @lru_cache(maxsize=32)\n    def total_value(self) -> float:\n        return round(sum(item.value for item in self.items), 2)\n\n\ndef main():\n    inventory = Inventory()\n    categories = [\"Electronics\", \"Books\", \"Clothing\", \"Food\"]\n    \n    # Generate random items\n    for i in range(10):\n        item = Item(\n            id=i,\n            name=f\"Item-{i}\",\n            value=random.uniform(10",
    "import os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:",
    "import argparse\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Set\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    extension: str\n    \n    @property\n    def size_in_kb(self) -> float:\n        return self.size / 1024\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: Path):\n        self.root_dir = root_dir\n        self.file_stats: List[FileStats] = []\n        self.extensions: Set[str] = set()\n        \n    def analyze(self, ignored_dirs: Optional[List[str]] = None) -> None:\n        ignored = set(ignored_dirs or [])\n        logger.info(f\"Starting analysis of {self.root_dir}\")\n        \n        for file_path in self.root_dir.rglob('*'):\n            if file_path.is_file() and not any(d in file_path.parts for d in ignored):\n                extension = file_path.suffix.lower()\n                size = file_path.stat().st_size\n                \n                self.file_stats.append(FileStats(\n                    path=file_path.relative_to(self.root_dir),\n                    size=size,\n                    extension=extension\n                ))\n                self.extensions.add(extension)\n        \n        logger.info(f\"Analysis complete. Found {len(self.file_stats)} files.\")\n    \n    def get_stats_by_extension(self) -> Dict[str, int]:\n        result = {}\n        for ext in self.extensions:\n            total_size = sum(f.size for f in self.file_stats if f.extension == ext)\n            result[ext] = total_size\n        return result\n    \n    def export_to_json(self, output_file: Path) -> None:\n        with output_file.open('",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    assigned_to: Optional[str] = None\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        logger.info(\"Task Manager initialized\")\n        \n    def add_task(self, task: Task) -> int:\n        task_id = len(self.tasks)\n        self.tasks.append(task)\n        logger.info(f\"Added task '{task.name}' with ID {task_id}\")\n        return task_id\n    \n    def update_status(self, task_id: int, status: TaskStatus) -> bool:\n        if 0 <= task_id < len(self.tasks):\n            old_status = self.tasks[task_id].status\n            self.tasks[task_id].status = status\n            logger.info(f\"Task {task_id} status changed: {old_status} -> {status}\")\n            return True\n        logger.error(f\"Invalid task ID: {task_id}\")\n        return False\n    \n    def assign_task(self, task_id: int, person: str) -> bool:\n        if 0 <= task_id < len(self.tasks):\n            self.tasks[task_id].assigned_to = person\n            logger.info(f\"Task {task_id} assigned to {person}\")\n            return True\n        logger.error(f\"Invalid task",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t['id'],\n                    title=t['title'],\n                    description=t['description'],\n                    created_at=datetime.fromisoformat(t['created_at']),\n                    completed=t['completed'],\n                    tags=t.get('tags', [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport json\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    data: Dict[str, Any]\n    completed: bool = False\n    result: Optional[Any] = None\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: List[Task] = []\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.id} - {task.name}\")\n        \n    def process_task(self, task: Task) -> Task:\n        logger.info(f\"Processing task: {task.id} - {task.name}\")\n        try:\n            # Simulate work\n            time.sleep(task.priority * 0.5)\n            task.result = {\n                \"processed_at\": time.time(),\n                \"input_size\": len(str(task.data)),\n                \"success\": True\n            }\n            task.completed = True\n            logger.info(f\"Completed task: {task.id}\")\n        except Exception as e:\n            logger.error(f\"Error processing task {task.id}: {str(e)}\")\n            task.result = {\"error\": str(e), \"success\": False}\n        return task\n    \n    def run(self) -> List[Task]:\n        if not self.tasks:\n            logger.warning(\"No tasks to process\")\n            return []\n            \n        # Sort tasks by priority (lower number = higher priority)\n        self.tasks.sort(key=lambda t: t.priority)\n        \n        with ThreadPoolExecutor(max_workers=self.",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self):\n        return {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n    \n    @classmethod\n    def from_dict(cls, data):\n        data[\"created_at\"] = datetime.fromisoformat(data[\"created_at\"])\n        return cls(**data)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def complete_task(self, index: int) -> Optional[Task]:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].completed = True\n            logger.info(f\"Completed task: {self.tasks[index].title}\")\n            self.save_tasks()\n            return self.tasks[index]\n        return None\n    \n    def list_tasks(self, show_completed: bool = False) -> List[Task]:\n        return [task for task in self.",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n        if isinstance(self.completed_at, str) and self.completed_at:\n            self.completed_at = datetime.fromisoformat(self.completed_at)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}\"\n        self.tasks[task_id] = Task(\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []\n        )\n        self.save_tasks()\n        return task_id\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_id not in self.tasks:\n            return False\n        self.tasks[task_id].completed = True\n        self.tasks[task_id].completed_at = datetime.now()\n        self.save_tasks()\n        return True\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in (task.tags or [])]\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            tasks_dict =",
    "import argparse\nimport csv\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n\n@dataclass\nclass Transaction:\n    date: str\n    description: str\n    amount: float\n    category: Optional[str] = None\n\n\nclass BudgetTracker:\n    def __init__(self, data_file: Path):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self.logger = logging.getLogger(__name__)\n        self._setup_logging()\n        \n    def _setup_logging(self):\n        logging.basicConfig(\n            level=logging.INFO,\n            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n        )\n    \n    def load_transactions(self):\n        if not self.data_file.exists():\n            self.logger.warning(f\"Data file {self.data_file} not found\")\n            return\n            \n        try:\n            with open(self.data_file, 'r', newline='') as csvfile:\n                reader = csv.DictReader(csvfile)\n                self.transactions = [\n                    Transaction(\n                        date=row['date'],\n                        description=row['description'],\n                        amount=float(row['amount']),\n                        category=row.get('category')\n                    )\n                    for row in reader\n                ]\n            self.logger.info(f\"Loaded {len(self.transactions)} transactions\")\n        except Exception as e:\n            self.logger.error(f\"Error loading transactions: {e}\")\n    \n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self.save_transactions()\n        \n    def save_transactions(self):\n        try:\n            with open(self.data_file, 'w', newline='') as csvfile:\n                fieldnames = ['date', 'description', 'amount', 'category']\n                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n                writer.writeheader()\n                for t",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\nimport time\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    completion_time: Optional[float] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"Task Manager initialized\")\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task ID {task_id} not found\")\n        return None\n    \n    def process_tasks(self) -> int:\n        if not self.tasks:\n            logger.info(\"No tasks to process\")\n            return 0\n            \n        # Sort tasks by priority (higher number = higher priority)\n        pending_tasks = [t for t in self.tasks if t.status == TaskStatus.PENDING]\n        pending_tasks.sort(key=lambda x: x.priority, reverse=True)\n        \n        processed_count = 0\n        for task in pending_tasks:\n            try:\n                logger.info(f\"Processing task: {",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    subtasks: List['Task'] = field(default_factory=list)\n    \n    def mark_completed(self, recursive: bool = False) -> None:\n        self.completed = True\n        if recursive:\n            for subtask in self.subtasks:\n                subtask.mark_completed(recursive=True)\n    \n    def add_subtask(self, task: 'Task') -> None:\n        self.subtasks.append(task)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists and will be overwritten\")\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            return True\n        logger.warning(f\"Task '{task_name}' not found\")\n        return False\n    \n    def get_incomplete_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f",
    "import logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskPriority(Enum):\n    LOW = auto()\n    MEDIUM = auto()\n    HIGH = auto()\n    CRITICAL = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: TaskPriority\n    completed: bool = False\n    dependencies: List[int] = field(default_factory=list)\n    estimated_hours: Optional[float] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"TaskManager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, task: Task) -> int:\n        task_id = self.next_id\n        self.tasks[task_id] = task\n        self.next_id += 1\n        self.logger.info(f\"Added task '{task.name}' with ID {task_id}\")\n        return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            self.logger.error(f\"Task ID {task_id} not found\")\n            return False\n        \n        task = self.tasks[task_id]\n        for dep_id in task.dependencies:\n            if dep_id in self.tasks and not self.tasks[dep_id].completed:\n                self.logger.warning(f\"Cannot complete task {task_id}: dependency {dep_id} not completed\")\n                return False\n        \n        task.completed = True\n        self.logger.info(f\"Completed task '{task.name",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    description: str\n    completed: bool = False\n    created_at: float = 0.0\n    completed_at: Optional[float] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.created_at == 0.0:\n            self.created_at = time.time()\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = time.time()\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at,\n            \"completed_at\": self.completed_at,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.i",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nimport os\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self):\n        return {\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> Optional[Task]:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].complete()\n            self.save_tasks()\n            return self.tasks[index]\n        return None\n    \n    def delete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            del self.tasks[index]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_all_tasks(self) -> List[Task]:\n        return self.tasks\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as",
    "import time\nfrom functools import wraps\nfrom typing import Callable, Dict, List, Optional, TypeVar, Any\n\nT = TypeVar('T')\n\n# Cache decorator with timeout\ndef cached(timeout_seconds: int = 300):\n    cache: Dict[str, Dict[str, Any]] = {}\n    \n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> T:\n            # Create a cache key from function name and arguments\n            key = f\"{func.__name__}:{str(args)}:{str(kwargs)}\"\n            \n            # Check if result is in cache and not expired\n            if key in cache:\n                entry = cache[key]\n                if time.time() - entry['timestamp'] < timeout_seconds:\n                    return entry['result']\n            \n            # Calculate the result and store in cache\n            result = func(*args, **kwargs)\n            cache[key] = {\n                'result': result,\n                'timestamp': time.time()\n            }\n            return result\n        return wrapper\n    return decorator\n\nclass DataProcessor:\n    def __init__(self, name: str):\n        self.name = name\n        self.data: List[int] = []\n    \n    @cached(timeout_seconds=10)\n    def process_data(self, data_input: List[int]) -> Dict[str, Any]:\n        \"\"\"Expensive operation that we want to cache\"\"\"\n        print(f\"Processing data with {self.name}...\")\n        time.sleep(1)  # Simulate work\n        \n        return {\n            'sum': sum(data_input),\n            'avg': sum(data_input) / len(data_input) if data_input else 0,\n            'max': max(data_input) if data_input else None,\n            'min': min(data_input) if data_input else None,\n            'processor': self.name\n        }\n\n# Usage example\nif __name__ == \"__main__\":\n    processor = DataProcessor(\"MainProcessor\")\n    \n    # First call - will be processed\n    data = [1,",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_data in tasks_data:\n                created_at = datetime.fromisoformat(task_data['created_at'])\n                completed_at = datetime.fromisoformat(task_data['completed_at']) if task_data['completed_at'] else None\n                \n                task = Task(\n                    id=task_data['id'],",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Task':\n        return cls(\n            id=data['id'],\n            title=data['title'],\n            description=data['description'],\n            created_at=datetime.fromisoformat(data['created_at']),\n            completed=data['completed'],\n            tags=data.get('tags', [])\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task.from_dict(task_data) for task_data in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= threshold]\n    \n    def load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(\"No task file found, starting with empty task list\")\n            return",
    "import argparse\nimport csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass SalesRecord:\n    date: str\n    product_id: str\n    product_name: str\n    quantity: int\n    unit_price: float\n    \n    @property\n    def total_price(self) -> float:\n        return self.quantity * self.unit_price\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_path: str):\n        self.data_path = data_path\n        self.records: List[SalesRecord] = []\n        \n    def load_data(self) -> None:\n        if not os.path.exists(self.data_path):\n            logger.error(f\"File not found: {self.data_path}\")\n            return\n            \n        try:\n            with open(self.data_path, 'r', newline='') as csvfile:\n                reader = csv.DictReader(csvfile)\n                for row in reader:\n                    record = SalesRecord(\n                        date=row['date'],\n                        product_id=row['product_id'],\n                        product_name=row['product_name'],\n                        quantity=int(row['quantity']),\n                        unit_price=float(row['unit_price'])\n                    )\n                    self.records.append(record)\n            logger.info(f\"Loaded {len(self.records)} sales records\")\n        except Exception as e:\n            logger.error(f\"Error loading data: {e}\")\n            \n    def get_total_sales(self) -> float:\n        return sum(record.total_price for record in self.records)\n        \n    def get_sales_by_product(self) -> Dict[str, float]:\n        result = {}\n        for record in self.records:\n            if record.product_id in result:\n                result[record.product_id] += recor",
    "import csv\nimport datetime\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass Transaction:\n    date: datetime.date\n    amount: float\n    category: str\n    description: Optional[str] = None\n\n\nclass ExpenseTracker:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n\n    def _load_transactions(self):\n        if not os.path.exists(self.file_path):\n            return\n\n        with open(self.file_path, 'r', newline='') as f:\n            reader = csv.reader(f)\n            next(reader, None)  # Skip header\n            for row in reader:\n                date = datetime.datetime.strptime(row[0], '%Y-%m-%d').date()\n                self.transactions.append(Transaction(\n                    date=date,\n                    amount=float(row[1]),\n                    category=row[2],\n                    description=row[3] if row[3] else None\n                ))\n\n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_transactions()\n\n    def _save_transactions(self):\n        with open(self.file_path, 'w', newline='') as f:\n            writer = csv.writer(f)\n            writer.writerow(['Date', 'Amount', 'Category', 'Description'])\n            for t in self.transactions:\n                writer.writerow([\n                    t.date.strftime('%Y-%m-%d'),\n                    t.amount,\n                    t.category,\n                    t.description or ''\n                ])\n\n    def get_total_by_category(self):\n        result = {}\n        for t in self.transactions:\n            if t.category not in result:\n                result[t.category] = 0\n            result[t.category] += t.amount\n        return result\n\n\nif __name__ == \"__main__\":\n    tracker = ExpenseTracker(\"expenses.csv\")",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    last_modified: float\n    \n    @property\n    def size_in_mb(self) -> float:\n        return self.size / (1024 * 1024)\n    \n    def __str__(self) -> str:\n        return f\"{self.path} ({self.size_in_mb:.2f} MB)\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        start_time = time.time()\n        \n        with ThreadPoolExecutor() as executor:\n            for root, _, files in os.walk(self.root_dir):\n                file_paths = [os.path.join(root, file) for file in files]\n                if self.extensions:\n                    file_paths = [f for f in file_paths if os.path.splitext(f)[1].lower() in self.extensions]\n                \n                executor.map(self._process_file, file_paths)\n        \n        logger.info(f\"Scan completed in {time.time() - start_time:.2f} seconds\")\n        return sorted(self.files, key=lambda x: x.size, reverse=True)\n    \n    def _process_file(self, file_path: str) -> None:\n        try:\n            # Simulate some processing time\n            time.sleep(",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting with empty task list\")\n            return\n        \n        try:\n            data = json.loads(self.storage_path.read_text())\n            for task_dict in data:\n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    completed=task_dict[\"completed\"],\n                    tags=task_dict.get(\"tags\", [])\n                )\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            data = [\n                {\n                    \"id\": task.id,\n                    \"title\": task.title,\n                    \"description\": task.description,\n                    \"completed\": task.completed,\n                    \"tags\": task.tags\n                }\n                for task in self.tasks.values()\n            ]\n            self.storage_path.write_text(json.dumps(data, indent",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n\n    def remove_task(self, task_name: str) -> Optional[Task]:\n        if task_name in self.tasks:\n            task = self.tasks.pop(task_name)\n            self.save_tasks()\n            return task\n        return None\n\n    def get_task(self, task_name: str) -> Optional[Task]:\n        return self.tasks.get(task_name)\n\n    def mark_completed(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def list_tasks(self, filter_completed: bool = None, tag: str = None) -> List[Task]:\n        tasks = list(self.tasks.values())\n        \n        if filter_completed is not None:\n            tasks = [t for t in tasks if t.completed == filter_completed]\n            \n        if tag:\n            tasks = [t for t in tasks if tag in t.tags]\n            \n        return sorted(tasks, key=lambda x: x.priority, reverse=True)\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            serialized = {\n                name: {\n                    **vars(task),\n                    '",
    "import logging\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def save_tasks(self):\n        with open(self.storage_path,",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, field\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 3  # 1=highest, 5=lowest\n    due_date: Optional[datetime] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags,\n            'priority': self.priority,\n            'due_date': self.due_date.isoformat() if self.due_date else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    title=task_dict['title'],\n                    description=task_dict['description'],\n                    created_at=datetime.fromisoformat(task_dict['created_at']),\n                    completed=task_dict['complete",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\nimport os\n\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id and not task.completed:\n                task.completed = True\n                task.completed_at = datetime.now()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        return None\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, default=str)\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, updating\")\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n    \n    def save(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({name: task.__dict__ for name, task in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Tasks saved to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")\n    \n    def load(self) -> bool:\n        if not self.storage_path.exists():\n            logger",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        completed=t[\"completed\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                    self.tasks[task_id] = Task(**task_data)\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            tasks_dict = {\n                task_id: {**task.__dict__, 'created_at': task.created_at.isoformat()}\n                for task_id, task in self.tasks.items()\n            }\n            with open(self.storage_path, 'w') as f:\n                json.",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Creating new task storage at {self.storage_path}\")\n            os.makedirs(os.path.dirname(self.storage_path), exist_ok=True)\n            with open(self.storage_path, 'w') as f:\n                json.dump([], f)\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                    complete",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\nimport time\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    completion_time: Optional[float] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskProcessor:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n    \n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        self.tasks[task_id] = Task(task_id, name, priority, dependencies=dependencies or [])\n        logger.info(f\"Added task '{name}' with ID {task_id}\")\n        return task_id\n    \n    def process_tasks(self):\n        eligible_tasks = self._get_eligible_tasks()\n        \n        if not eligible_tasks:\n            logger.info(\"No eligible tasks to process\")\n            return 0\n        \n        processed_count = 0\n        for task in eligible_tasks:\n            try:\n                logger.info(f\"Processing task {task.id}: {task.name}\")\n                task.status = TaskStatus.IN_PROGRESS\n                \n                # Simulate processing time based on priority\n                processing_time = random.uniform(0.1, 0.5) / task.priority\n                time.sleep(processing_time)\n                \n                # 10",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        completed=t[\"completed\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]) if t[\"created_at\"] else None,\n                        completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                    )\n                    for t in tasks_data\n                ]\n    \n    def save_tasks(self):\n        with open(self.storage_path, \"w\")",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    name: str\n    value: float\n    weight: float\n\nclass Inventory:\n    def __init__(self):\n        self.items: List[Item] = []\n    \n    def add_item(self, item: Item) -> None:\n        self.items.append(item)\n        logger.info(f\"Added {item.name} to inventory\")\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name == item_name:\n                removed = self.items.pop(i)\n                logger.info(f\"Removed {removed.name} from inventory\")\n                return removed\n        logger.warning(f\"Item {item_name} not found in inventory\")\n        return None\n    \n    def total_value(self) -> float:\n        return sum(item.value for item in self.items)\n    \n    def __str__(self) -> str:\n        return f\"Inventory with {len(self.items)} items, total value: {self.total_value():.2f}\"\n\nclass Character(ABC):\n    def __init__(self, name: str):\n        self.name = name\n        self.inventory = Inventory()\n        self.health = 100\n    \n    @abstractmethod\n    def special_ability(self) -> str:\n        pass\n    \n    def take_damage(self, amount: float) -> None:\n        self.health = max(0, self.health - amount)\n        logger.info(f\"{self.name} took {amount} damage, health now {self.health}\")\n\nclass Warrior(Character):\n    def special_ability(self) -> str:\n        return f\"{self.name} performs a powerful attack!\"",
    "import json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport os\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = None\n    completed_at: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat() if self.created_at else None,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    \n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]) if task_data[\"created_at\"] else None,\n                        completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) if task_data[\"completed_at\"] else None\n                    )\n                    self.tasks",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=t[\"id\"],\n                            title=t[\"title\"],\n                            description=t[\"description\"],\n                            completed=t[\"completed\"],\n                            created_at=datetime.fromisoformat(t[\"created_at\"]),\n                            tags=t.get(\"tags\", [])\n                        ) for t in tasks_data\n                    ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return self.due_date and not self.completed and datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self._save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].complete()\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t['id'],\n                    title=t['title'],\n                    description=t['description'],\n                    completed=t['completed'],\n                    created_at=datetime.fromisoformat(t['created_at']),\n                    completed_at=datetime.fromisoformat(t['completed_at']) if t['complete",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    \n    def to_dict(self):\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = []\n            for task_dict in tasks_data:\n                due_date = None\n                if task_dict.get(\"due_date\"):\n                    due_date = datetime.fromisoformat(task_dict[\"due_date\"])\n                \n                task = Task(\n                    id=task_dict[\"id\"],\n                    title=task_dict[\"title\"],\n                    description=task_dict[\"description\"],\n                    completed=task_dict[\"completed\"],\n                    due_date=due_date\n                )\n                self.tasks.append(task)\n            logger.info(f\"Loaded {len(self.tasks)}",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    \n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) if task_data[\"completed_at\"] else",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1-5 scale\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self._save_tasks()\n\n    def remove_task(self, task_name: str) -> Optional[Task]:\n        if task_name in self.tasks:\n            task = self.tasks.pop(task_name)\n            self._save_tasks()\n            return task\n        return None\n\n    def mark_completed(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            self._save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]\n\n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict[\"created_at\"] = datetime.fromisoformat(task_dict[\"created_",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass User:\n    user_id: str\n    username: str\n    email: str\n    created_at: datetime\n    last_login: Optional[datetime] = None\n    preferences: Dict[str, str] = field(default_factory=dict)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"user_id\": self.user_id,\n            \"username\": self.username,\n            \"email\": self.email,\n            \"created_at\": self.created_at.isoformat(),\n            \"last_login\": self.last_login.isoformat() if self.last_login else None,\n            \"preferences\": self.preferences\n        }\n\n\nclass UserManager:\n    def __init__(self, storage_path: str = \"users.json\"):\n        self.storage_path = storage_path\n        self.users: Dict[str, User] = {}\n        self.load_users()\n    \n    def load_users(self) -> None:\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for user_data in data:\n                    user = User(\n                        user_id=user_data[\"user_id\"],\n                        username=user_data[\"username\"],\n                        email=user_data[\"email\"],\n                        created_at=datetime.fromisoformat(user_data[\"created_at\"]),\n                        last_login=datetime.fromisoformat(user_data[\"last_login\"]) if user_data[\"last_login\"] else None,\n                        preferences=user_data[\"preferences\"]\n                    )\n                    self.users[user.user_id] = user\n        except (FileNotFoundError, json.JSONDecodeError):\n            self.users = {}\n    \n    def save_users(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([user.to_dict() for user",
    "import json\nimport logging\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                        completed=task_dict[\"completed\"],\n                        tags=task_dict[\"tags\"]\n                    )\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)}",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    \n    def is_overdue(self) -> bool:\n        return self.due_date and not self.completed and datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, default=str)\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        if not self.completed:\n            self.completed = True\n            self.completed_at = datetime.now().isoformat()\n            logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No tasks file found, starting with empty task list\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")",
    "import time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport threading\nimport queue\n\n\n@dataclass\nclass Task:\n    id: int\n    priority: int\n    description: str\n    completed: bool = False\n    created_at: float = time.time()\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.lock = threading.Lock()\n        self.task_queue = queue.PriorityQueue()\n        self._running = True\n        self.worker = threading.Thread(target=self._process_tasks)\n        self.worker.daemon = True\n        self.worker.start()\n\n    def add_task(self, description: str, priority: int = 1) -> Task:\n        with self.lock:\n            task_id = len(self.tasks) + 1\n            new_task = Task(id=task_id, priority=priority, description=description)\n            self.tasks.append(new_task)\n            self.task_queue.put((priority, task_id))\n            return new_task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        with self.lock:\n            for task in self.tasks:\n                if task.id == task_id:\n                    return task\n            return None\n\n    def mark_completed(self, task_id: int) -> bool:\n        with self.lock:\n            task = self.get_task(task_id)\n            if task:\n                task.completed = True\n                return True\n            return False\n\n    def _process_tasks(self):\n        while self._running:\n            try:\n                priority, task_id = self.task_queue.get(timeout=1)\n                task = self.get_task(task_id)\n                if task and not task.completed:\n                    # Simulate processing time\n                    time.sleep(random.uniform(0.1, 0.5))\n                    print(f\"Processed task {task_id}: {task.description}\")\n                self.task_queue.task_done()\n            except queue.Empty:",
    "import time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport threading\nimport queue\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    data: Optional[dict] = None\n    completed: bool = False\n\n\nclass TaskProcessor:\n    def __init__(self, num_workers: int = 3):\n        self.task_queue = queue.PriorityQueue()\n        self.results = {}\n        self.lock = threading.Lock()\n        self.workers = []\n        self.running = False\n        \n        for i in range(num_workers):\n            worker = threading.Thread(target=self._worker_loop, args=(i,))\n            self.workers.append(worker)\n    \n    def add_task(self, task: Task):\n        self.task_queue.put((-task.priority, task.id, task))\n    \n    def start(self):\n        self.running = True\n        for worker in self.workers:\n            worker.daemon = True\n            worker.start()\n    \n    def stop(self):\n        self.running = False\n        for worker in self.workers:\n            worker.join(timeout=1.0)\n    \n    def _worker_loop(self, worker_id: int):\n        while self.running:\n            try:\n                _, _, task = self.task_queue.get(timeout=1.0)\n                result = self._process_task(task, worker_id)\n                with self.lock:\n                    self.results[task.id] = result\n                self.task_queue.task_done()\n            except queue.Empty:\n                continue\n    \n    def _process_task(self, task: Task, worker_id: int) -> dict:\n        print(f\"Worker {worker_id} processing task {task.id}: {task.name}\")\n        # Simulate work\n        time.sleep(random.uniform(0.5, 2.0))\n        task.completed = True\n        return {\"task_id\": task.id, \"worker_id\": worker_id, \"success\": True}\n    \n    def",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        if not self.tasks:\n            return None\n        return max(self.tasks, key=lambda x: x.priority if not x.completed else -1)\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task and not task.completed:\n            task.complete()\n            return True\n        return False\n    \n    def get_stats(self) -> dict:\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks if task.completed)\n        return {\n            \"total\": total,\n            \"completed\": completed,\n            \"pending\": total - completed,\n            \"completion_rate\": complete",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    stock: int = 0\n    \n    def is_available(self) -> bool:\n        return self.stock > 0\n    \n    def __str__(self) -> str:\n        return f\"{self.name} (${self.price:.2f})\"\n\n\nclass Inventory:\n    def __init__(self):\n        self.products: Dict[int, Product] = {}\n        \n    def add_product(self, product: Product) -> None:\n        self.products[product.id] = product\n        logger.info(f\"Added product: {product.name}\")\n        \n    def get_product(self, product_id: int) -> Optional[Product]:\n        return self.products.get(product_id)\n    \n    def list_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products.values() if p.category == category]\n    \n    def update_stock(self, product_id: int, quantity: int) -> bool:\n        if product_id in self.products:\n            self.products[product_id].stock += quantity\n            logger.info(f\"Updated stock for {self.products[product_id].name}: {quantity}\")\n            return True\n        return False\n\n\nclass ShoppingCart:\n    def __init__(self, inventory: Inventory):\n        self.inventory = inventory\n        self.items: Dict[int, int] = {}  # product_id -> quantity\n        \n    def add_item(self, product_id: int, quantity: int = 1) -> bool:\n        product = self.inventory.get_product(product_id)\n        if product and product.stock >= quantity:\n            self.items[product_id] = self.items.get(product_id,",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([vars(task) for task in self.tasks.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom pathlib import Path\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    duration: int  # in seconds\n    dependencies: List[str] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks: Dict[str, Task] = {}\n        self.completed_tasks: List[str] = []\n        self.max_workers = max_workers\n        \n    def load_tasks(self, file_path: Path) -> None:\n        try:\n            with open(file_path, 'r') as f:\n                data = json.load(f)\n                for task_data in data:\n                    task = Task(\n                        id=task_data['id'],\n                        name=task_data['name'],\n                        duration=task_data['duration'],\n                        dependencies=task_data.get('dependencies', [])\n                    )\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {file_path}\")\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n            raise\n    \n    def process_task(self, task_id: str) -> bool:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n            \n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        time.sleep",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                for task_id, task_info in tasks_data.items():\n                    self.tasks[task_id] = Task(\n                        id=task_id,\n                        title=task_info['title'],\n                        description=task_info['description'],\n                        created_at=datetime.fromisoformat(task_info['created_at']),\n                        completed=task_info['completed'],\n                        tags=task_info['tags']\n                    )\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_dict in tasks_data:\n                    due_date = None\n                    if task_dict.get(\"due_date\"):\n                        due_date = datetime.fromisoformat(task_dict[\"due_date\"])\n                    \n                    self.tasks.append(Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\nclass ItemType(Enum):\n    WEAPON = auto()\n    ARMOR = auto()\n    POTION = auto()\n    TREASURE = auto()\n\n@dataclass\nclass Item:\n    name: str\n    value: int\n    item_type: ItemType\n    durability: Optional[int] = None\n    \n    def __post_init__(self):\n        if self.item_type in (ItemType.WEAPON, ItemType.ARMOR) and self.durability is None:\n            self.durability = 100\n    \n    def use(self) -> bool:\n        if self.item_type in (ItemType.WEAPON, ItemType.ARMOR):\n            if self.durability <= 0:\n                logger.warning(f\"{self.name} is broken and cannot be used!\")\n                return False\n            self.durability -= random.randint(1, 10)\n            logger.info(f\"{self.name} used. Durability: {self.durability}\")\n            return True\n        else:\n            logger.info(f\"{self.name} used\")\n            return True\n\nclass Inventory:\n    def __init__(self, capacity: int = 10):\n        self.items: List[Item] = []\n        self.capacity = capacity\n    \n    def add_item(self, item: Item) -> bool:\n        if len(self.items) >= self.capacity:\n            logger.warning(\"Inventory full!\")\n            return False\n        self.items.append(item)\n        logger.info(f\"Added {item.name} to inventory\")\n        return True\n    \n    def remove_item(self, item_index: int) -> Optional[Item]:\n        if 0 <= item_index < len(self.items):\n            item = self.items.pop(",
    "import csv\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport os\n\n\n@dataclass\nclass SalesRecord:\n    product_id: str\n    quantity: int\n    price: float\n    customer_id: str\n    date: str\n    \n    @property\n    def total(self) -> float:\n        return self.quantity * self.price\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.records: List[SalesRecord] = []\n        self._load_data()\n    \n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            return\n            \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.records.append(SalesRecord(\n                    product_id=row['product_id'],\n                    quantity=int(row['quantity']),\n                    price=float(row['price']),\n                    customer_id=row['customer_id'],\n                    date=row['date']\n                ))\n    \n    def save_data(self) -> None:\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['product_id', 'quantity', 'price', 'customer_id', 'date'])\n            writer.writeheader()\n            for record in self.records:\n                writer.writerow(vars(record))\n    \n    def add_record(self, record: SalesRecord) -> None:\n        self.records.append(record)\n    \n    def get_total_sales(self) -> float:\n        return sum(record.total for record in self.records)\n    \n    def get_sales_by_product(self) -> Dict[str, float]:\n        result = defaultdict(float)\n        for record in self.records:\n            result[record.product_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, assignee: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task with status {self.status}\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = assignee\n        logger.info(f\"Task {self.id} started by {assignee}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot fail task with status {self.status}\")\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)",
    "import logging\nimport threading\nimport time\nfrom typing import Dict, List, Optional, Tuple\nfrom dataclasses import dataclass\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self):\n        self._tasks: Dict[int, Task] = {}\n        self._lock = threading.Lock()\n        self._next_id = 1\n        \n    def add_task(self, name: str, priority: int = 1) -> int:\n        with self._lock:\n            task_id = self._next_id\n            self._tasks[task_id] = Task(task_id, name, priority)\n            self._next_id += 1\n            logger.info(f\"Added task {task_id}: '{name}' with priority {priority}\")\n            return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        with self._lock:\n            if task_id in self._tasks and not self._tasks[task_id].completed:\n                self._tasks[task_id].complete()\n                return True\n            return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        with self._lock:\n            return sorted(\n                [task for task in self._tasks.values() if not task.completed],\n                key=lambda t: (-t.priority, t.id)\n            )\n\ndef worker(manager: TaskManager, worker_id: int):\n    logger.info(f\"Worker {worker_id} started\")\n    while True:\n        pending = manager.get_pending_tasks()\n        if not pending:\n            logger.info(f\"Worker {",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    tags: Optional[List[str]] = None\n\nclass Inventory:\n    def __init__(self, data_file: Path):\n        self.data_file = data_file\n        self.products: Dict[int, Product] = {}\n        self._load_inventory()\n    \n    def _load_inventory(self) -> None:\n        if not self.data_file.exists():\n            logger.warning(f\"Inventory file {self.data_file} not found. Starting with empty inventory.\")\n            return\n        \n        try:\n            with open(self.data_file, 'r') as f:\n                data = json.load(f)\n                for item in data:\n                    self.products[item['id']] = Product(**item)\n            logger.info(f\"Loaded {len(self.products)} products from inventory\")\n        except json.JSONDecodeError:\n            logger.error(f\"Invalid JSON in {self.data_file}\")\n        except Exception as e:\n            logger.error(f\"Error loading inventory: {e}\")\n    \n    def save(self) -> None:\n        data = [vars(product) for product in self.products.values()]\n        with open(self.data_file, 'w') as f:\n            json.dump(data, f, indent=2)\n        logger.info(f\"Saved {len(data)} products to inventory\")\n    \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists\")\n            return\n        self.products[product",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        \n    def add_task(self, name: str, description: str, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        # Validate dependencies\n        if dependencies:\n            for dep_id in dependencies:\n                if dep_id not in self.tasks:\n                    raise ValueError(f\"Dependency task ID {dep_id} does not exist\")\n        \n        self.tasks[task_id] = Task(task_id, name, description, dependencies=dependencies or [])\n        logger.info(f\"Added task: {name} (ID: {task_id})\")\n        return task_id\n    \n    def update_status(self, task_id: int, status: TaskStatus) -> None:\n        if task_id not in self.tasks:\n            raise ValueError(f\"Task ID {task_id} does not exist\")\n        \n        self.tasks[task_id].status = status\n        logger.info(f\"Updated task {task_id} status to {status.name}\")\n    \n    def get_executable_tasks(self) -> List[Task]:\n        \"\"\"Return tasks that can be execute",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom pathlib import Path\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except IOError as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: Optional",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = None\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.tags is None:\n            self.tags = []\n            \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.title}\")\n        self._save_tasks()\n        \n    def get_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.completed == completed]\n    \n    def find_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n        \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, default=str)\n            \n    def _load_tasks(self) -> None:\n        if not os.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, worker: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task {self.id}: not in PENDING state\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = worker\n        logger.info(f\"Task {self.id} started by {worker}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task {self.id}: not in IN_PROGRESS state\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Task {task_id} added: {name}\")\n        return task",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: Optional[List[str]] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        try:\n            if self.storage_path.exists():\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task) for task in data]\n                    logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            else:\n                logger.info(\"No existing task file found, starting with empty list\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            self.tasks = []\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        next_id = max([task.id for task in self.tasks], default=0) + 1\n        new_task = Task(id=next_id, title=title, description=description, tags=tags or [])\n        self.tasks.appen",
    "import json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    categories: List[str] = field(default_factory=list)\n    in_stock: bool = True\n    \n    def apply_discount(self, percentage: float) -> float:\n        \"\"\"Apply discount to product price\"\"\"\n        if not 0 <= percentage <= 100:\n            raise ValueError(\"Discount percentage must be between 0 and 100\")\n        return self.price * (1 - percentage / 100)\n\nclass Inventory:\n    def __init__(self):\n        self.products: Dict[str, Product] = {}\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists, updating\")\n        self.products[product.id] = product\n        logger.info(f\"Added product: {product.name}\")\n    \n    def remove_product(self, product_id: str) -> Optional[Product]:\n        if product_id in self.products:\n            product = self.products.pop(product_id)\n            logger.info(f\"Removed product: {product.name}\")\n            return product\n        logger.warning(f\"Product with ID {product_id} not found\")\n        return None\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products.values() if category in p.categories]\n    \n    def save_to_file(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            json_data = {\n                'timestamp': datetime.now().isoformat(),\n                'products': {",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[str] = None\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n            \n        try:\n            data = json.loads(self.storage_path.read_text())\n            for task_data in data:\n                task = Task(**task_data)\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except json.JSONDecodeError:\n            logger.error(\"Failed to parse tasks file\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            \n    def save(self) -> None:\n        task_list = [vars(task) for task in self.tasks.values()]\n        self.storage_path.write_text(json.dumps(task_list, indent=2))\n        logger.info",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    last_modified: float\n    \n    @property\n    def is_large(self) -> bool:\n        return self.size > 1024 * 1024  # Greater than 1MB\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = root_dir\n        self.extensions = extensions or ['.txt', '.py', '.md', '.json']\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        \"\"\"Scan the directory and collect file information\"\"\"\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        self.files = []\n        \n        for root, _, files in os.walk(self.root_dir):\n            for file in files:\n                if any(file.endswith(ext) for ext in self.extensions):\n                    full_path = os.path.join(root, file)\n                    try:\n                        stats = os.stat(full_path)\n                        self.files.append(FileInfo(\n                            path=full_path,\n                            size=stats.st_size,\n                            last_modified=stats.st_mtime\n                        ))\n                    except OSError as e:\n                        logger.error(f\"Error accessing {full_path}: {e}\")\n        \n        return self.files\n    \n    def process_files(self, max_workers: int = 4) -> dict:\n        \"\"\"Process files using a thread pool\"\"\"\n        results = {'total': 0, 'large_files': 0,",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"□\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    @lru_cache(maxsize=32)\n    def get_priority_stats(self) -> dict:\n        if not self.tasks:\n            return {}\n        \n        priorities = [task.priority for task in self.tasks]\n        return {\n            \"min\": min(priorities),",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, filename: str = \"tasks.json\"):\n        self.filename = filename\n        self.tasks: List[Task] = []\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: datetime, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.results = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task ID {task_id} not found\")\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                logger.warning(f\"Dependency {dep_id} not completed for task {task_id}\")\n                return None\n                \n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Task {task.name} completed with priority {task.priority}\"\n        self.results[task_id] = result\n        return result\n        \n    def process_all_tasks(self) -> dict:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.results) < len(",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, name: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, description=description, tags=tags or [])\n        self.tasks[name] = task\n        logger.info(f\"Added new task: {name}\")\n        self._save_tasks()\n        return task\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def _load_tasks(self) -> None:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        \n    def to_dict(self) -> Dict:\n        return asdict(self)\n\n\nclass Inventory:\n    def __init__(self, data_file: str = \"inventory.json\"):\n        self.data_file = data_file\n        self.products: List[Product] = []\n        self._load_data()\n    \n    def _load_data(self) -> None:\n        if os.path.exists(self.data_file):\n            try:\n                with open(self.data_file, 'r') as f:\n                    data = json.load(f)\n                self.products = [Product(**item) for item in data]\n                logger.info(f\"Loaded {len(self.products)} products from {self.data_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading data: {e}\")\n        else:\n            logger.warning(f\"Data file {self.data_file} not found, starting with empty inventory\")\n    \n    def save_data(self) -> None:\n        with open(self.data_file, 'w') as f:\n            json.dump([p.to_dict() for p in self.products], f, indent=2)\n        logger.info(f\"Saved {len(self.products)} products to {self.data_file}\")\n    \n    @lru_cache(maxsize=32)",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self._save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.warning(f\"Storage file not found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_data in data:\n                task = Task(\n                    name=task",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: str\n    size: int\n    extension: str\n    is_binary: bool = False\n    \n@dataclass\nclass DirectoryAnalysis:\n    root_path: str\n    total_files: int = 0\n    total_size: int = 0\n    extension_counts: Dict[str, int] = field(default_factory=dict)\n    largest_files: List[FileStats] = field(default_factory=list)\n    \n    def add_file(self, file_stat: FileStats) -> None:\n        self.total_files += 1\n        self.total_size += file_stat.size\n        \n        ext = file_stat.extension or 'no_extension'\n        self.extension_counts[ext] = self.extension_counts.get(ext, 0) + 1\n        \n        # Keep track of top 5 largest files\n        self.largest_files.append(file_stat)\n        self.largest_files.sort(key=lambda x: x.size, reverse=True)\n        self.largest_files = self.largest_files[:5]\n        \ndef is_binary_file(file_path: str) -> bool:\n    try:\n        with open(file_path, 'r') as f:\n            f.read(1024)\n        return False\n    except UnicodeDecodeError:\n        return True\n\ndef analyze_file(file_path: str) -> Optional[FileStats]:\n    try:\n        path_obj = Path(file_path)\n        size = path_obj.stat().st_size\n        return FileStats(\n            path=file_path,\n            size=size,\n            extension=path_obj",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    extension: str\n    is_executable: bool\n\n\nclass FileAnalyzer:\n    def __init__(self, directory: Path, extensions: Optional[List[str]] = None):\n        self.directory = directory\n        self.extensions = extensions\n        self.logger = logging.getLogger(__name__)\n        self._setup_logging()\n\n    def _setup_logging(self) -> None:\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n\n    def analyze(self) -> List[FileStats]:\n        self.logger.info(f\"Analyzing directory: {self.directory}\")\n        \n        if not self.directory.exists():\n            self.logger.error(f\"Directory {self.directory} does not exist\")\n            return []\n        \n        results = []\n        for file_path in self.directory.glob(\"**/*\"):\n            if not file_path.is_file():\n                continue\n                \n            extension = file_path.suffix.lower()[1:] if file_path.suffix else \"\"\n            \n            if self.extensions and extension not in self.extensions:\n                continue\n                \n            stats = FileStats(\n                path=file_path,\n                size=file_path.stat().st_size,\n                extension=extension,\n                is_executable=file_path.stat().st_mode & 0o100 != 0\n            )\n            results.append(stats)\n            \n        self.logger.info(f\"Found {len(results)} matching files\")\n        return results\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Analyze files in a directory\")\n    parser.add_argument(\"directory\", help=\"Directory to analyze\")\n    parser.add_argument(\"--extensions\", nargs=\"+\", help=\"Filter",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.id}: {self.name} (priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom pathlib import Path\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, config_path: Path):\n        self.tasks: Dict[int, Task] = {}\n        self.config_path = config_path\n        \n    def load_tasks(self) -> None:\n        try:\n            with open(self.config_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_data in data.get('tasks', []):\n                task = Task(\n                    id=task_data['id'],\n                    name=task_data['name'],\n                    duration=task_data['duration'],\n                    dependencies=task_data.get('dependencies', [])\n                )\n                self.tasks[task.id] = task\n                \n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.config_path}\")\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n            raise\n    \n    def execute_task(self, task: Task) -> bool:\n        logger.info(f\"Starting task {task.id}: {task.name}\")\n        try:\n            # Simulate task execution\n            time.sleep(task.duration)\n            logger.info(f\"Completed task {task.id}: {task.name}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Task {task.id} failed: {e",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([{\n                'name': t.name,\n                'priority': t.priority,\n                'due_date': t.due_date.isoformat(),\n                'completed': t.completed,\n                'tags': t.tags\n            } for t in self.tasks], f)\n    \n    def load_",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task_data) for task_data in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, KeyError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks],",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass User:\n    id: int\n    name: str\n    email: str\n    posts: List[int] = None\n\n@dataclass\nclass Post:\n    id: int\n    title: str\n    body: str\n    user_id: int\n\nclass APIClient:\n    def __init__(self, base_url: str):\n        self.base_url = base_url\n        self.session = requests.Session()\n    \n    @lru_cache(maxsize=100)\n    def get_user(self, user_id: int) -> Optional[User]:\n        try:\n            response = self.session.get(f\"{self.base_url}/users/{user_id}\")\n            response.raise_for_status()\n            data = response.json()\n            return User(\n                id=data['id'],\n                name=data['name'],\n                email=data['email']\n            )\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching user {user_id}: {e}\")\n            return None\n    \n    def get_posts(self, user_id: int) -> List[Post]:\n        try:\n            response = self.session.get(f\"{self.base_url}/users/{user_id}/posts\")\n            response.raise_for_status()\n            return [\n                Post(\n                    id=item['id'],\n                    title=item['title'],\n                    body=item['body'],\n                    user_id=user_id\n                )\n                for item in response.json()\n            ]\n        except requests.RequestException as e:\n            logger.error(f\"Error fetching posts for user {user_id}: {e}\")\n            return []\n\ndef process_user(",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n    \n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        self.tasks[task_id] = Task(task_id, name, priority, dependencies=dependencies)\n        logger.info(f\"Added task {task_id}: '{name}' with priority {priority}\")\n        return task_id\n    \n    def get_next_task(self) -> Optional[Task]:\n        available_tasks = [\n            task for task in self.tasks.values()\n            if not task.completed and all(\n                self.tasks.get(dep_id, Task(-1, \"\", 0, True)).completed \n                for dep_id in (task.dependencies or [])\n            )\n        ]\n        \n        if not available_tasks:\n            return None\n            \n        return max(available_tasks, key=lambda t: t.priority)\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n            \n        task = self.tasks[task",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.mark_complete()\n            return True\n        logger.warning(f\"Task {task_id} not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\ndef main():\n    manager = TaskManager()\n    \n    #",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No existing tasks file found\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path\n        self._load_tasks()\n    \n    def add_task(self, name: str, priority: int, tags: Optional[List[str]] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, priority=priority, tags=tags or [])\n        self.tasks[name] = task\n        logger.info(f\"Added new task: {name} (priority: {priority})\")\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, name: str) -> None:\n        if name not in self.tasks:\n            raise ValueError(f\"Task '{name}' not found\")\n        \n        self.tasks[name].complete()\n        self._save_tasks()\n    \n    def get_pending_tasks(self, priority: Optional[int] = None) -> List[Task]:\n        tasks = [task for task in self.tasks.",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            logger.info(f\"",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    depends_on: Optional[int] = None\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def add_task(self, name: str, priority: int, depends_on: Optional[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        # Validate dependency\n        if depends_on and not any(t.id == depends_on for t in self.tasks):\n            logger.warning(f\"Dependency {depends_on} not found, ignoring\")\n            depends_on = None\n            \n        task = Task(id=task_id, name=name, priority=priority, depends_on=depends_on)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                logger.info(f\"Completed task: {task}\")\n                return True\n        logger.error(f\"Task {task_id} not found\")\n        return False\n    \n    def get_next_task(self) -> Optional[Task]:\n        available_tasks = [\n            t for t in self.tasks \n            if not t.completed and (\n                t.depends_on is None or \n                any(dt.id == t.depends_on and dt.completed for dt in self.tasks)\n            )\n        ]\n        \n        if not available_tasks:",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with id {task_id} not found\")\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        return False\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        if not self.tasks:\n            return None\n        return max(self.tasks, key=lambda x: x.priority if not x.completed else -1)\n    \n    def __str__(self):\n        return \"\\n\".join(str(task) for task in sorted(self.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"TaskManager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n    \n    def add_task(self, task: Task) -> bool:\n        if task.id in self.tasks:\n            self.logger.warning(f\"Task with ID {task.id} already exists\")\n            return False\n        \n        self.tasks[task.id] = task\n        self.logger.info(f\"Added task: {task.name}\")\n        return True\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_status(self, task_id: int, status: TaskStatus) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            self.logger.error(f\"Task with ID {task_id} not found\")\n            return False\n        \n        task.status = status\n        self.logger.info(f\"Updated task {task.name} status to {status.name}\")\n        return True\n    \n    def can_execute(",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport json\nfrom pathlib import Path\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    duration: float\n    dependencies: List[str] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> bool:\n        logger.info(f\"Starting task: {self.name}\")\n        try:\n            time.sleep(self.duration)  # Simulate work\n            logger.info(f\"Completed task: {self.name}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to execute task {self.name}: {e}\")\n            return False\n\n\nclass TaskManager:\n    def __init__(self, config_path: Optional[Path] = None):\n        self.tasks = {}\n        self.config_path = config_path or Path(\"tasks.json\")\n        \n    def load_tasks(self) -> bool:\n        if not self.config_path.exists():\n            logger.warning(f\"Config file not found: {self.config_path}\")\n            return False\n            \n        try:\n            with open(self.config_path, 'r') as f:\n                task_data = json.load(f)\n                \n            for task_info in task_data:\n                task = Task(\n                    name=task_info[\"name\"],\n                    duration=task_info[\"duration\"],\n                    dependencies=task_info.get(\"dependencies\", [])\n                )\n                self.tasks[task.name] = task\n            \n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.config_path}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Failed to loa",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f)\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                task_dicts = json.load(f)\n                \n            self",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_list = []\n                for task in self.tasks.values():\n                    task_dict = task.__dict__.copy()\n                    task_dict['created_at'] = task_dict['created_at'].isoformat()\n                    tasks_list.append(task_dict)\n                json.dump(tasks_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def execute(self) -> Dict:\n        logger.info(f\"Starting task {self.name} (ID: {self.id})\")\n        time.sleep(self.duration)  # Simulate work\n        result = {\n            \"task_id\": self.id,\n            \"task_name\": self.name,\n            \"duration\": self.duration,\n            \"status\": \"completed\"\n        }\n        logger.info(f\"Completed task {self.name} (ID: {self.id})\")\n        return result\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks: Dict[int, Task] = {}\n        self.results: Dict[int, Dict] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def can_execute(self, task_id: int) -> bool:\n        task = self.tasks[task_id]\n        return all(dep_id in self.results for dep_id in task.dependencies)\n    \n    def execute_all(self) -> Dict[int, Dict]:\n        pending_tasks = set(self.tasks.keys())\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while pending_tasks:\n                executable_tasks = [tid for tid in pending_tasks if self.can_execute(tid)]",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return asdict(self)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks[task_id] = task\n        self.save_tasks()\n        logger.info(f\"Added task: {title} (ID: {task_id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        if task_id not in self.tasks:\n            return None\n        \n        task = self.tasks[task_id]\n        for key, value in kwargs.items():\n            if hasattr(task",
    "import csv\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass ExpenseTracker:\n    def __init__(self, filename: str = \"expenses.csv\"):\n        self.filename = filename\n        self.categories = [\"food\", \"transportation\", \"housing\", \"entertainment\", \"other\"]\n        self._ensure_file_exists()\n\n    def _ensure_file_exists(self) -> None:\n        if not os.path.exists(self.filename):\n            with open(self.filename, \"w\", newline=\"\") as file:\n                writer = csv.writer(file)\n                writer.writerow([\"date\", \"amount\", \"category\", \"description\"])\n\n    def add_expense(self, amount: float, category: str, description: str) -> bool:\n        if category not in self.categories:\n            print(f\"Invalid category. Choose from: {', '.join(self.categories)}\")\n            return False\n        \n        if amount <= 0:\n            print(\"Amount must be positive\")\n            return False\n            \n        date = datetime.now().strftime(\"%Y-%m-%d\")\n        with open(self.filename, \"a\", newline=\"\") as file:\n            writer = csv.writer(file)\n            writer.writerow([date, amount, category, description])\n        return True\n\n    def get_expenses(self, category: Optional[str] = None) -> List[Dict]:\n        expenses = []\n        with open(self.filename, \"r\", newline=\"\") as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                if category is None or row[\"category\"] == category:\n                    row[\"amount\"] = float(row[\"amount\"])\n                    expenses.append(row)\n        return expenses\n\n    def get_summary(self) -> Tuple[float, Dict[str, float]]:\n        category_totals = {cat: 0.0 for cat in self.categories}\n        total = 0.0\n        \n        for expense in self.get_expenses():\n            amount = expense[\"amount\"]\n            category = expense[\"category\"]\n            total += amount\n            category_tot",
    "import csv\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Tuple\n\n\nclass Transaction:\n    def __init__(self, date: datetime, amount: float, category: str, description: str):\n        self.date = date\n        self.amount = amount\n        self.category = category\n        self.description = description\n\n    def __str__(self) -> str:\n        return f\"{self.date.strftime('%Y-%m-%d')} | ${self.amount:.2f} | {self.category} | {self.description}\"\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str = \"expenses.csv\"):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n\n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, \"r\", newline=\"\") as f:\n            reader = csv.reader(f)\n            next(reader)  # Skip header\n            for row in reader:\n                date = datetime.strptime(row[0], \"%Y-%m-%d\")\n                amount = float(row[1])\n                category = row[2]\n                description = row[3]\n                self.transactions.append(Transaction(date, amount, category, description))\n\n    def add_transaction(self, amount: float, category: str, description: str, \n                       date: Optional[datetime] = None) -> None:\n        if date is None:\n            date = datetime.now()\n        \n        transaction = Transaction(date, amount, category, description)\n        self.transactions.append(transaction)\n        self._save_data()\n\n    def _save_data(self) -> None:\n        with open(self.data_file, \"w\", newline=\"\") as f:\n            writer = csv.writer(f)\n            writer.writerow([\"Date\", \"Amount\", \"Category\", \"Description\"])\n            for t in self.transactions:\n                writer.writerow([t.date.strftime(\"%Y-%m-%",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_file}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_file, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_file}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or [],\n            'priority': self.priority\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n            \n            self.tasks = [\n                Task(\n                    id=t['id'],\n                    title=t['title'],\n                    description=t['description'],\n                    created_at=datetime.fromisoformat(t['created_at']),\n                    completed=t['completed'],\n                    tags=t['tags'],\n                    priority=t['priority']\n                )\n                for t in tasks_data\n            ]\n            logger.info(",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(\"No task file found, starting with",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport time\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.logger = logging.getLogger(__name__)\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        self.logger.info(f\"Added task: {task.name} (Priority: {task.priority})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            self.logger.info(f\"Completed task: {task.name}\")\n            return task\n        self.logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n\ndef simulate_task_processing(manager: TaskManager):\n    for _ in range(3):\n        pending = manager.get_pending_tasks()\n        if not pending:\n            break\n        \n        task = random.choice(pending)\n        print(f\"Processing task:",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport argparse\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool\n    created_at: datetime\n    completed_at: Optional[datetime] = None\n    \n    def mark_completed(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            self.tasks = []\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    completed=t[\"completed\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    completed_at=datetime.fromisoformat(t[\"completed_at\"]) if t[\"completed_at\"] else None\n                )\n                for t in tasks_data\n            ]\n        except (json.JSONDecodeError, FileNotFoundError):\n            self.tasks = []\n    \n    def save(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task",
    "import os\nimport csv\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    description: str\n    amount: float\n    category: str\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n\n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r', newline='') as file:\n            reader = csv.DictReader(file)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    description=row['description'],\n                    amount=float(row['amount']),\n                    category=row['category']\n                ))\n\n    def add_transaction(self, date: datetime, description: str, amount: float, category: str):\n        transaction = Transaction(date, description, amount, category)\n        self.transactions.append(transaction)\n        self._save_data()\n        return transaction\n\n    def _save_data(self):\n        with open(self.data_file, 'w', newline='') as file:\n            writer = csv.DictWriter(file, fieldnames=['date', 'description', 'amount', 'category'])\n            writer.writeheader()\n            for transaction in self.transactions:\n                writer.writerow({\n                    'date': transaction.date.strftime('%Y-%m-%d'),\n                    'description': transaction.description,\n                    'amount': transaction.amount,\n                    'category': transaction.category\n                })\n\n    def get_total_by_category(self) -> Dict[str, float]:\n        totals = {}\n        for transaction in self.transactions:\n            if transaction.category not in totals:\n                totals[transaction.category] = 0\n            totals[transaction.category] +=",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        due = f\", due: {self.due_date.strftime('%Y-%m-%d')}\" if self.due_date else \"\"\n        return f\"[{status}] {self.name} (priority: {self.priority}{due})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_completed_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.completed]\n    \n    def get_high_priority_tasks(self, threshold: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n    \n    def save_to_file(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            for task in self.tasks:\n                f.write(f\"{str(task)}\\n\")\n        logger.info(f\"Tasks saved to {filename}\")\n\n\nif __name",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n        if isinstance(self.completed_at, str) and self.completed_at:\n            self.completed_at = datetime.fromisoformat(self.completed_at)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                for task_dict in tasks_data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n\n    def save_tasks(self) -> None:\n        tasks_data = [asdict(task) for task in self.tasks.values()]\n        with open(self.storage_path, \"w\") as f:\n            json.dump(tasks_data, f, default=str, indent=2)\n\n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []\n        )\n        self.tasks",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Result of {task.name}\"\n        task.result = result\n        logger.info(f\"Completed task {task.name} (ID: {task.id})\")\n        return result\n        \n    def execute_all(self) -> Dict[int, Any]:\n        results = {}\n        processed = set()\n        \n        while len(processed) < len(self.tasks):\n            ready_tasks = [\n                task_id for task_id, task in self.tasks.items()\n                if task_id not in processed and all(dep in processed for dep in task.dependencies)\n            ]\n            \n            if not ready_tasks:\n                raise ValueError(\"Circular dependency detected\")\n                \n            with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n                futures = {executor.submit(self.process",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        data = data.copy()\n        data['created_at'] = datetime.fromisoformat(data['created_at'])\n        return cls(**data)\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                for task_data in tasks_data:\n                    task = Task.from_dict(task_data)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        logger.info(f\"Assigning task {self.id} to {person}\")\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        logger.info(f\"Completing task {self.id}\")\n        self.status = TaskStatus.COMPLETED\n    \n    def fail(self) -> None:\n        logger.info(f\"Task {self.id} failed\")\n        self.status = TaskStatus.FAILED\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def create_task(self, name: str, description: str) -> Task:\n        task = Task(id=self.next_id, name=name, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Created task: {task.name}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    extension: str\n    is_hidden: bool\n\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, ignore_hidden: bool = True):\n        self.root_dir = Path(root_dir)\n        self.ignore_hidden = ignore_hidden\n        self.logger = logging.getLogger(__name__)\n        \n    def collect_files(self) -> List[FileStats]:\n        if not self.root_dir.exists():\n            self.logger.error(f\"Directory {self.root_dir} does not exist\")\n            return []\n        \n        result = []\n        for file_path in self.root_dir.glob(\"**/*\"):\n            if file_path.is_file():\n                is_hidden = file_path.name.startswith(\".\")\n                if self.ignore_hidden and is_hidden:\n                    continue\n                    \n                result.append(FileStats(\n                    path=file_path,\n                    size=file_path.stat().st_size,\n                    extension=file_path.suffix.lower(),\n                    is_hidden=is_hidden\n                ))\n        return result\n    \n    def get_extension_stats(self, files: List[FileStats]) -> dict:\n        stats = {}\n        for file in files:\n            ext = file.extension or \"(no extension)\"\n            if ext not in stats:\n                stats[ext] = {\"count\": 0, \"total_size\": 0}\n            stats[ext][\"count\"] += 1\n            stats[ext][\"total_size\"] += file.size\n        return stats\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Analyze files in a directory\")\n    parser.add_argument(\"directory\", help=\"Directory to analyze\")\n    parser.add_argument(\"--include-hidden\", action=\"store_true\", help=\"Include hidden files\")\n    args = parser.parse_args()\n    \n    logging.basicConfig(level=logging.INFO,",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            return False\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        return True\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            return False\n        \n        self.tasks.remove(task)\n        self.save_tasks()\n        return True\n\n    def get_tasks_by_priority(self, min_priority: int = 1) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def _generate_id(self) -> int:\n        existing_ids = {task.id for task in self.tasks}\n        new_id =",
    "import argparse\nimport json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    subtasks: List['Task'] = None\n\n    def __post_init__(self):\n        if self.subtasks is None:\n            self.subtasks = []\n\n    def add_subtask(self, task: 'Task') -> None:\n        self.subtasks.append(task)\n\n    def mark_completed(self, recursive: bool = True) -> None:\n        self.completed = True\n        if recursive and self.subtasks:\n            for subtask in self.subtasks:\n                subtask.mark_completed(recursive=True)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[str, Task] = {}\n        self.storage_path = storage_path or Path.home() / \".tasks.json\"\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n\n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            return True\n        return False\n\n    def get_task(self, task_name: str) -> Optional[Task]:\n        return self.tasks.get(task_name)\n\n    def get_all_tasks(self) -> List[Task]:\n        return sorted(self.tasks.values(), key=lambda t: t.priority, reverse=True)\n\n    def save(self) -> None:\n        data = {name: {\"priority\": task.priority, \"completed\": task.completed,\n                       \"subtasks\": [s.__dict__ for s in task.subtasks]}\n                for name, task in self.tasks.items()}\n        with open(self.storage_path, 'w') as f:\n            json.dump(data, f, indent=2)\n\n    def load(self) -> bool:\n        if not self.storage_path.exists():",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = None\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> int:\n        self.tasks.append(task)\n        self.save_tasks()\n        return len(self.tasks) - 1  # Return the index of the new task\n    \n    def complete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].completed = True\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks \n                if task.priority >= min_priority and not task.completed]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            tasks_dict = [\n                {**asdict(task), 'created_at': task.created_at.isoformat()}\n                for task in self.tasks\n            ]\n            json.dump(tasks_dict, f, indent=2)\n    \n    def load_tasks(self):",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    notes: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = self._load_tasks()\n    \n    def _load_tasks(self) -> List[Task]:\n        if not os.path.exists(self.storage_path):\n            return []\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            return [Task(\n                name=t['name'],\n                priority=t['priority'],\n                due_date=datetime.fromisoformat(t['due_date']),\n                completed=t['completed'],\n                tags=t.get('tags', []),\n                notes=t.get('notes')\n            ) for t in tasks_data]\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            return []\n    \n    def _save_tasks(self) -> None:\n        tasks_data = [asdict(task) for task in self.tasks]\n        for task_dict in tasks_data:\n            task_dict['due_",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1-5, where 5 is highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n\n    def _save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            serializable_tasks = {}\n            for task_id, task in self.tasks.items():\n                task_dict = task.__dict__.copy()\n                task_dict[\"created_at\"] = task.created_at.isoformat()\n                serializable_tasks[task_id] = task_dict\n            json.dump(serializable_tasks, f, indent=2)\n\n    def add_task(self, title: str, description: str, tags: List[str] = None, priority: int = 1) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}\"\n        self.tasks[task_id] = Task(\n            title=",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=task[\"id\"],\n                        title=task[\"title\"],\n                        description=task[\"description\"],\n                        completed=task[\"completed\"],\n                        created_at=datetime.fromisoformat(task[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task[\"completed_at\"]) if task[\"completed_at\"] else None\n                    )\n                    for task in tasks_data\n                ]\n                logger",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        if not self.due_date or self.completed:\n            return False\n        return datetime.now() > self.due_date\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n            self.save_tasks()\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in (task.tags or [])]\n\n    def load_tasks(self) -> None:\n        if not os.path.exists(self",
    "import logging\nfrom dataclasses import dataclass, field\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int = 1\n    dependencies: List[int] = field(default_factory=list)\n    completed: bool = False\n    \n    def execute(self) -> bool:\n        logger.info(f\"Starting task {self.name} (ID: {self.id})\")\n        time.sleep(self.duration)  # Simulate work\n        success = random.random() > 0.2  # 80% success rate\n        self.completed = success\n        status = \"completed\" if success else \"failed\"\n        logger.info(f\"Task {self.name} (ID: {self.id}) {status}\")\n        return success\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks: List[Task] = []\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        \n    def can_execute(self, task: Task) -> bool:\n        return all(any(t.id == dep_id and t.completed for t in self.tasks) \n                  for dep_id in task.dependencies)\n    \n    def run(self) -> List[Task]:\n        pending_tasks = sorted(self.tasks, key=lambda t: t.priority, reverse=True)\n        completed_tasks = []\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while pending_tasks:\n                executable_tasks = [t for t in pending_tasks if self.can_execute(t)]\n                if not executable_tasks:\n                    logger.warning",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [Task(**task_data) for task_data in data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n            return False\n    \n    def add_",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    extension: str\n    is_hidden: bool\n\nclass FileAnalyzer:\n    def __init__(self, directory: Path, recursive: bool = False):\n        self.directory = directory\n        self.recursive = recursive\n        \n    def get_files(self) -> List[Path]:\n        if not self.directory.exists():\n            logger.error(f\"Directory {self.directory} does not exist\")\n            return []\n            \n        pattern = \"**/*\" if self.recursive else \"*\"\n        return [f for f in self.directory.glob(pattern) if f.is_file()]\n        \n    def analyze_files(self) -> List[FileStats]:\n        files = self.get_files()\n        results = []\n        \n        for file_path in files:\n            try:\n                stats = FileStats(\n                    path=file_path,\n                    size=file_path.stat().st_size,\n                    extension=file_path.suffix.lower(),\n                    is_hidden=file_path.name.startswith(\".\")\n                )\n                results.append(stats)\n            except Exception as e:\n                logger.warning(f\"Error analyzing {file_path}: {e}\")\n                \n        return results\n        \n    def get_summary(self) -> dict:\n        files = self.analyze_files()\n        \n        if not files:\n            return {\"total_files\": 0}\n            \n        extensions = {}\n        for file in files:\n            ext = file.extension or \"no_extension\"\n            if ext not in extensions:\n                extensions[ext] = 0\n            extensions[ext] += 1\n            \n        return {\n            \"total_files\": len(files),\n            \"total",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_file):\n            logger.info(f\"Storage file {self.storage_file} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_file, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_data in tasks_data:\n                task = Task(\n                    id=task_data[\"id\"],\n                    title=task_data[\"title\"],\n                    description=task_data[\"description\"],\n                    created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                    completed=task_data[\"completed\"],",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport requests\nfrom concurrent.futures import ThreadPoolExecutor\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    title: str\n    author: str\n    year: int\n    isbn: str\n    rating: Optional[float] = None\n    \n    def __str__(self) -> str:\n        return f\"{self.title} by {self.author} ({self.year})\"\n    \n    def to_dict(self) -> dict:\n        return {\n            \"title\": self.title,\n            \"author\": self.author,\n            \"year\": self.year,\n            \"isbn\": self.isbn,\n            \"rating\": self.rating\n        }\n\nclass BookRepository:\n    def __init__(self, filename: str = \"books.json\"):\n        self.filename = filename\n        self.books: List[Book] = []\n        self._load_books()\n    \n    def _load_books(self) -> None:\n        try:\n            with open(self.filename, 'r') as f:\n                books_data = json.load(f)\n                self.books = [Book(**book) for book in books_data]\n        except FileNotFoundError:\n            logger.warning(f\"File {self.filename} not found. Starting with empty repository.\")\n            self.books = []\n    \n    def save_books(self) -> None:\n        with open(self.filename, 'w') as f:\n            json.dump([book.to_dict() for book in self.books], f, indent=2)\n    \n    def add_book(self, book: Book) -> None:\n        self.books.append(book)\n        self.save_books()\n    \n    def find_by_author(self, author: str) -> List[Book]:\n        return [book for book in self.books if author.lower() in book.author.lower()]\n    \n    def get_ratings(self)",
    "import argparse\nimport json\nimport os\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n            except (json.JSONDecodeError, IOError) as e:\n                print(f\"Error loading tasks: {e}\")\n        \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([vars(task) for task in self.tasks.values()], f, indent=2)\n        except IOError as e:\n            print(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks(self, completed:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass ProductCategory(Enum):\n    ELECTRONICS = auto()\n    CLOTHING = auto()\n    BOOKS = auto()\n    FOOD = auto()\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: ProductCategory\n    stock: int = 0\n    \n    def is_available(self) -> bool:\n        return self.stock > 0\n\nclass Inventory:\n    def __init__(self):\n        self._products: Dict[int, Product] = {}\n        \n    def add_product(self, product: Product) -> None:\n        if product.id in self._products:\n            logger.warning(f\"Product {product.id} already exists, updating instead\")\n        self._products[product.id] = product\n        logger.info(f\"Added/updated product {product.name} to inventory\")\n    \n    def get_product(self, product_id: int) -> Optional[Product]:\n        return self._products.get(product_id)\n    \n    def list_by_category(self, category: ProductCategory) -> List[Product]:\n        return [p for p in self._products.values() if p.category == category]\n    \n    def update_stock(self, product_id: int, quantity: int) -> bool:\n        product = self.get_product(product_id)\n        if not product:\n            logger.error(f\"Product {product_id} not found\")\n            return False\n        \n        product.stock += quantity\n        logger.info(f\"Updated stock for {product.name}: {product.stock}\")\n        return True\n\ndef main():\n    inventory = Inventory()\n    \n    # Create some products\n    products = [\n        Product(1, \"Laptop\", 999.99, ProductCategory",
    "import os\nimport json\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t[\"id\"],\n                        title=t[\"title\"],\n                        description=t[\"description\"],\n                        created_at=datetime.fromisoformat(t[\"created_at\"]),\n                        completed=t[\"completed\"],\n                        tags=t.get(\"tags\", [])\n                    )\n                    for t in tasks_data\n                ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def can_start(self, completed_tasks: List[int]) -> bool:\n        return all(dep in completed_tasks for dep in self.dependencies)\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.task_id_counter = 0\n        \n    def add_task(self, name: str, description: str, dependencies: List[int] = None) -> int:\n        task_id = self.task_id_counter\n        self.tasks[task_id] = Task(name, description, dependencies=dependencies or [])\n        self.task_id_counter += 1\n        logger.info(f\"Added task '{name}' with ID {task_id}\")\n        return task_id\n    \n    def update_status(self, task_id: int, new_status: TaskStatus) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        task = self.tasks[task_id]\n        if new_status == TaskStatus.IN_PROGRESS:\n            completed_tasks = [tid for tid, task in self.tasks.items() \n                              if task.status == TaskStatus.DONE]\n            if not task.can_start(completed_tasks):\n                logger.warning(",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'due_date': self.due_date.isoformat() if self.due_date else None,\n            'completed': self.completed,\n            'tags': self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = 'tasks.json'):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_file):\n            logger.info(f\"Storage file {self.storage_file} not found, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_file, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                due_date = None\n                if task_dict.get('due_date'):\n                    due_date = datetime.fromisoformat(task_dict['due_date'])\n                \n                task = Task(\n                    id=task_dict['id'],\n                    title=task_dict['title'],\n                    description=task_dict['",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    \n    def apply_discount(self, percentage: float) -> float:\n        \"\"\"Return price after discount\"\"\"\n        return self.price * (1 - percentage / 100)\n\nclass Inventory:\n    def __init__(self):\n        self.products: List[Product] = []\n        \n    def add_product(self, product: Product) -> None:\n        self.products.append(product)\n        logger.info(f\"Added product: {product.name}\")\n        \n    def get_product_by_id(self, product_id: int) -> Optional[Product]:\n        for product in self.products:\n            if product.id == product_id:\n                return product\n        return None\n    \n    def get_products_by_category(self, category: str) -> List[Product]:\n        return [p for p in self.products if p.category == category]\n    \n    @lru_cache(maxsize=128)\n    def get_average_price(self, category: str) -> float:\n        products = self.get_products_by_category(category)\n        if not products:\n            return 0.0\n        return sum(p.price for p in products) / len(products)\n\ndef main():\n    inventory = Inventory()\n    \n    # Add sample products\n    categories = [\"Electronics\", \"Books\", \"Clothing\", \"Food\"]\n    for i in range(1, 21):\n        product = Product(\n            id=i,\n            name=f\"Product {i}\",\n            price=random.uniform(10.0, 100.0),\n            category=random.choice(categories),",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    modified: float\n    \n    @property\n    def size_kb(self) -> float:\n        return self.size / 1024\n    \n    def __str__(self) -> str:\n        return f\"{self.path} ({self.size_kb:.2f} KB)\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self, max_workers: int = 4) -> List[FileInfo]:\n        start_time = time.time()\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        \n        all_files = []\n        for root, _, files in os.walk(self.root_dir):\n            for file in files:\n                if self.extensions is None or any(file.endswith(ext) for ext in self.extensions):\n                    all_files.append(os.path.join(root, file))\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            self.files = list(executor.map(self._get_file_info, all_files))\n        \n        elapsed = time.time() - start_time\n        logger.info(f\"Scan completed in {elapsed:.2f} seconds, found {len(self.files)} files\")\n        return self.files\n    \n    def _get_file_info(self, file_path: str) -> FileInfo:\n        # Simulate some work",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime, timedelta\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                \n            for task_id, task_data in data.items():\n                task_data['due_date'] = datetime.fromisoformat(task_data['due_date'])\n                self.tasks[task_id] = Task(**task_data)\n            \n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            data = {}\n            for task_id, task in self.tasks.items():\n                task_dict = task.__dict__.copy()\n                task_dict['",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger('task_manager')\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1-5 scale\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None, priority: int = 1) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            tags=tags or [],\n            priority=priority\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Created task: {task.title} (ID: {task.id})\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Completed task ID: {task_id}\")\n            self.save_tasks()\n            return self.tasks[task_id]\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending = self.get_pending_tasks()\n        return max(pending, key=lambda x: x.priority) if pending else None\n\n@lru_cache(maxsize=100)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    for i in range(10):\n        priority = random.randint(1, 10)\n        manager.add_task(Task(id=i, name=f\"Task {i}\", priority=priority))\n    \n    # Process tasks in priority order\n    while True:\n        task = manager.get_highest_priority_task()",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as complete\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n    \n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        \n        task = Task(id=task_id, name=name, priority=priority, dependencies=dependencies)\n        self.tasks[task_id] = task\n        \n        logger.info(f\"Added task {task_id}: '{name}' with priority {priority}\")\n        return task_id\n    \n    def get_available_tasks(self) -> List[Task]:\n        available = []\n        for task in self.tasks.values():\n            if not task.completed and all(\n                self.tasks.get(dep_id, Task(0, \"\", 0, True)).completed \n                for dep_id in task.dependencies\n            ):\n                available.append(task)\n        \n        return sorted(available, key=lambda t: t.priority, reverse=True)\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        task = self.tasks[",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(**task_dict)\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n            return",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    for task_id, task_dict in tasks_data.items():\n                        self.tasks[int(task_id)] = Task(**task_dict)\n            except (json.JSONDecodeError, FileNotFoundError):\n                self.tasks = {}\n    \n    def _save_tasks(self):\n        tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n        with open(self.storage_path, \"w\") as f:\n            json.dump(tasks_dict, f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, task_id:",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_data in tasks_data:\n                    completed_at = None\n                    if task_data.get(\"completed_at\"):\n                        completed_at = datetime.fromisoformat(task_data[\"completed_at\"])\n                    \n                    self.tasks.append(Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    priority: int = 1  # 1-5 scale, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.csv\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            return\n\n        with open(self.storage_path, \"r\", newline=\"\") as file:\n            reader = csv.reader(file)\n            next(reader)  # Skip header\n            for row in reader:\n                self.tasks.append(\n                    Task(\n                        id=int(row[0]),\n                        title=row[1],\n                        description=row[2],\n                        due_date=datetime.fromisoformat(row[3]),\n                        completed=row[4].lower() == \"true\",\n                        priority=int(row[5]),\n                    )\n                )\n\n    def save_tasks(self):\n        with open(self.storage_path, \"w\", newline=\"\") as file:\n            writer = csv.writer(file)\n            writer.writerow([\"id\", \"title\", \"description\", \"due_date\", \"completed\", \"priority\"])\n            for task in self.tasks:\n                writer.writerow([\n                    task.id,\n                    task.title,\n                    task.description,\n                    task.due_date.isoformat(),\n                    task.completed,\n                    task.priority\n                ])\n\n    def add_task(self, title: str, description: str, due_date: datetime, priority: int = 1) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        task = Task(i",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Dict] = self._load_tasks()\n    \n    def _load_tasks(self) -> List[Dict]:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                return []\n        return []\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_file, 'w') as f:\n            json.dump(self.tasks, f, indent=2)\n    \n    def add_task(self, title: str, description: str, due_date: Optional[str] = None,\n                 priority: int = 1) -> int:\n        task_id = len(self.tasks) + 1\n        task = {\n            \"id\": task_id,\n            \"title\": title,\n            \"description\": description,\n            \"created_at\": datetime.now().isoformat(),\n            \"due_date\": due_date,\n            \"priority\": priority,\n            \"completed\": False\n        }\n        self.tasks.append(task)\n        self._save_tasks()\n        return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task[\"id\"] == task_id:\n                task[\"completed\"] = True\n                task[\"completed_at\"] = datetime.now().isoformat()\n                self._save_tasks()\n                return True\n        return False\n    \n    def get_task(self, task_id: int) -> Optional[Dict]:\n        for task in self.tasks:\n            if task[\"id\"] == task_id:\n                return task\n        return None\n    \n    def get_pending_tasks(self) -> List[Dict]:",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport argparse\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    subtasks: List[\"Task\"] = field(default_factory=list)\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, updating\")\n        self.tasks[task.name] = task\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.error(f\"Task '{task_name}' not found\")\n            return False\n        self.tasks[task_name].completed = True\n        self.save_tasks()\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found, starting empty\")\n            return\n        \n        try:\n            data = json.loads(self.storage_path.read_text())\n            for task_data in data:\n                task = Task(\n                    name=task_data[\"name\"],\n                    priority=task_data[\"priority\"],",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, creating new task store\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = {k: Task(**v) for k, v in data.items()}\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({k: asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int = 1\n    completed: bool = False\n    \n    def execute(self) -> bool:\n        logger.info(f\"Executing task {self.id}: {self.name} (priority: {self.priority})\")\n        time.sleep(self.duration)  # Simulate work\n        self.completed = True\n        logger.info(f\"Completed task {self.id}: {self.name}\")\n        return True\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def execute_all(self, max_workers: int = 3) -> None:\n        # Sort tasks by priority (higher first)\n        sorted_tasks = sorted(self.tasks, key=lambda t: t.priority, reverse=True)\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            executor.map(lambda task: task.execute(), sorted_tasks)\n\ndef main():\n    manager = TaskManager()\n    \n    # Create some sample tasks\n    for i in range(5):\n        task = Task(\n            id=i,\n            name=f\"Task-{i}\",\n            duration=random.uniform(0.5, 2.0),\n            priority=random.randint(1, 5)\n        )\n        manager.add_",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(\"No existing tasks file found. Starting with empty task list.\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=item[\"id\"],\n                    title=item[\"title\"],\n                    description=item[\"description\"],\n                    completed=item[\"completed\"],\n                    created_at=datetime.fromisoformat(item[\"created_at\"]),\n                    completed_at=datetime.fromisoformat(item[\"completed_at\"]) if item[\"completed_at\"]",
    "import json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional, Dict, Any\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: int, **kwargs: Any) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: Optional[str] = None\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'tags': self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(\n                        id=task_dict['id'],\n                        title=task_dict['title'],\n                        description=task_dict['description'],\n                        completed=task_dict['completed'],\n                        created_at=datetime.fromisoformat(task_dict['created_at']),\n                        tags=task_dict['tags']\n                    )\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except FileNotFoundError:\n            logger.info(f\"No task file found at {self.storage_path}, starting with empty",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.max_workers = max_workers\n        self.tasks: Dict[int, Task] = {}\n        self.results: Dict[int, Any] = {}\n        self.completed_tasks: List[int] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Dict[str, Any]:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        result = {\n            \"task_id\": task.id,\n            \"task_name\": task.name,\n            \"status\": \"completed\",\n            \"processing_time\": task.duration,\n            \"random_value\": random.randint(1, 100)\n        }\n        \n        self.completed_tasks.append(task_id)\n        logger.info(f\"Completed task {task.name} (ID: {task.id})\")\n        return result\n    \n    def run(self) -> Dict[int, Any]:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Process tasks respecting dependencies\n            while len(self",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No existing tasks file found, starting with empty task list\")\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def",
    "import json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime, \n                 tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, \n                    due_date=due_date, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_i",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        return None\n    \n    def get_tasks(",
    "import argparse\nimport json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    subtasks: List[\"Task\"] = None\n\n    def __post_init__(self):\n        if self.subtasks is None:\n            self.subtasks = []\n\n    def add_subtask(self, task: \"Task\") -> None:\n        self.subtasks.append(task)\n\n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"subtasks\": [subtask.to_dict() for subtask in self.subtasks]\n        }\n\n    @classmethod\n    def from_dict(cls, data: Dict) -> \"Task\":\n        task = cls(\n            name=data[\"name\"],\n            priority=data[\"priority\"],\n            completed=data[\"completed\"]\n        )\n        for subtask_data in data.get(\"subtasks\", []):\n            task.add_subtask(cls.from_dict(subtask_data))\n        return task\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n\n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n\n    def get_tasks_by_priority(self) -> List[Task]:\n        return sorted(self.tasks, key=lambda t: t.priority, reverse=True)\n\n    def save(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump({\"tasks\": [task.to_dict() for task in self.tasks]}, f, indent=2)\n\n    def load(self) -> None:\n        if not self.storage_path.exists():\n            return\n        \n        with open(self.storage_path, \"r\") as f:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        logger.info(f\"Completing task: {self.name}\")\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending = self.get_pending_tasks()\n        return max(pending, key=lambda x: x.priority) if pending else None\n\n@lru_cache(maxsize=100)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef main():\n    manager = TaskManager()\n    \n    # Create some sample tasks\n    for i in range(10):\n        priority = random.randint(1, 5)\n        task = Task(id=i, name=f\"Task {i}\", priority=priority)\n        manager.add_task(task)\n    \n    # Process tasks by priority\n    while True:\n        next_task = manager.get",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_incomplete_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    priority: int\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.due_date, str):\n            self.due_date = datetime.fromisoformat(self.due_date)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, task_id: str, task: Task) -> None:\n        self.tasks[task_id] = task\n        self.save_tasks()\n\n    def remove_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n\n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def complete_task(self, task_id: str) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_overdue_tasks(self) -> List[Task]:\n        now = datetime.now()\n        return [\n            task for task in self.tasks.values()\n            if task.due_date and task.due_date < now and not task.completed\n        ]\n\n    def save_tasks(self) -> None",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nimport os\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            logger.warning(f\"Task with ID {task_id} not found\")\n            return None\n        \n        for key, value in kwargs",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom functools import wraps\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\ndef retry(max_attempts: int = 3, delay: float = 1.0):\n    \"\"\"Decorator for retrying a function if it raises an exception.\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    if attempts == max_attempts:\n                        logger.error(f\"Failed after {max_attempts} attempts: {e}\")\n                        raise\n                    logger.warning(f\"Attempt {attempts} failed: {e}. Retrying in {delay} seconds...\")\n                    time.sleep(delay)\n        return wrapper\n    return decorator\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    completed: bool = False\n    priority: int = 1\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n    \n    def add_task(self, name: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Adde",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=t[\"id\"],\n                            title=t[\"title\"],\n                            description=t[\"description\"],\n                            due_date=datetime.fromisoformat(t[\"due_date\"]),\n                            completed=t[\"completed\"],\n                            tags=t.get(\"tags\", [])\n                        ) for t in tasks_data\n                    ]\n                logger.info(f\"Loaded {len(self",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> Task:\n        if any(t.id == task.id for t in self.tasks):\n            raise ValueError(f\"Task with ID {task.id} already exists\")\n        self.tasks.append(task)\n        self._save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_incomplete_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def _save_tasks(",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\nimport time\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    completion_time: Optional[float] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"Task Manager initialized\")\n    \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n        return task\n    \n    def get_next_task(self) -> Optional[Task]:\n        pending_tasks = [t for t in self.tasks if t.status == TaskStatus.PENDING]\n        if not pending_tasks:\n            return None\n        return max(pending_tasks, key=lambda x: x.priority)\n    \n    def process_tasks(self):\n        while True:\n            task = self.get_next_task()\n            if not task:\n                logger.info(\"No pending tasks\")\n                break\n                \n            logger.info(f\"Processing task: {task.name}\")\n            task.status = TaskStatus.IN_PROGRESS\n            \n            try:\n                # Simulate work\n                processing_time = random.uniform(0.5, 2.0)\n                time.sleep(processing_time)\n                \n                if random.random() < 0.",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.title}\"\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, priority=priority, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def filter_tasks(self, completed: Optional[bool] = None, min_priority: int = 0) -> List[Task]:\n        filtered = self.tasks\n        if completed is not None:\n            filtered = [t for t in filtered if t.completed == completed]\n        if min_priority > 0:\n            filtered = [t for t in filtered if",
    "import logging\nimport os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                self.save_tasks()\n                return True\n        logger.warning(f\"Task with ID {task_id} not",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.description}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, min_priority: int = 3) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    tasks = [\n        (\"Fix critical bug in authentication module\", 5",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    last_modified: float\n    \n    @property\n    def size_in_mb(self) -> float:\n        return self.size / (1024 * 1024)\n    \n    def __str__(self) -> str:\n        return f\"{self.path} ({self.size_in_mb:.2f} MB)\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        start_time = time.time()\n        \n        with ThreadPoolExecutor(max_workers=4) as executor:\n            for root, _, files in os.walk(self.root_dir):\n                executor.map(lambda f: self._process_file(root, f), files)\n                \n        logger.info(f\"Scan completed in {time.time() - start_time:.2f} seconds\")\n        return self.files\n    \n    def _process_file(self, root: str, filename: str) -> None:\n        if self.extensions and not any(filename.endswith(ext) for ext in self.extensions):\n            return\n            \n        full_path = os.path.join(root, filename)\n        try:\n            stats = os.stat(full_path)\n            self.files.append(FileInfo(\n                path=full_path,\n                size=stats.",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    due_date: datetime\n    tags: List[str] = field(default_factory=list)\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            raise ValueError(f\"Task with ID {task.id} already exists\")\n        self.tasks[task.id] = task\n        self._save_tasks()\n        \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate processing result\n        result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        task.result = result\n        \n        logger.info(f\"Completed task {task.name} (ID: {task.id})\")\n        return result\n        \n    def execute_workflow(self) -> Dict[int, Any]:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Track completed tasks\n            completed_tasks = set()\n            results = {}\n            \n            while len(completed_tasks) < len(self.tasks):\n                ready_tasks = []\n                \n                # Find tasks that can be executed (all dependencies satisfied)\n                for task_id, task in self.tasks.items():\n                    if task_id not",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, IOError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n                self.tasks = []\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except IOError as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([",
    "import time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport threading\nimport queue\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    execution_time: float\n    result: Optional[str] = None\n    completed: bool = False\n\nclass TaskProcessor:\n    def __init__(self, num_workers: int = 3):\n        self.task_queue = queue.PriorityQueue()\n        self.results = {}\n        self.workers = []\n        self.running = True\n        \n        for i in range(num_workers):\n            worker = threading.Thread(target=self._worker_loop, args=(i,))\n            worker.daemon = True\n            self.workers.append(worker)\n            worker.start()\n    \n    def add_task(self, task: Task):\n        self.task_queue.put((-task.priority, task.id, task))\n    \n    def _worker_loop(self, worker_id: int):\n        while self.running:\n            try:\n                _, _, task = self.task_queue.get(timeout=1)\n                print(f\"Worker {worker_id} processing task {task.name}\")\n                time.sleep(task.execution_time)  # Simulate work\n                task.result = f\"Result of {task.name} (processed by worker {worker_id})\"\n                task.completed = True\n                self.results[task.id] = task\n                self.task_queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                print(f\"Error in worker {worker_id}: {e}\")\n    \n    def shutdown(self):\n        self.running = False\n        for worker in self.workers:\n            worker.join(timeout=2)\n\ndef generate_tasks(count: int) -> List[Task]:\n    return [\n        Task(\n            id=i,\n            name=f\"Task-{i}\",\n            priority=random.randint(1, 10),\n            execution_time=random.uniform(0.1, 0.5)",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport random\nfrom collections import defaultdict\n\n\n@dataclass\nclass Transaction:\n    id: str\n    amount: float\n    category: str\n    date: str\n    description: Optional[str] = None\n\n\nclass BudgetTracker:\n    def __init__(self, filename: str = \"transactions.json\"):\n        self.filename = filename\n        self.transactions: List[Transaction] = []\n        self.load_transactions()\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self.save_transactions()\n    \n    def load_transactions(self) -> None:\n        try:\n            with open(self.filename, 'r') as f:\n                data = json.load(f)\n                self.transactions = [Transaction(**t) for t in data]\n        except (FileNotFoundError, json.JSONDecodeError):\n            self.transactions = []\n    \n    def save_transactions(self) -> None:\n        with open(self.filename, 'w') as f:\n            json.dump([vars(t) for t in self.transactions], f, indent=2)\n    \n    def get_category_summary(self) -> Dict[str, float]:\n        summary = defaultdict(float)\n        for transaction in self.transactions:\n            summary[transaction.category] += transaction.amount\n        return dict(summary)\n    \n    def get_total_spent(self) -> float:\n        return sum(t.amount for t in self.transactions)\n\n\nif __name__ == \"__main__\":\n    tracker = BudgetTracker(\"my_budget.json\")\n    \n    # Add some sample transactions\n    categories = [\"Groceries\", \"Entertainment\", \"Bills\", \"Transport\"]\n    \n    for i in range(5):\n        transaction = Transaction(\n            id=f\"tx-{random.randint(1000, 9999)}\",\n            amount=round(random.uniform(10, 100), 2),\n            category=random.choice(categories),\n            date=\"2023-11-15\",",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    subtasks: List['Task'] = field(default_factory=list)\n    metadata: Dict[str, str] = field(default_factory=dict)\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.completed = True\n                logger.info(f\"Marked task as completed: {task_name}\")\n                return True\n        logger.warning(f\"Task not found: {task_name}\")\n        return False\n    \n    def get_pending_tasks(self, min_priority: int = 0) -> List[Task]:\n        return [task for task in self.tasks \n                if not task.completed and task.priority >= min_priority]\n    \n    def save(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([(t.name, t.priority, t.completed, t.metadata) \n                          for t in self.tasks], f)\n            logger.info(f\"Tasks saved to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Failed to save tasks: {e}\")\n    \n    def loa",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n    \n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        self.tasks[task_id] = Task(\n            id=task_id,\n            name=name,\n            priority=priority,\n            dependencies=dependencies or []\n        )\n        logger.info(f\"Added task: {name} (ID: {task_id})\")\n        return task_id\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        task = self.tasks[task_id]\n        task.completed = True\n        logger.info(f\"Completed task: {task.name}\")\n        return True\n    \n    def get_next_task(self) -> Optional[Task]:\n        available_tasks = [\n            task for task in self.tasks.values()\n            if not task.completed and all(\n                self.tasks[dep].completed for dep in (task.dependencies or [])\n                if dep in self.tasks\n            )\n        ]\n        \n        if not available_tasks:\n            return None\n        \n        return max(available_tasks, key=lambda t: t.priority)\n    \n    def process_tasks(self):\n        while",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate some processing\n        result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        task.result = result\n        \n        return result\n    \n    def execute_tasks(self) -> Dict[int, Any]:\n        results = {}\n        processed_tasks = set()\n        \n        while len(processed_tasks) < len(self.tasks):\n            ready_tasks = [\n                task_id for task_id, task in self.tasks.items()\n                if task_id not in processed_tasks and\n                all(dep in processed_tasks for dep in task.dependencies)\n            ]\n            \n            if not ready_tasks:\n                logger.error(\"Dependency cycle detected or no tasks available\")\n                break\n                \n            with ThreadPoolExecutor(max_workers=",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\nimport argparse\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.logger = self._setup_logger()\n        \n    def _setup_logger(self):\n        logger = logging.getLogger(\"task_manager\")\n        logger.setLevel(logging.INFO)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        return logger\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            self.logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        self.tasks[task.name] = task\n        self.logger.info(f\"Added task: {task.name}\")\n        return True\n        \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            self.logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        self.tasks[task_name].mark_complete()\n        self.logger.info(f\"Completed task: {task_name}\")\n        return True\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool\n    created_at: datetime\n    completed_at: Optional[datetime] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file {self.storage_path} not found. Creating a new task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=task['id'],\n                    title=task['title'],\n                    description=task['description'],\n                    completed=task['completed'],\n                    created_at=datetime.fromisoformat(task['created_at']),\n                    completed_at=datetime.fromisoformat(task['completed_at']) if task['completed_at'] else None\n                )\n                for task in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n\n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, name: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(name=name, description=description, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_index: int) -> bool:\n        if 0 <= task_index < len(self.tasks):\n            self.tasks[task_index].complete()\n            self.save_tasks()\n            return True\n        return False\n\n    def list_tasks(self, show_completed: bool = False) -> List[Task]:\n        return [task for task in self.tasks if show_completed or not task.completed]\n\n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task in self.",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = None\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                \n                for task_dict in tasks_data:\n                    # Convert string date back to datetime\n                    if 'created_at' in task_dict and task_dict['created_at']:\n                        task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                    self.tasks.append(Task(**task_dict))\n                \n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport os\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n            logger.info(",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_completed(self):\n        self.completed = True\n        return self\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self._load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority, tags=tags)\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self._save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]",
    "import json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.next_id = 1\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self._save_tasks()\n        logger.info(f\"Added task: {title} (ID: {task.id})\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self._save_tasks()\n            logger.info(f\"Completed task ID",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse {self.storage_path}. Starting with empty task list.\")\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) +",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, assigned_to: str) -> None:\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = assigned_to\n        logger.info(f\"Task {self.id} started by {assigned_to}\")\n    \n    def complete(self) -> None:\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added new task: {name} (ID: {task_id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_tasks_by_status(self,",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = None\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 3  # 1 (highest) to 5 (lowest)\n    due_date: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_index: int) -> None:\n        if 0 <= task_index < len(self.tasks):\n            self.tasks[task_index].completed = True\n            logger.info(f\"Completed task: {self.tasks[task_index].title}\")\n            self.save_tasks()\n        else:\n            logger.error(f\"Invalid task index: {task_index}\")\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def save_tasks(self) -> None:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1  # 1 (low) to 5 (high)\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None, \n                priority: int = 1) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        self.tasks[task_id] = Task(\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or [],\n            priority=max(1, min(5, priority))  # Clamp between 1-5\n        )\n        self._save_tasks()\n        return task_id\n\n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self._save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Dict]:\n        return [\n            {\"id\": task_id, **asdict(task)}\n            for task_id, task in self.tasks.items()\n            if tag in task.tags\n        ]\n\n    def get_priority_tasks(self, min_priority: int = 3) -> List[Dict]:\n        return [\n            {\"id\": task_id, **asdict(task)}\n            for task_id, task in self",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    def get_next_task(self) -> Optional[Task]:\n        incomplete_tasks = [t for t in self.tasks if not t.completed]\n        if not incomplete_tasks:\n            return None\n        return max(incomplete_tasks, key=lambda t: t.priority)\n    \n    def summary(self) -> str:\n        completed = sum(",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def mark_completed(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            logger.info(f\"Deleted task: {task.title}\")\n            return True\n        return False\n    \n    def save_tasks(self) -> None:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}, starting with empty task list\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                for task_data in tasks_data:\n                    task = Task(**task_data)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            tasks_data = [asdict(task) for task in self.tasks.values()]\n            with open(self.storage_path, \"w\") as f:\n                json.dump(tasks_data, f, default=str, indent=2)\n            logger.",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.tasks: Dict[int, Task] = {}\n        self.storage_file = storage_file\n        self.next_id = 1\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added new task: {task.title}\")\n        self.save_tasks()\n        return task\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            logger.info(f\"Deleted task {task_",
    "import argparse\nimport json\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if self.storage_path.exists():\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_data in data:\n                    task = Task(**task_data)\n                    self.tasks[task.id] = task\n\n    def save_tasks(self):\n        with open(self.storage_path, \"w\") as f:\n            json.dump([vars(task) for task in self.tasks.values()], f, indent=2)\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Task Manager CLI\")\n    subparsers",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport argparse\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Creating new task storage at {self.storage_path}\")\n            self.storage_path.parent.mkdir(parents=True, exist_ok=True)\n            self._save_tasks()\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task(**task) for task in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            self.tasks = []\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([t.id for t in self.tasks], default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.",
    "import time\nfrom functools import wraps\nfrom typing import Callable, Dict, List, Optional, TypeVar, Any\n\nT = TypeVar('T')\n\n# Decorator for timing function execution\ndef timer(func: Callable[..., T]) -> Callable[..., T]:\n    @wraps(func)\n    def wrapper(*args, **kwargs) -> T:\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} executed in {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n# Cache decorator with timeout\nclass memoize:\n    def __init__(self, timeout: int = 60):\n        self.timeout = timeout\n        self.cache: Dict[str, Dict] = {}\n    \n    def __call__(self, func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args, **kwargs) -> Any:\n            key = str(args) + str(kwargs)\n            if key in self.cache:\n                if time.time() - self.cache[key]['time'] < self.timeout:\n                    return self.cache[key]['result']\n            \n            result = func(*args, **kwargs)\n            self.cache[key] = {'result': result, 'time': time.time()}\n            return result\n        return wrapper\n\n@timer\n@memoize(timeout=5)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n@timer\ndef process_data(items: List[int], threshold: Optional[int] = None) -> List[int]:\n    if threshold is None:\n        threshold = sum(items) // len(items)\n    \n    return [x for x in items if x > threshold]\n\nif __name__ == \"__main__\":\n    # Test fibonacci with memoization\n    print(f\"Fibonacci of 30: {fibonacci(30)}\")\n    print(\"Running again (should be faster due to cache):\")\n    print(",
    "import argparse\nimport logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.logger = logging.getLogger(__name__)\n\n    def add_task(self, description: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, description=description, priority=priority)\n        self.tasks.append(task)\n        self.logger.info(f\"Added task: {task}\")\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.logger.info(f\"Completed task: {task}\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        self.logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n\n    def get_pending_tasks(self, sort_by_priority: bool = False) -> List[Task]:\n        pending = [task for task in self.tasks if not task.completed]\n        if sort_by_priority:\n            return sorted(pending, key=lambda x: x.priority, reverse=True)\n        return pending\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Task Manager CLI\")\n    parser.add_argument(\"--log-level\", default=\"INFO\", help=\"Set logging level\")\n    args = parser.parse_args()\n\n    logging.basicConfig(\n        level=getattr(logging, args.log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    manager = TaskManager()",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[str] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = self._load_tasks()\n        \n    def _load_tasks(self) -> List[Task]:\n        if not os.path.exists(self.storage_path):\n            return []\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                return [Task(**task) for task in tasks_data]\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            return []\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n    \n    def add_task(self, title: str, description: str, due_date: Optional[str] = None, tags: List[str] = None) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        new_task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(new_task)",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: str):\n        self.station_id = station_id\n        self.location = location\n        self.temperature_readings = []\n        self.humidity_readings = []\n        \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n        \n    def average_temperature(self) -> float:\n        if not self.temperature_readings:\n            return 0.0\n        return sum(self.temperature_readings) / len(self.temperature_readings)\n    \n    def average_humidity(self) -> float:\n        if not self.humidity_readings:\n            return 0.0\n        return sum(self.humidity_readings) / len(self.humidity_readings)\n    \n    def __str__(self) -> str:\n        return f\"Station {self.station_id} at {self.location}\"\n\n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n        \n    def add_station(self, station: WeatherStation) -> None:\n        self.stations[station.station_id] = station\n        \n    def get_station(self, station_id: str) -> WeatherStation:\n        return self.stations.get(station_id)\n    \n    def get_all_readings(self) -> Dict[str, List[Tuple[float, float]]]:\n        result = defaultdict(list)\n        for station_id, station in self.stations.items():\n            for temp, humid in zip(station.temperature_readings, station.humidity_readings):\n                result[station_id].append((temp, humid))\n        return result\n    \n    def hottest_station(self) -> WeatherStation:\n        if not self.stations:\n            return None\n        return max(self.stations.values(), key=lambda s: s.average_temperature())\n\n\nif __name__ == \"__main__\":",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom pathlib import Path\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2",
    "import csv\nimport argparse\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom typing import Dict, List, Tuple\n\n\nclass SalesAnalyzer:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.sales_data = []\n        self.load_data()\n\n    def load_data(self) -> None:\n        try:\n            with open(self.file_path, 'r', newline='') as file:\n                reader = csv.DictReader(file)\n                self.sales_data = list(reader)\n        except FileNotFoundError:\n            print(f\"Error: File '{self.file_path}' not found.\")\n            exit(1)\n\n    def get_total_sales(self) -> float:\n        return sum(float(row['amount']) for row in self.sales_data)\n\n    def get_sales_by_region(self) -> Dict[str, float]:\n        sales_by_region = defaultdict(float)\n        for row in self.sales_data:\n            sales_by_region[row['region']] += float(row['amount'])\n        return dict(sales_by_region)\n\n    def get_monthly_sales(self) -> Dict[str, float]:\n        monthly_sales = defaultdict(float)\n        for row in self.sales_data:\n            date = datetime.strptime(row['date'], '%Y-%m-%d')\n            month_key = f\"{date.year}-{date.month:02d}\"\n            monthly_sales[month_key] += float(row['amount'])\n        return dict(monthly_sales)\n\n    def get_top_products(self, limit: int = 5) -> List[Tuple[str, float]]:\n        product_sales = defaultdict(float)\n        for row in self.sales_data:\n            product_sales[row['product']] += float(row['amount'])\n        \n        return sorted(product_sales.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Analyze sales data from CSV",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_file}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_file, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_file}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def get_tasks_by_priority(self, min_priority: int = 1) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n\n    def _generate_id(self) -> int:\n        if not self.tasks:\n            return 1\n        return max(task.id for task in self.tasks) + 1\n\n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            self.tasks = []\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n        except (json.JSONDec",
    "import csv\nimport argparse\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\n\n\n@dataclass\nclass SalesRecord:\n    product_id: str\n    quantity: int\n    price: float\n    customer_id: str\n    date: str\n    \n    @property\n    def total(self) -> float:\n        return self.quantity * self.price\n\n\nclass SalesAnalyzer:\n    def __init__(self, filename: str):\n        self.filename = filename\n        self.records: List[SalesRecord] = []\n        self._load_data()\n    \n    def _load_data(self) -> None:\n        try:\n            with open(self.filename, 'r') as f:\n                reader = csv.DictReader(f)\n                for row in reader:\n                    self.records.append(SalesRecord(\n                        product_id=row['product_id'],\n                        quantity=int(row['quantity']),\n                        price=float(row['price']),\n                        customer_id=row['customer_id'],\n                        date=row['date']\n                    ))\n        except FileNotFoundError:\n            print(f\"Warning: File {self.filename} not found. Starting with empty records.\")\n    \n    def total_sales(self) -> float:\n        return sum(record.total for record in self.records)\n    \n    def sales_by_product(self) -> Dict[str, float]:\n        result = defaultdict(float)\n        for record in self.records:\n            result[record.product_id] += record.total\n        return dict(result)\n    \n    def top_customers(self, limit: int = 5) -> List[tuple]:\n        customer_sales = defaultdict(float)\n        for record in self.records:\n            customer_sales[record.customer_id] += record.total\n        \n        return sorted(customer_sales.items(), key=lambda x: x[1], reverse=True)[:limit]\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Analyze sales data')\n    parser.add_argument('filename",
    "import json\nimport os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(\n                            id=task_dict[\"id\"],\n                            title=task_dict[\"title\"],\n                            description=task_dict[\"description\"],\n                            completed=task_dict[\"completed\"],\n                            due_date=datetime.fromisoformat(task_dict[\"due_date\"]) if task_dict[\"due_date\"] else None,\n                            tags=task_dict[\"tags\"]\n                        )\n                        self.tasks[task.id]",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        created_at=datetime.fromisoformat(task_dict[\"created_at\"]),\n                        completed=task_dict[\"completed\"],\n                        tags=task_dict[\"tags\"]\n                    )\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n\n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n\n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.completed = True\n                logger.info(f\"Marked task as completed: {task.name}\")\n                self.save_tasks()\n                return True\n        logger.warning(f\"Task not found: {task_name}\")\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n\n    def get_high_priority_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.priority > 7]\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            serialized = [asdict(task) for task in self.tasks]\n            for task_dict in serialized:\n                if task_dict.get('due_date'):",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = [\n                    Task(\n                        id=t['id'],\n                        title=t['title'],\n                        description=t['description'],\n                        completed=t['completed'],\n                        created_at=datetime.fromisoformat(t['created_at']),\n                        completed_at=datetime.fromisoformat(t['completed_at']) if t['completed_at'] else None\n                    )\n                    for t in tasks_data\n                ]",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    last_modified: float\n    metadata: Optional[Dict[str, Any]] = None\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, file_extensions: List[str] = None):\n        self.root_dir = Path(root_dir)\n        self.file_extensions = file_extensions or ['.txt', '.py', '.json']\n        self.results: List[FileInfo] = []\n    \n    def scan_directory(self, max_workers: int = 4) -> List[FileInfo]:\n        start_time = time.time()\n        logger.info(f\"Starting scan of {self.root_dir}\")\n        \n        all_files = []\n        for ext in self.file_extensions:\n            all_files.extend(self.root_dir.glob(f\"**/*{ext}\"))\n        \n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            self.results = list(executor.map(self._process_file, all_files))\n        \n        elapsed = time.time() - start_time\n        logger.info(f\"Scan completed in {elapsed:.2f} seconds, found {len(self.results)} files\")\n        return self.results\n    \n    def _process_file(self, file_path: Path) -> FileInfo:\n        stat = file_path.stat()\n        metadata = None\n        \n        if file_path.suffix == '.json':\n            try:\n                with open(file_path, 'r') as f:\n                    metadata = json.load(f)\n            except json.JSONDecodeError:\n                logger",
    "import time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport threading\nimport queue\n\n\n@dataclass\nclass Task:\n    id: int\n    description: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.task_queue = queue.Queue()\n        self._next_id = 1\n        self._lock = threading.Lock()\n        self._running = False\n        self._worker_thread = None\n\n    def add_task(self, description: str, priority: int = 1) -> Task:\n        with self._lock:\n            task = Task(id=self._next_id, description=description, priority=priority)\n            self._next_id += 1\n            self.tasks.append(task)\n            self.task_queue.put(task)\n            return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        with self._lock:\n            for task in self.tasks:\n                if task.id == task_id:\n                    return task\n        return None\n\n    def mark_completed(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def start_processing(self):\n        if self._running:\n            return\n        \n        self._running = True\n        self._worker_thread = threading.Thread(target=self._process_tasks)\n        self._worker_thread.daemon = True\n        self._worker_thread.start()\n\n    def stop_processing(self):\n        self._running = False\n        if self._worker_thread:\n            self._worker_thread.join(timeout=1.0)\n\n    def _process_tasks(self):\n        while self._running:\n            try:\n                task = self.task_queue.get(timeout=1.0)\n                print(f\"Processing task {task.id}: {task.description}\")\n                # Simulate work\n                time.sleep(task.priority *",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field, asdict\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n    \n    def is_overdue(self) -> bool:\n        return self.due_date is not None and not self.completed and datetime.now() > self.due_date\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json_data = {name: asdict(task) for name, task in self.tasks.items()}\n            for task_dict in json",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (highest) to 5 (lowest)\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}. Creating new task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                    self.tasks[task_id] = Task(**task_data)\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            tasks_dict = {}\n            for task_id, task in self.tasks.items():\n                task_dict = task.__dict__.copy()\n                task_dict['created_at'] = task.created_at.isoformat()\n                tasks_dict[task_id] = task_dict\n                \n            with open(self",
    "import json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        logger.warning(f\"Task with ID {task_i",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}. Creating new task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_data in tasks_data:\n                task = Task(\n                    id=task_data['id'],\n                    title=task_data['title'],\n                    description=task_data['description'],\n                    completed=task_data['completed'],\n                    created_at=datetime.fromisoformat(task_data['created_at']),\n                    completed_at=",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    CANCELLED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_in_progress(self):\n        self.status = TaskStatus.IN_PROGRESS\n        \n    def mark_completed(self):\n        self.status = TaskStatus.COMPLETED\n        \n    def mark_cancelled(self):\n        self.status = TaskStatus.CANCELLED\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        self.logger = self._setup_logger()\n    \n    def _setup_logger(self):\n        logger = logging.getLogger(\"TaskManager\")\n        logger.setLevel(logging.INFO)\n        if not logger.handlers:\n            handler = logging.StreamHandler()\n            formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n            handler.setFormatter(formatter)\n            logger.addHandler(handler)\n        return logger\n    \n    def create_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, tags=tags)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.logger.info(f\"Created task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def get_task(self",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass CardSuit(Enum):\n    HEARTS = auto()\n    DIAMONDS = auto()\n    CLUBS = auto()\n    SPADES = auto()\n    \nclass CardRank(Enum):\n    ACE = 1\n    TWO = 2\n    THREE = 3\n    FOUR = 4\n    FIVE = 5\n    SIX = 6\n    SEVEN = 7\n    EIGHT = 8\n    NINE = 9\n    TEN = 10\n    JACK = 11\n    QUEEN = 12\n    KING = 13\n\n@dataclass\nclass Card:\n    rank: CardRank\n    suit: CardSuit\n    \n    def __str__(self) -> str:\n        return f\"{self.rank.name} of {self.suit.name}\"\n\nclass Deck:\n    def __init__(self):\n        self.cards: List[Card] = []\n        self._initialize_deck()\n        \n    def _initialize_deck(self) -> None:\n        self.cards = [\n            Card(rank, suit)\n            for suit in CardSuit\n            for rank in CardRank\n        ]\n        \n    def shuffle(self) -> None:\n        logger.info(\"Shuffling deck\")\n        random.shuffle(self.cards)\n        \n    def draw(self) -> Optional[Card]:\n        if not self.cards:\n            logger.warning(\"Attempted to draw from empty deck\")\n            return None\n        return self.cards.pop()\n\nclass Player:\n    def __init__(self, name: str):\n        self.name = name\n        self.hand: List[Card] = []\n        \n    def add_card(self, card: Card) -> None:\n        self.hand.append(card)",
    "import time\nfrom functools import wraps\nfrom typing import Dict, List, Optional, Callable, Any\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n# Decorator for timing function execution\ndef timing_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        logger.info(f\"Function {func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n# Data model\nclass Task:\n    def __init__(self, task_id: int, name: str, priority: int = 1, completed: bool = False):\n        self.task_id = task_id\n        self.name = name\n        self.priority = priority\n        self.completed = completed\n        \n    def __repr__(self) -> str:\n        status = \"✓\" if self.completed else \"□\"\n        return f\"Task {self.task_id}: [{status}] {self.name} (priority: {self.priority})\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(self.next_id, name, priority)\n        self.tasks[self.next_id] = task\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if not 1 <= self.priority <= 5:\n            raise ValueError(\"Priority must be between 1 and 5\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks = []\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1, tags: List[str] = None) -> Task:\n        new_id = self._generate_id()\n        task = Task(id=new_id, title=title, description=description, priority=priority, tags=tags)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value in kwargs.items():\n                if hasattr(task, key):\n                    setattr(task, key, value)\n            self.save_tasks()\n            return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self,",
    "import requests\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Book:\n    id: int\n    title: str\n    author: str\n    year: int\n    rating: float\n    available: bool = True\n\nclass BookRepository:\n    def __init__(self):\n        self.books = {}\n        self._load_initial_data()\n    \n    def _load_initial_data(self):\n        initial_books = [\n            Book(1, \"The Great Gatsby\", \"F. Scott Fitzgerald\", 1925, 4.2),\n            Book(2, \"To Kill a Mockingbird\", \"Harper Lee\", 1960, 4.5),\n            Book(3, \"1984\", \"George Orwell\", 1949, 4.6),\n        ]\n        for book in initial_books:\n            self.books[book.id] = book\n    \n    def add_book(self, book: Book) -> bool:\n        if book.id in self.books:\n            return False\n        self.books[book.id] = book\n        return True\n    \n    def get_book(self, book_id: int) -> Optional[Book]:\n        return self.books.get(book_id)\n    \n    def get_all_books(self) -> List[Book]:\n        return list(self.books.values())\n    \n    def update_book(self, book_id: int, **kwargs) -> bool:\n        if book_id not in self.books:\n            return False\n        \n        for key, value in kwargs.items():\n            if hasattr(self.books[book_id], key):\n                setattr(self.books[book_id], key, value)\n        return True\n\n@lru_cache(maxsize=100)\ndef fetch_",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"due_date\": self.due_date.isoformat() if self.due_date else None,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Task added: {task.name}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.completed = True\n                logger.info(f\"Task completed: {task.name}\")\n                self.save_tasks()\n                return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def save_tasks(self",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    id: int\n    name: str\n    value: float\n    category: str\n\nclass Inventory:\n    def __init__(self):\n        self.items: List[Item] = []\n        \n    def add_item(self, item: Item) -> None:\n        logger.info(f\"Adding item: {item.name}\")\n        self.items.append(item)\n        \n    def remove_item(self, item_id: int) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.id == item_id:\n                logger.info(f\"Removing item: {item.name}\")\n                return self.items.pop(i)\n        logger.warning(f\"Item with id {item_id} not found\")\n        return None\n    \n    def get_items_by_category(self, category: str) -> List[Item]:\n        return [item for item in self.items if item.category == category]\n    \n    def get_total_value(self) -> float:\n        return sum(item.value for item in self.items)\n    \n    def __len__(self) -> int:\n        return len(self.items)\n\n@lru_cache(maxsize=128)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef main():\n    inventory = Inventory()\n    categories = [\"electronics\", \"books\", \"clothing\", \"food\"]\n    \n    # Generate random items\n    for i in range(10):\n        item = Item(\n            id=i,\n            name=f\"Item-{i}\",\n            value=random.uniform(10.0, 100.0",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport os\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_complete(self):\n        self.completed = True\n        return self\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, due_date: Optional[str] = None) -> Task:\n        due_date_obj = datetime.fromisoformat(due_date) if due_date else None\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date_obj)\n        self.tasks[self.next_id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        if task_id not in self.tasks:\n            return None\n        \n        task = self.tasks[task_id]\n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_i",
    "import os\nimport json\nimport logging\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom pathlib import Path\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass TaskItem:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[TaskItem] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file not found at {self.storage_path}, creating new task list\")\n            self.tasks = []\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [\n                    TaskItem(\n                        id=item[\"id\"],\n                        title=item[\"title\"],\n                        description=item[\"description\"],\n                        completed=item[\"completed\"],\n                        created_at=datetime.fromisoformat(item[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(item[\"completed_at\"]) if item[\"completed_at\"] else None\n                    ) for item in data\n                ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            self.tasks = []\n    \n    def save(self) -> None:\n        data = [\n            {\n                \"id\": task.id,\n                \"title\": task.title,\n                \"description\": task.description,",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate result\n        result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        task.result = result\n        return result\n        \n    def execute_all(self) -> Dict[int, Any]:\n        results = {}\n        processed = set()\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(processed) < len(self.tasks):\n                ready_tasks = [\n                    task_id for task_id, task in self.tasks.items()\n                    if task_id not in processed and all(dep in processed for dep in task.dependencies)\n                ]\n                \n                if not ready_tasks:\n                    break\n                    \n                futures = {\n                    executor.submit(self.process",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    for task_id, task_data in tasks_data.items():\n                        self.tasks[int(task_id)] = Task(**task_data)\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n                json.dump(tasks_dict, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n\n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n\n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    task_dicts = json.load(f)\n                    self.tasks = [Task(**task) for task in task_dicts]\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n                self.tasks = []\n        \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        next_id = max([task.id for task in self.tasks], default=0) + 1\n        task = Task(id=next_id, title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id and not task.completed:\n                task.completed = True\n                task.completed_at = datetime.now().isoformat()\n                self.save_tasks()",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self.save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        if tag:\n            return [task for task in self.tasks.values() if tag in task.tags]\n        return list(self.tasks.values())\n    \n    def save_tasks(self):\n        with open(self.storage_path, '",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n    \n    def assign_task(self, task_name: str, person: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.assigned_to = person\n                task.status = TaskStatus.IN_PROGRESS\n                logger.info(f\"Task '{task_name}' assigned to {person}\")\n                return True\n        logger.warning(f\"Task '{task_name}' not found\")\n        return False\n    \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.status = TaskStatus.COMPLETED\n                logger.info(f\"Task '{task_name}' marked as completed\")\n                return True\n        logger.warning(f\"Task '{task_name}' not found\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_tasks_by_person(self, person: str) -> List[Task",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    due_date = None\n                    if task_data.get(\"due_date\"):\n                        due_date = datetime.fromisoformat(task_data[\"due_date\"])\n                    \n                    self.tasks[task_id] = Task(\n                        name=task_data[\"name\"],\n                        description=task_data[\"description\"],\n                        due_date=due_date,\n                        completed=task_data[\"completed\"],\n                        tags=task_data.get(\"tags\", [])\n                    )\n        except (json.JSONDecodeError, FileNotFoundError):\n            pass\n\n    def save_tasks(self) -> None:\n        serializable_tasks = {}\n        for task_id, task in self.tasks.items():\n            task_dict = {\n                \"name\": task.name,\n                \"description\": task.description,\n                \"completed\": task.completed,\n                \"tags\": task.tags\n            }\n            if task.due_date:\n                task_dict[\"due_date\"] = task.due_date.isoformat()\n            \n            serializable_tasks[task_id] = task_dict\n            \n        with open(self.storage_path, \"w\") as f:",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: Optional[str] = None\n    \n    def is_expense(self) -> bool:\n        return self.amount < 0\n    \n    def is_income(self) -> bool:\n        return self.amount > 0\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n    \n    def _load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            logger.info(f\"Data file {self.data_file} not found. Starting with empty dataset.\")\n            return\n        \n        try:\n            with open(self.data_file, 'r', newline='') as f:\n                reader = csv.reader(f)\n                next(reader)  # Skip header\n                for row in reader:\n                    if len(row) >= 3:\n                        date = datetime.strptime(row[0], '%Y-%m-%d')\n                        amount = float(row[1])\n                        category = row[2]\n                        description = row[3] if len(row) > 3 else None\n                        self.transactions.append(\n                            Transaction(date, amount, category, description)\n                        )\n            logger.info(f\"Loaded {len(self.transactions)} transactions from {self.data_file}\")\n        except Exception as e:\n            logger.error(f\"Error loading data: {e}\")\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions",
    "import random\nfrom collections import defaultdict\nfrom typing import Dict, List, Tuple, Optional\n\n\nclass WeatherStation:\n    def __init__(self, station_id: str, location: Tuple[float, float]):\n        self.station_id = station_id\n        self.location = location  # (latitude, longitude)\n        self.temperature_readings: List[float] = []\n        self.humidity_readings: List[float] = []\n        \n    def add_reading(self, temperature: float, humidity: float) -> None:\n        self.temperature_readings.append(temperature)\n        self.humidity_readings.append(humidity)\n        \n    def avg_temperature(self) -> Optional[float]:\n        if not self.temperature_readings:\n            return None\n        return sum(self.temperature_readings) / len(self.temperature_readings)\n    \n    def avg_humidity(self) -> Optional[float]:\n        if not self.humidity_readings:\n            return None\n        return sum(self.humidity_readings) / len(self.humidity_readings)\n    \n    def __str__(self) -> str:\n        return f\"Station {self.station_id} at {self.location}\"\n\n\nclass WeatherNetwork:\n    def __init__(self):\n        self.stations: Dict[str, WeatherStation] = {}\n        self.region_stations: Dict[str, List[str]] = defaultdict(list)\n        \n    def add_station(self, station: WeatherStation, region: str) -> None:\n        self.stations[station.station_id] = station\n        self.region_stations[region].append(station.station_id)\n        \n    def get_region_data(self, region: str) -> Dict[str, float]:\n        if region not in self.region_stations:\n            return {}\n            \n        temps = []\n        humidity = []\n        \n        for station_id in self.region_stations[region]:\n            station = self.stations[station_id]\n            avg_temp = station.avg_temperature()\n            avg_hum = station.avg_humidity()\n            \n            if avg_temp is not None:\n                temps",
    "import logging\nfrom dataclasses import dataclass\nfrom enum import Enum, auto\nfrom typing import Dict, List, Optional\nimport random\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass ItemType(Enum):\n    WEAPON = auto()\n    ARMOR = auto()\n    POTION = auto()\n    SCROLL = auto()\n\n\n@dataclass\nclass Item:\n    name: str\n    item_type: ItemType\n    value: int\n    weight: float\n    \n    def __str__(self) -> str:\n        return f\"{self.name} ({self.item_type.name}): {self.value} gold, {self.weight} kg\"\n\n\nclass Inventory:\n    def __init__(self, capacity: float = 50.0):\n        self.items: List[Item] = []\n        self.capacity = capacity\n        \n    @property\n    def current_weight(self) -> float:\n        return sum(item.weight for item in self.items)\n    \n    @property\n    def remaining_capacity(self) -> float:\n        return self.capacity - self.current_weight\n    \n    def add_item(self, item: Item) -> bool:\n        if item.weight <= self.remaining_capacity:\n            self.items.append(item)\n            logger.info(f\"Added {item.name} to inventory\")\n            return True\n        logger.warning(f\"Cannot add {item.name}: exceeds capacity\")\n        return False\n    \n    def remove_item(self, item_name: str) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.name.lower() == item_name.lower():\n                removed_item = self.items.pop(i)\n                logger.info(f\"Removed {removed_item.name} from inventory\")\n                return removed_item\n        logger.warning(f\"Item {item_name} not found in inventory\")\n        return None\n    \n    def list",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    for task_id, task_dict in tasks_data.items():\n                        self.tasks[int(task_id)] = Task(**task_dict)\n            except (json.JSONDecodeError, IOError) as e:\n                print(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self):\n        tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump(tasks_dict, f, indent=2)\n        except IOError as e:\n            print(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, due_date=due_date)\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            logger.info(f\"",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool\n    created_at: datetime\n    tags: List[str]\n    priority: int\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, tags: List[str] = None, priority: int = 1) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            completed=False,\n            created_at=datetime.now(),\n            tags=tags or [],\n            priority=priority\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if not task:\n            return None\n        \n        for key, value in kwargs.items():\n            if hasattr(task, key):\n                setattr(task, key, value)\n        \n        self.save_tasks()\n        return task\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n\n    def get_all_tasks(self) -> List[Task]:\n        return list(self.tasks.values())\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    tags: Optional[List[str]] = None\n\nclass Inventory:\n    def __init__(self, data_file: str = \"inventory.json\"):\n        self.data_file = Path(data_file)\n        self.products: Dict[int, Product] = {}\n        self.load_inventory()\n    \n    def load_inventory(self) -> None:\n        if not self.data_file.exists():\n            logger.warning(f\"Inventory file {self.data_file} not found. Starting with empty inventory.\")\n            return\n        \n        try:\n            with open(self.data_file, 'r') as f:\n                data = json.load(f)\n                for item in data:\n                    self.products[item['id']] = Product(**item)\n            logger.info(f\"Loaded {len(self.products)} products from inventory\")\n        except json.JSONDecodeError:\n            logger.error(f\"Failed to parse {self.data_file}. Starting with empty inventory.\")\n        except Exception as e:\n            logger.error(f\"Error loading inventory: {e}\")\n    \n    def save_inventory(self) -> None:\n        try:\n            with open(self.data_file, 'w') as f:\n                json.dump([vars(p) for p in self.products.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.products)} products to inventory\")\n        except Exception as e:\n            logger.error(f\"Error saving inventory: {e}\")\n    \n    def add_product(self, product: Product) -> None:\n        if",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom datetime import datetime\nimport logging\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags or []\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [\n                    Task(\n                        id=item[\"id\"],\n                        title=item[\"title\"],\n                        description=item[\"description\"],\n                        created_at=datetime.fromisoformat(item[\"created_at\"]),\n                        completed=item[\"completed\"],\n                        tags=item.get(\"tags\", [])\n                    )\n                    for item in data\n                ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Failed to load tasks: {e}\")",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\nfrom collections import defaultdict\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    duration: int  # in minutes\n    dependencies: List[str] = field(default_factory=list)\n    completed: bool = False\n    \n@dataclass\nclass Project:\n    name: str\n    tasks: Dict[str, Task] = field(default_factory=dict)\n    \n    def add_task(self, task: Task) -> None:\n        if task.id in self.tasks:\n            logger.warning(f\"Task {task.id} already exists in project {self.name}\")\n            return\n        self.tasks[task.id] = task\n        logger.info(f\"Added task {task.name} to project {self.name}\")\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id not in self.tasks:\n            logger.error(f\"Task {task_id} not found in project {self.name}\")\n            return False\n        \n        task = self.tasks[task_id]\n        for dep_id in task.dependencies:\n            if not self.tasks[dep_id].completed:\n                logger.error(f\"Cannot complete task {task_id}: dependency {dep_id} not completed\")\n                return False\n                \n        task.completed = True\n        logger.info(f\"Marked task {task.name} as completed\")\n        return True\n    \n    def get_next_tasks(self) -> List[Task]:\n        \"\"\"Return tasks that can be worked on (all dependencies completed)\"\"\"\n        result = []\n        for task in self.tasks.values():\n            if task.completed:\n                continue\n                \n            dependencies_met = all(\n                self.tasks[dep_id].completed for dep_id in task.dependencies",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                        self.tasks[task_id] = Task(**task_data)\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            serialized_tasks = {}\n            for task_id, task in self.tasks.items():\n                task_dict = task.__dict__.copy()\n                task_",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n        self.save_tasks()\n        return True\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def get_all_tasks(self) -> List[Task]:\n        return list(self.tasks.values())\n    \n    def get_tasks",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_income: bool = False\n\n\nclass BudgetTracker:\n    def __init__(self, data_file: str = \"transactions.csv\"):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n\n    def _load_transactions(self) -> None:\n        if not os.path.exists(self.data_file):\n            return\n\n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.fromisoformat(row['date']),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description'],\n                    is_income=row['is_income'].lower() == 'true'\n                ))\n\n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self._save_transactions()\n\n    def _save_transactions(self) -> None:\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['date', 'amount', 'category', 'description', 'is_income'])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.isoformat(),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description,\n                    'is_income': str(t.is_income)\n                })\n\n    def get_balance(self) -> float:\n        income = sum(t.amount for t in self.transactions if t.is_income)\n        expenses = sum(",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    priority: int  # 1-5\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n    \n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n    \n    def add_task(self, title: str, description: str, priority: int, \n                due_date: datetime, tags: List[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            priority=priority,\n            due_date=due_date,\n            tags=tags\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def mark_completed(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        new_task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks.append(new_task)\n        logger.info(f\"Added task: {new_task.title} (ID: {new_task.id})\")\n        self.save_tasks()\n        return new_task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.title} (ID: {task.id})\")\n            self.save_tasks()\n        return task\n    \n    def get_task(self, task_id:",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n    BLOCKED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    status: TaskStatus\n    assigned_to: Optional[str] = None\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n    \n    def update_status(self, new_status: TaskStatus) -> None:\n        logger.info(f\"Task {self.id} status changed: {self.status} -> {new_status}\")\n        self.status = new_status\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n        \n    def add_task(self, title: str, description: str, assigned_to: Optional[str] = None) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            status=TaskStatus.TODO,\n            assigned_to=assigned_to\n        )\n        self.tasks[task.id] = task\n        self.next_id += 1\n        logger.info(f\"Added task: {task.title} (ID: {task.id})\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task in self.tasks.values() if task.status == status]\n    \n    def assign_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    description: Optional[str] = None\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"description\": self.description\n        }\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.completed = True\n                logger.info(f\"Marked task as completed: {task.name}\")\n                return True\n        logger.warning(f\"Task not found: {task_name}\")\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n    \n    def export_to_json(self, filename: str) -> None:\n        with open(filename, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n        logger.info(f\"Exported tasks to",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def get_high_priority_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= 8]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        return False\n\ndef generate_sample_tasks(count: int) -> List[Task]:\n    tasks = []\n    for i in range(1, count + 1):\n        due_date = datetime.now() + timedelta(days=random.randint(-2, 5))\n        priority = random.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self._next_id = 1\n        logger.info(\"TaskManager initialized\")\n    \n    def create_task(self, name: str, description: str) -> Task:\n        task = Task(id=self._next_id, name=name, description=description)\n        self.tasks.append(task)\n        self._next_id += 1\n        logger.info(f\"Created task: {task.name}\")\n        return task\n    \n    def assign_task(self, task_id: int, assignee: str) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            return False\n        task.assigned_to = assignee\n        task.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {task_id} assigned to {assignee}\")\n        return True\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            return False\n        task.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {task_id} marked as completed\")\n        return True\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.i",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.tasks.get(task_id)\n        if task:\n            task.complete()\n            logger.info(f\"Completed task: {task.title}\")\n            self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def get_all_tasks(self) -> List[Task]:\n        return list(self.tasks.values())\n    \n    def save_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass FruitType(Enum):\n    APPLE = auto()\n    BANANA = auto()\n    ORANGE = auto()\n    GRAPE = auto()\n    PEAR = auto()\n\n\n@dataclass\nclass Fruit:\n    type: FruitType\n    weight: float\n    price_per_kg: float\n    is_organic: bool = False\n    \n    @property\n    def price(self) -> float:\n        \"\"\"Calculate price based on weight and price per kg.\"\"\"\n        base_price = self.weight * self.price_per_kg\n        # Organic fruits cost 20% more\n        return base_price * 1.2 if self.is_organic else base_price\n\n\nclass FruitBasket:\n    def __init__(self, capacity: int = 10):\n        self.capacity = capacity\n        self.fruits: List[Fruit] = []\n    \n    def add_fruit(self, fruit: Fruit) -> bool:\n        if len(self.fruits) >= self.capacity:\n            logger.warning(\"Basket is full, cannot add more fruits\")\n            return False\n        self.fruits.append(fruit)\n        logger.info(f\"Added {fruit.type.name} to basket\")\n        return True\n    \n    def remove_fruit(self, fruit_type: FruitType) -> Optional[Fruit]:\n        for i, fruit in enumerate(self.fruits):\n            if fruit.type == fruit_type:\n                return self.fruits.pop(i)\n        return None\n    \n    def total_price(self) -> float:\n        return sum(fruit.price for fruit in self.fruits)\n    \n    def __str__(self) -> str:\n        return f\"Basket with {len(self.fruits)}/{self.capacity} fruits, total price",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        \n        if isinstance(self.due_date, str):\n            self.due_date = datetime.fromisoformat(self.due_date)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None, tags: List[str] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n        self.save_tasks()\n        return True\n    \n    def get_tasks_",
    "import os\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n        \n    def save_tasks(self) -> None:\n        with open(self.storage_path",
    "import json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom pathlib import Path\nimport argparse\nimport sys\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    tags: Optional[List[str]] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks = []\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, FileNotFoundError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self, task: Task):\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def list_tasks(self, completed=None):\n        if completed is None:\n            return self.tasks\n        return [task for task in self.tasks if task.complete",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task with name '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def complete_task(self, name: str) -> bool:\n        task = self.get_task(name)\n        if task:\n            task.complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in data.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({str(k): asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error",
    "import os\nimport json\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) \n                            if task_data[\"completed_at\"] else None",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict[str, Any]:\n        result = {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n        if self.due_date:\n            result[\"due_date\"] = self.due_date.isoformat()\n        return result\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, due_date: Optional[datetime] = None, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                logger.info(f\"Complete",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 3  # 1 = highest, 5 = lowest\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if not isinstance(self.created_at, datetime):\n            self.created_at = datetime.fromisoformat(self.created_at)\n    \n    def complete(self):\n        self.completed = True\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None, \n                priority: int = 3) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}_{int(datetime.now().timestamp())}\"\n        self.tasks[task_id] = Task(\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or [],\n            priority=priority\n        )\n        self._save_tasks()\n        return task_id\n    \n    def get_task(self, task_id: str) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def complete_task(self, task_id: str) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].complete()\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[str] = None\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, updating\")\n        self.tasks[task.name] = task\n        self._save_tasks()\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def delete_task(self, name: str) -> bool:\n        if name in self.tasks:\n            del self.tasks[name]\n            self._save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def _save_tasks(self) -> None:\n        data = {name: {\n            \"name\": task.name,\n            \"priority\": task.priority",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def is_overdue(self) -> bool:\n        return self.due_date < datetime.now() and not self.completed\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists and will be updated\")\n        self.tasks[task.name] = task\n        self._save_tasks()\n        \n    def remove_task(self, task_name: str) -> Optional[Task]:\n        task = self.tasks.pop(task_name, None)\n        if task:\n            self._save_tasks()\n            logger.info(f\"Task '{task_name}' removed\")\n            return task\n        logger.warning(f\"Task '{task_name}' not found\")\n        return None\n        \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_over",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"task_manager\")\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    metadata: Dict = field(default_factory=dict)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added new task: '{task.name}'\")\n        self.save_tasks()\n        \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([{\n                \"name\": t.name,\n                \"priority\": t.priority,\n                \"created_at\": t.created_at.isoformat(),\n                \"completed\": t.completed,\n                \"tags\": t.",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom pathlib import Path\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(\"inventory_manager\")\n\n@dataclass\nclass Product:\n    id: str\n    name: str\n    price: float\n    quantity: int = 0\n    categories: List[str] = field(default_factory=list)\n    \n    def is_in_stock(self) -> bool:\n        return self.quantity > 0\n    \n    def update_quantity(self, amount: int) -> None:\n        new_quantity = self.quantity + amount\n        if new_quantity < 0:\n            raise ValueError(f\"Cannot reduce quantity below zero (requested: {amount})\")\n        self.quantity = new_quantity\n        logger.info(f\"Updated quantity for {self.name} (ID: {self.id}): {self.quantity}\")\n\nclass InventoryManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.products: Dict[str, Product] = {}\n        self.storage_path = storage_path or Path(\"inventory.json\")\n    \n    def add_product(self, product: Product) -> None:\n        if product.id in self.products:\n            logger.warning(f\"Product with ID {product.id} already exists, updating\")\n        self.products[product.id] = product\n        \n    def remove_product(self, product_id: str) -> bool:\n        if product_id in self.products:\n            del self.products[product_id]\n            logger.info(f\"Removed product with ID {product_id}\")\n            return True\n        return False\n    \n    def get_low_stock_products(self, threshold: int = 5) -> List[Product]:\n        return [p for p in self.products.values() if 0 < p.quantity <= threshold]\n    \n    def save(self) ->",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists, updating instead\")\n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added task: {task.name}\")\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.error(f\"Task '{task_name}' not found\")\n            return False\n        self.tasks[task_name].completed = True\n        self._save_tasks()\n        logger.info(f\"Marked task as completed: {task_name}\")\n        return True\n    \n    def get_pending_tasks(self, tag: Optional[str] = None) -> List[Task]:\n        pending = [task for task in self.tasks.values() if not task.completed]\n        if tag:\n            pending = [task for task in pending if tag in task.tags]\n        return sorted(pending, key=lambda x: x.priority, reverse=True)\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: '{task.name}'\")\n        return True\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name not in self.tasks:\n            logger.warning(f\"Task '{task_name}' not found\")\n            return False\n        \n        del self.tasks[task_name]\n        self._save_tasks()\n        logger.info(f\"Removed task: '{task_name}'\")\n        return True\n    \n    def get_high_priority_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority > 7]\n    \n    def _",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_file = storage_file\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_file, 'w') as f:\n            tasks_dict = [\n                {\n                    \"name\": t.name,\n                    \"description\": t.description,\n                    \"completed\": t.completed,\n                    \"due_date\": t.due_date.isoformat() if t",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json_data = [\n                {\n                    \"name\": task.name,\n                    \"description\": task.description,\n                    \"completed\":",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n            \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            for task_data in tasks_data:\n                task = Task(\n                    id=task_data[\"id\"],\n                    title=task_data[\"title\"],\n                    description=task_data[\"description\"],\n                    completed=task_data[\"completed\"],\n                    tags=task_data[\"tags\"]\n                )\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    for task_id, task_dict in tasks_data.items():\n                        self.tasks[int(task_id)] = Task(**task_dict)\n            except (json.JSONDecodeError, IOError) as e:\n                print(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self):\n        tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump(tasks_dict, f, indent=2)\n        except IOError as e:\n            print(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[task_",
    "import time\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\nfrom typing import List, Dict, Callable, Any\n\n\nclass DataProcessor:\n    def __init__(self, worker_count: int = 4):\n        self.worker_count = worker_count\n        self.executor = ThreadPoolExecutor(max_workers=worker_count)\n        self.results_cache: Dict[str, Any] = {}\n    \n    def process_data(self, items: List[Any], processor_func: Callable[[Any], Any]) -> List[Any]:\n        \"\"\"Process data items in parallel and return results.\"\"\"\n        futures = []\n        results = []\n        \n        for item in items:\n            # Check cache first\n            item_key = f\"{str(item)}:{processor_func.__name__}\"\n            if item_key in self.results_cache:\n                results.append(self.results_cache[item_key])\n                continue\n                \n            # Submit to thread pool\n            futures.append((\n                self.executor.submit(processor_func, item),\n                item_key\n            ))\n        \n        # Collect results\n        for future, key in futures:\n            result = future.result()\n            self.results_cache[key] = result\n            results.append(result)\n            \n        return results\n    \n    def shutdown(self):\n        self.executor.shutdown()\n\n\ndef simulate_work(item: int) -> Dict[str, Any]:\n    \"\"\"Simulates processing work with random delay.\"\"\"\n    time.sleep(random.uniform(0.1, 0.5))\n    return {\n        \"input\": item,\n        \"squared\": item ** 2,\n        \"processed_at\": time.time()\n    }\n\n\nif __name__ == \"__main__\":\n    processor = DataProcessor(worker_count=3)\n    \n    try:\n        # First batch\n        data = list(range(10))\n        start = time.time()\n        results = processor.process_data(data, simulate_work)\n        print(f\"Processed {len(results)} items in {time.time() - start:.2f} seconds\")\n        \n        # Second batch (",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_expense: bool = True\n\n\nclass BudgetTracker:\n    def __init__(self, filename: str):\n        self.filename = filename\n        self.transactions: List[Transaction] = []\n        self.load_transactions()\n    \n    def load_transactions(self) -> None:\n        if not os.path.exists(self.filename):\n            return\n        \n        with open(self.filename, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description'],\n                    is_expense=row['is_expense'].lower() == 'true'\n                ))\n    \n    def save_transactions(self) -> None:\n        with open(self.filename, 'w', newline='') as csvfile:\n            fieldnames = ['date', 'amount', 'category', 'description', 'is_expense']\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description,\n                    'is_expense': str(t.is_expense)\n                })\n    \n    def add_transaction(self, transaction: Transaction) -> None:\n        self.transactions.append(transaction)\n        self.save_transactions()\n    \n    def get_balance(self) -> float:\n        balance = 0.0\n        for t in self.transactions:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport json\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    created_at: datetime = datetime.now()\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self):\n        return {\n            \"name\": self.name,\n            \"priority\": self.priority,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name:\n                task.completed = True\n                logger.info(f\"Marked task as completed: {task.name}\")\n                self.save_tasks()\n                return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def save_tasks(self)",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = {}\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def execute_task(self, task: Task) -> bool:\n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            dep_task = self.get_task(dep_id)\n            if not dep_task or not dep_task.completed:\n                logger.warning(f\"Cannot execute task {task.name}: dependencies not met\")\n                return False\n                \n        logger.info(f\"Executing task: {task.name} (Duration: {task.duration}s)\")\n        time.sleep(task.duration)  # Simulate task execution\n        task.completed = True\n        logger.info(f\"Completed task: {task.name}\")\n        return True\n    \n    def execute_all(self, max_workers: int = 3) -> None:\n        with ThreadPoolExecutor(max_workers=max_workers) as executor:\n            while not all(task.completed for task in self.tasks.values()):\n                for task in self.tasks.values():\n                    if not task.",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            \n    def complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = Path(storage_path)\n        self.load_tasks()\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def complete_task(self, task_name: str) -> bool:\n        for task in self.tasks:\n            if task.name == task_name and not task.completed:\n                task.complete()\n                logger.info(f\"Completed task: {task.name}\")\n                self.save_tasks()\n                return True\n        return False\n    \n    def save_tasks(self) -> None:\n        tasks_dict = [\n            {\n                \"name",
    "import json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nimport os\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {title} (ID: {task_id})\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task ID {task_id} not found\")\n            return False\n        \n        self.tasks[task_id].completed = True\n        logger.info(f\"Completed task: {self.tasks[task_id].title} (ID: {",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1-5, 5 being highest\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    task_dict = json.load(f)\n                    for task_id, task_data in task_dict.items():\n                        task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n\n    def _save_tasks(self) -> None:\n        task_dict = {}\n        for task_id, task in self.tasks.items():\n            task_dict[task_id] = {\n                \"name\": task.name,\n                \"description\": task.description,\n                \"completed\": task.completed,\n                \"created_at\": task.created_at.isoformat(),\n                \"tags\": task.tags,\n                \"priority\": task.priority\n            }\n        with open(self.storage_path, \"w\") as f:\n            json.dump(task_dict, f, indent=2)\n\n    def add_task(self, task: Task) -> str:\n        task_id = f\"task_{len(self.tasks) + 1}\"\n        self.tasks[task_",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field, asdict\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    priority: int = 1\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n    \n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].complete()\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        now = datetime.now()\n        return [\n            task for task in self.tasks.values() \n            if task.due_date and not task.completed and task.due_date < now\n        ]\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            tasks_dict = {\n                name: {**asdict(task), 'created_at': task.created_at.isoformat(), \n                      'due_date': task.due_date.isoformat() if task.due_date else None}\n                for name, task in self.tasks.items()",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def is_overdue(self) -> bool:\n        if not self.due_date or self.completed:\n            return False\n        return datetime.now() > self.due_date\n    \n    def complete(self) -> None:\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n    \n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            logger.info(f\"Removed task: {task_name}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def save_tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No existing tasks file found, starting with empty task list\")\n    \n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(\"Tasks saved to storage\")\n        except Exception as e:\n            logger.error(f",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional, Dict\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return asdict(self)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    self.tasks = {\n                        task_id: Task(**task_data)\n                        for task_id, task_data in tasks_data.items()\n                    }\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                tasks_dict = {\n                    task_id: task.to_dict() \n                    for task_id, task in self.tasks.items()\n                }\n                json.dump(tasks_dict, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)}",
    "import logging\nimport random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport time\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.results = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task ID {task_id} not found\")\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                logger.warning(f\"Dependency {dep_id} not completed for task {task_id}\")\n                return None\n        \n        logger.info(f\"Processing task: {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        result = f\"Result of {task.name} (priority: {task.priority})\"\n        logger.info(f\"Completed task: {task.name}\")\n        return result\n    \n    def run_all(self) -> dict:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime\nimport json\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            'id': self.id,\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'tags': self.tags or []\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Task':\n        return cls(\n            id=data['id'],\n            title=data['title'],\n            description=data['description'],\n            created_at=datetime.fromisoformat(data['created_at']),\n            completed=data['completed'],\n            tags=data['tags']\n        )\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}, creating new task list\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task.from_dict(task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[datetime] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        \n        if isinstance(self.created_at, str):\n            self.created_at = datetime.fromisoformat(self.created_at)\n            \n        if isinstance(self.due_date, str) and self.due_date:\n            self.due_date = datetime.fromisoformat(self.due_date)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    for task_dict in tasks_data:\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks.values()], f, default=str)",
    "import os\nimport json\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n                    self.next_id = max(self.next_id, task.id + 1)\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def _save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks.values()], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def add_task(self, title: str, description: str, priority: int, tags: List",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, assignee: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task {self.id}: not in PENDING state\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = assignee\n        logger.info(f\"Task {self.id} started by {assignee}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task {self.id}: not in IN_PROGRESS state\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.error(f\"Task {self.id} failed: {reason}\")\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created new task: {task.name} (ID: {task.i",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def complete(self) -> None:\n        self.completed = True\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime, \n                 tags: Optional[List[str]] = None) -> Task:\n        task = Task(id=self.next_id, title=title, description=description, \n                    due_date=due_date, tags=tags)\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def delete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            self.tasks.remove(task)\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n\n    def get_tasks_by",
    "import csv\nimport os\nfrom collections import defaultdict\nfrom datetime import datetime\nfrom typing import Dict, List, Tuple\n\n\nclass SalesAnalyzer:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.sales_data = []\n        self.load_data()\n\n    def load_data(self) -> None:\n        if not os.path.exists(self.data_file):\n            raise FileNotFoundError(f\"Data file {self.data_file} not found\")\n        \n        with open(self.data_file, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            self.sales_data = list(reader)\n    \n    def get_monthly_sales(self) -> Dict[str, float]:\n        monthly_sales = defaultdict(float)\n        \n        for record in self.sales_data:\n            try:\n                date = datetime.strptime(record['date'], '%Y-%m-%d')\n                month_key = date.strftime('%Y-%m')\n                monthly_sales[month_key] += float(record['amount'])\n            except (ValueError, KeyError) as e:\n                print(f\"Error processing record: {record}, Error: {e}\")\n        \n        return dict(monthly_sales)\n    \n    def get_top_products(self, limit: int = 5) -> List[Tuple[str, float]]:\n        product_sales = defaultdict(float)\n        \n        for record in self.sales_data:\n            try:\n                product_sales[record['product']] += float(record['amount'])\n            except (KeyError, ValueError):\n                continue\n        \n        sorted_products = sorted(\n            product_sales.items(), \n            key=lambda x: x[1], \n            reverse=True\n        )\n        \n        return sorted_products[:limit]\n\n\nif __name__ == \"__main__\":\n    # Create sample data file if it doesn't exist\n    if not os.path.exists(\"sales.csv\"):\n        with open(\"sales.csv\", \"w\", newline=\"\")",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom pathlib import Path\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks.append(task)\n        logger.info(f\"Task created: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Task completed: {task.title}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nimport json\nfrom pathlib import Path\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    tags: List[str] = None\n    due_date: Optional[str] = None\n    \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"tags\": self.tags or [],\n            \"due_date\": self.due_date\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([task.to_dict() for task in self.tasks], f, indent=2)",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_dict = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in tasks_dict.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except (json.JSONDecodeError, KeyError) as e:\n                logger.error(f\"Error loading tasks: {e}\")\n                self.tasks = {}\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                tasks_dict = {str(k): asdict(v) for k, v in self.tasks.items()}\n                json.dump(tasks_dict, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n            return True\n        except Exception as e:\n            logger",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                self.tasks = {\n                    task_id: Task(**task_data) \n                    for task_id, task_data in tasks_data.items()\n                }\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, IOError) as e:\n            logger.error(f\"Failed to load tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump(\n                    {task_id: asdict(task",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, with 5 being highest priority\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n\n    def complete_task(self, task_id: int) -> bool:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.completed = True\n                self.save_tasks()\n                return True\n        return False\n\n    def get_pending_tasks(self) -> List[Task]:\n        return sorted(\n            [task for task in self.tasks if not task.completed],\n            key=lambda x: x.priority,\n            reverse=True,\n        )\n\n    def _generate_id(self) -> int:\n        existing_ids = {task.id for task in self.tasks}\n        new_id = random.randint(1000, 9999)\n        while new_id in existing_ids:\n            new_id = random.randint(1000, 9999)\n        return new_id\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, \"w\") as f:\n            json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n\n    def load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            self.tasks = []",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                for task_dict in tasks_data:\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except json.JSONDecodeError:\n            logger.error(\"Failed to parse tasks file\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self):\n        try:\n            with open(self.storage_path, \"w\") as f:\n                tasks_list = [task.__dict__ for task in self.tasks.values()]\n                json.dump(tasks_list, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n\n    def ad",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def start(self, assignee: str) -> None:\n        if self.status != TaskStatus.PENDING:\n            raise ValueError(f\"Cannot start task with status {self.status}\")\n        self.status = TaskStatus.IN_PROGRESS\n        self.assigned_to = assignee\n        logger.info(f\"Task {self.id} started by {assignee}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed by {self.assigned_to}\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n        return task\n    \n    def",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def to_dict(self) -> Dict:\n        return {\n            'name': self.name,\n            'description': self.description,\n            'priority': self.priority,\n            'completed': self.completed,\n            'created_at': self.created_at.isoformat(),\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None,\n            'tags': self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                for task_data in tasks_data:\n                    task = Task(\n                        name=task_data['name'],\n                        description=task_data['description'],\n                        priority=task_data['priority'],\n                        completed=task_data['completed'],",
    "import logging\nimport os\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskScheduler:\n    def __init__(self, max_workers: int = 3):\n        self.tasks = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def can_execute(self, task: Task) -> bool:\n        if task.completed:\n            return False\n        \n        for dep_id in task.dependencies:\n            if dep_id not in self.tasks or not self.tasks[dep_id].completed:\n                return False\n        return True\n    \n    def execute_task(self, task: Task) -> None:\n        logger.info(f\"Starting task: {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        task.completed = True\n        logger.info(f\"Completed task: {task.name} (ID: {task.id})\")\n        \n    def run(self) -> None:\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while not all(task.completed for task in self.tasks.values()):\n                futures = []\n                for task in self.tasks.values():\n                    if self.can_execute(task) and not task.completed:\n                        futures.appen",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self._next_id = 1\n    \n    def add_task(self, name: str, priority: int, \n                due_date: datetime, tags: Optional[List[str]] = None) -> Task:\n        task = Task(\n            id=self._next_id,\n            name=name,\n            priority=priority,\n            due_date=due_date,\n            tags=tags\n        )\n        self.tasks[task.id] = task\n        self._next_id += 1\n        logger.info(f\"Added task: {task.name}\")\n        return task\n    \n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if task.is_overdue()]\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in (task.tags or [])]\n\n\nif __name__ == \"__main__\":\n    manager = TaskManager()\n    \n    #",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int = 1\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        self._save_tasks()\n        logger.info(f\"Added new task: {task.name}\")\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def list_tasks(self, completed: Optional[bool] = None) -> List[Task]:\n        if completed is None:\n            return list(self.tasks.values())\n        return [task for task in self.tasks.values() if task.completed == completed]\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json_data",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name} with priority {task.priority}\")\n    \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task_by_id(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.name}\")\n            return True\n        return False\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= threshold]\n\ndef process_task(task: Task) -> str:\n    # Simulate processing time\n    processing_time = random.uniform(0.1, 0.5)\n    import time\n    time.sleep(processing_time)\n    return f\"Processed task {task.id}: {task.name} (priority: {task.priority})\"\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    for i in range(10",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    status: TaskStatus = TaskStatus.PENDING\n    assigned_to: Optional[str] = None\n    \n    def assign(self, person: str) -> None:\n        self.assigned_to = person\n        self.status = TaskStatus.IN_PROGRESS\n        logger.info(f\"Task {self.id} assigned to {person}\")\n    \n    def complete(self) -> None:\n        if self.status != TaskStatus.IN_PROGRESS:\n            raise ValueError(f\"Cannot complete task with status {self.status}\")\n        self.status = TaskStatus.COMPLETED\n        logger.info(f\"Task {self.id} completed\")\n    \n    def fail(self, reason: str) -> None:\n        self.status = TaskStatus.FAILED\n        logger.warning(f\"Task {self.id} failed: {reason}\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n    \n    def create_task(self, name: str, description: str) -> Task:\n        task = Task(id=self.next_id, name=name, description=description)\n        self.tasks.append(task)\n        self.next_id += 1\n        logger.info(f\"Created task: {task.name}\")\n        return task\n    \n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.status == TaskStatus.PENDING]\n    \n    def get_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    priority: int\n    completed: bool = False\n    \n    def is_overdue(self) -> bool:\n        return not self.completed and self.due_date < datetime.now()\n    \n    def __str__(self) -> str:\n        status = \"Completed\" if self.completed else \"Pending\"\n        return f\"Task {self.id}: {self.title} ({status}) - Due: {self.due_date.strftime('%Y-%m-%d')}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self._next_id = 1\n        \n    def add_task(self, title: str, description: str, due_date: datetime, priority: int) -> Task:\n        task = Task(\n            id=self._next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            priority=priority\n        )\n        self.tasks.append(task)\n        self._next_id += 1\n        logger.info(f\"Added task: {task.title}\")\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = None\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as complete\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                for task_dict in tasks_data:\n                    # Convert ISO format string back to datetime\n                    if task_dict.get('created_at'):\n                        task_dict['created_at'] = datetime.fromisoformat(task_dict['created_at'])\n                    self.tasks.append(Task(**task_dict))\n                \n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport random\nfrom collections import defaultdict\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Product:\n    id: int\n    name: str\n    price: float\n    category: str\n    in_stock: bool = True\n    \n    def __post_init__(self):\n        self.price = round(self.price, 2)\n    \n    def display_info(self) -> str:\n        status = \"In Stock\" if self.in_stock else \"Out of Stock\"\n        return f\"{self.name} (${self.price}) - {status}\"\n\n\nclass Inventory:\n    def __init__(self):\n        self.products: List[Product] = []\n        self.categories: Dict[str, List[Product]] = defaultdict(list)\n        \n    def add_product(self, product: Product) -> None:\n        self.products.append(product)\n        self.categories[product.category].append(product)\n        logger.info(f\"Added product: {product.name}\")\n        \n    def find_product(self, product_id: int) -> Optional[Product]:\n        for product in self.products:\n            if product.id == product_id:\n                return product\n        return None\n    \n    def get_by_category(self, category: str) -> List[Product]:\n        return self.categories.get(category, [])\n    \n    def get_total_value(self) -> float:\n        return round(sum(p.price for p in self.products if p.in_stock), 2)\n\n\ndef main():\n    inventory = Inventory()\n    \n    # Create some sample products\n    categories = [\"Electronics\", \"Books\", \"Clothing\", \"Food\"]\n    names = [\"Laptop\", \"Smartphone\", \"Headphones\", \"Novel\", \"T-shirt\", \"Jeans\", \"Chocolate\", \"Coffee\"]",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return next((task for task in self.tasks if task.id == task_id), None)\n    \n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.complete()\n            return True\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return False\n    \n    @property\n    def pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    @property\n    def completed_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.completed]\n\n\n@lru_cache(maxsize=128)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    for i in range(1, 6):\n        priority = random.randint(1, 10)\n        manager",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"Storage file not found at {self.storage_path}. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task = Task(\n                        id=task_dict[\"id\"],\n                        title=task_dict[\"title\"],\n                        description=task_dict[\"description\"],\n                        completed=task_dict[\"completed\"],\n                        created_at=datetime.fromisoformat(task_dict[\"created_at\"]),",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.tasks: List[Task] = []\n        self.storage_path = storage_path\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                task.complete()\n                logger.info(f\"Completed task: {task.title}\")\n                self.save_tasks()\n                return task\n        logger.",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                        if task_data[\"completed_at\"]:\n                            task_data[\"completed_at\"] = datetime.fromisoformat(task_data[\"completed_at\"])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, IOError) as e:\n                print(f\"Error loading tasks: {e}\")\n\n    def _save_tasks(self) -> None:\n        try:\n            serialized_tasks = {}\n            for task_id, task in self.tasks.items():\n                task_dict = asdict(task)\n                task_dict[\"created_at\"] = task.created_at.isoformat()\n                if task.completed_at:\n                    task_",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n    priority: int = 1  # 1=low, 2=medium, 3=high\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        \n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n    \n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags,\n            \"priority\": self.priority\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n    \n    def add_task(self, title: str, description: str, due_date: datetime, \n                tags: Optional[List[str]] = None, priority: int = 1) -> Task:\n        task = Task(\n            id=self.next_id,\n            title=title,\n            description=description,\n            due_date=due_date,\n            tags=tags,\n            priority=priority\n        )\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def update_task(self, task_id: int, **kwargs) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            return False\n        \n        for key, value",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, 'r') as f:\n                try:\n                    tasks_dict = json.load(f)\n                    for task_id, task_data in tasks_dict.items():\n                        self.tasks[int(task_id)] = Task(**task_data)\n                except json.JSONDecodeError:\n                    print(\"Error loading tasks, starting with empty list\")\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            tasks_dict = {str(task_id): asdict(task) for task_id, task in self.tasks.items()}\n            json.dump(tasks_dict, f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n    \n    def complete_task(self, task",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime, timedelta\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def days_remaining(self) -> int:\n        if self.completed:\n            return 0\n        delta = self.due_date - datetime.now()\n        return max(0, delta.days)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n\n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n\n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_dict in data:\n                    task_dict[\"due_date\"] = datetime.fromisoformat(task_dict[\"due_date\"])\n                    self.tasks[task_dict[\"id\"]] = Task(**task_dict)\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n\n    def save_tasks(self) -> None:\n        try:\n            with open(self.",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path=\"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, name: str, description: str) -> Task:\n        task = Task(name=name, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, index: int) -> Optional[Task]:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].complete()\n            self.save_tasks()\n            return self.tasks[index]\n        return None\n    \n    def delete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            del self.tasks[index]\n            self.save_tasks()\n            return True\n        return False\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n    \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, name: str, description: str, priority: int, tags: Optional[List[str]] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task with name '{name}' already exists\")\n        \n        task = Task(name=name, description=description, priority=priority, tags=tags or [])\n        self.tasks[name] = task\n        self.save_tasks()\n        return task\n\n    def complete_task(self, name: str) -> None:\n        if name not in self.tasks:\n            raise ValueError(f\"Task with name '{name}' does not exist\")\n        \n        self.tasks[name].completed = True\n        self.save_tasks()\n\n    def get_tasks_by_priority(self, min_priority: int = 0) -> List[Task]:\n        return sorted(\n            [task for task in self.tasks.values() if task.priority >= min_priority],\n            key=lambda x: x.priority,\n            reverse=True\n        )\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump({\n                name: {\n                    **vars(task),\n                    'created_at': task.created_at.isoformat()",
    "import os\nimport json\nimport logging\nfrom datetime import datetime\nfrom dataclasses import dataclass, field, asdict\nfrom typing import List, Dict, Optional\nimport argparse\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    priority: int = 1  # 1 (low) to 5 (high)\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n    \n    def get_high_priority_tasks(self, min_priority: int = 4) -> List[Task]:\n        return [task for task in self.tasks if task.priority >= min_priority]\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_file):\n            logger.warning(f\"Storage file {self.storage_file} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_file, 'r') as f:\n                data = json.load(f)\n                \n            self",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict, Any\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    result: Any = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 4):\n        self.tasks: Dict[int, Task] = {}\n        self.max_workers = max_workers\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Any:\n        task = self.tasks[task_id]\n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        # Simulate result\n        result = f\"Result of {task.name}: {random.randint(1, 100)}\"\n        task.result = result\n        \n        logger.info(f\"Completed task {task.name} (ID: {task.id})\")\n        return result\n        \n    def execute_workflow(self) -> Dict[int, Any]:\n        results = {}\n        processed_tasks = set()\n        \n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(processed_tasks) < len(self.tasks):\n                eligible_tasks = []\n                \n                for task_id, task in self.tasks.items():\n                    if task_id not in processed_tasks and all(dep in processed_tasks for dep in task.dependencies):",
    "import os\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Union\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Dict] = self._load_tasks()\n        \n    def _load_tasks(self) -> Dict:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    return json.load(f)\n            except json.JSONDecodeError:\n                logger.error(f\"Failed to parse {self.storage_path}\")\n                return {}\n        return {}\n    \n    def _save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump(self.tasks, f, indent=2)\n        \n    def add_task(self, task_id: str, description: str, due_date: Optional[str] = None) -> bool:\n        if task_id in self.tasks:\n            logger.warning(f\"Task {task_id} already exists\")\n            return False\n            \n        self.tasks[task_id] = {\n            \"description\": description,\n            \"created_at\": datetime.now().isoformat(),\n            \"due_date\": due_date,\n            \"completed\": False\n        }\n        self._save_tasks()\n        logger.info(f\"Added task {task_id}\")\n        return True\n        \n    def complete_task(self, task_id: str) -> bool:\n        if task_id not in self.tasks:\n            logger.warning(f\"Task {task_id} not found\")\n            return False\n            \n        self.tasks[task_id][\"completed\"] = True\n        self.tasks[",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    completed: bool = False\n    description: Optional[str] = None\n    \n    def mark_completed(self):\n        self.completed = True\n        return self\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def save(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n            return True\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n            return False\n    \n    def add_task(self, title: str, description: Optional[str] = None) -> Task:\n        next_id = max([t.id for t in self.tasks], default=0) + 1\n        task = Task(id=",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nimport json\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if not os.path.exists(self.storage_path):\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                tasks_data = json.load(f)\n                \n            self.tasks = [\n                Task(\n                    id=t[\"id\"],\n                    title=t[\"title\"],\n                    description=t[\"description\"],\n                    completed=t[\"completed\"],\n                    created_at=datetime.fromisoformat(t[\"created_at\"]),\n                    tags=t.get(\"tags\", [])\n                )\n                for t in tasks_data\n            ]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileInfo:\n    path: str\n    size: int\n    extension: str\n    modified_time: float\n    \n    @property\n    def is_large(self) -> bool:\n        return self.size > 1_000_000  # Files larger than 1MB\n    \n    def __str__(self) -> str:\n        return f\"{os.path.basename(self.path)} ({self.size / 1024:.1f} KB)\"\n\nclass FileAnalyzer:\n    def __init__(self, root_dir: str, extensions: Optional[List[str]] = None):\n        self.root_dir = os.path.abspath(root_dir)\n        self.extensions = extensions\n        self.files: List[FileInfo] = []\n        \n    def scan_directory(self) -> List[FileInfo]:\n        logger.info(f\"Scanning directory: {self.root_dir}\")\n        start_time = time.time()\n        \n        with ThreadPoolExecutor(max_workers=os.cpu_count()) as executor:\n            for root, _, files in os.walk(self.root_dir):\n                for file in files:\n                    executor.submit(self._process_file, root, file)\n        \n        elapsed = time.time() - start_time\n        logger.info(f\"Scan completed in {elapsed:.2f} seconds. Found {len(self.files)} files.\")\n        return self.files\n    \n    def _process_file(self, root: str, filename: str) -> None:\n        full_path = os.path.join(root, filename)\n        _, ext = os.path.splitext(filename)\n        \n        if self.extensions and ext.lower() not in self.extensions:\n            return",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = {int(k): Task(**v) for k, v in data.items()}\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump({str(k): asdict(v) for k, v in self.tasks.items()}, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: Optional[str] = None\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str = \"expenses.csv\"):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n\n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.reader(f)\n            next(reader, None)  # Skip header\n            for row in reader:\n                if len(row) >= 3:\n                    date = datetime.strptime(row[0], \"%Y-%m-%d\")\n                    amount = float(row[1])\n                    category = row[2]\n                    description = row[3] if len(row) > 3 else None\n                    self.transactions.append(\n                        Transaction(date, amount, category, description)\n                    )\n\n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_data()\n\n    def _save_data(self):\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.writer(f)\n            writer.writerow([\"Date\", \"Amount\", \"Category\", \"Description\"])\n            for t in self.transactions:\n                writer.writerow([\n                    t.date.strftime(\"%Y-%m-%d\"),\n                    t.amount,\n                    t.category,\n                    t.description or \"\"\n                ])\n\n    def get_total_by_category(self):\n        totals = {}\n        for t in self.transactions:\n            totals[t.category] = totals.get(t.category, 0) + t.amount\n        return totals\n\n\nif __name__",
    "import os\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport json\nimport logging\nfrom datetime import datetime\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat()\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict) -> 'Task':\n        data[\"created_at\"] = datetime.fromisoformat(data[\"created_at\"])\n        return cls(**data)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task.from_dict(task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.to_dict() for task in self.tasks], f, indent=2)\n        logger.",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.name} (priority: {self.priority})\"\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        return task\n        \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    @lru_cache(maxsize=32)\n    def get_priority_stats(self) -> dict:\n        if not self.tasks:\n            return {\"avg\": 0, \"max\": 0, \"min\": 0}\n        \n        priorities = [task.priority for task in self.tasks]\n        return {\n            \"avg\": sum(priorities) / len(priorities),\n            \"max\": max(priorities),\n            \"min\": min(priorities)\n        }\n    \n    def get_next_task(self) -> Optional[Task]:\n        incomplete_tasks = [t for t in",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now()\n    \n    def to_dict(self):\n        return {\n            'title': self.title,\n            'description': self.description,\n            'created_at': self.created_at.isoformat(),\n            'completed': self.completed,\n            'completed_at': self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = 'tasks.json'):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task = Task(title=title, description=description, created_at=datetime.now())\n        self.tasks.append(task)\n        self._save_tasks()\n        return task\n    \n    def get_all_tasks(self) -> List[Task]:\n        return self.tasks\n    \n    def get_incomplete_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n    \n    def complete_task(self, index: int) -> bool:\n        if 0 <= index < len(self.tasks):\n            self.tasks[index].complete()\n            self._save_tasks()\n            return True\n        return False\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_dict in tasks_data:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    self.tasks = [\n                        Task(\n                            id=item[\"id\"],\n                            title=item[\"title\"],\n                            description=item[\"description\"],\n                            completed=item[\"completed\"],\n                            created_at=datetime.fromisoformat(item[\"created_at\"]),\n                            completed_at=datetime.fromisoformat(item[\"completed_at\"]) if item[\"completed_at\"] else None\n                        )\n                        for item in data\n                    ]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Failed to load tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([\n                    {\n                        \"id\": task.id,\n                        \"title\": task.title,",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                \n                for task_dict in tasks_data:\n                    task_dict[\"created_at\"] = datetime.fromisoformat(task_dict[\"created_at\"])\n                    task = Task(**task_dict)\n                    self.tasks[task.id] = task\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n    \n    def save_tasks(self):\n        try:\n            tasks_data = []\n            for task in self.tasks.values():\n                task_dict = asdict(task)\n                task_dict[\"created_",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n                self.tasks = []\n        else:\n            logger.info(\"No task storage found, starting with empty task list\")\n    \n    def save_tasks(self):\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional, Union\nfrom dataclasses import dataclass, field, asdict\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    priority: int = 1  # 1 (low) to 5 (high)\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n    \n    def mark_complete(self) -> None:\n        self.completed = True\n    \n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    data = json.load(f)\n                    for task_id, task_data in data.items():\n                        # Convert string dates back to datetime objects\n                        if task_data.get('created_at'):\n                            task_data['created_at'] = datetime.fromisoformat(task_data['created_at'])\n                        if task_data.get('due_date'):\n                            task_data['due_date'] = datetime.fromisoformat(task_data['due_date'])\n                        self.tasks[task_id] = Task(**task_data)\n            except (json.JSONDecodeError, FileNotFoundError):\n                self.tasks = {}\n    \n    def _save_tasks(self) -> None:\n        # Convert Task objects to dictionaries for JSON serialization\n        serializable_tasks = {}\n        for task_id, task in self.tasks.items():",
    "import json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Optional\nimport logging\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        try:\n            with open(self.storage_file, \"r\") as f:\n                data = json.load(f)\n                self.tasks = [Task(**task) for task in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n        except (FileNotFoundError, json.JSONDecodeError):\n            logger.warning(f\"No valid task file found at {self.storage_file}\")\n            self.tasks = []\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_file, \"w\") as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_file}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        new_task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(new_task",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_file}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_file}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            with open(self.storage_file, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_file}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    completed: bool = False\n    description: Optional[str] = None\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task '{self.title}' marked as completed\")\n        \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] {self.id}: {self.title}\"\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self):\n        if not self.storage_path.exists():\n            logger.warning(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                self.tasks = [Task(**task_data) for task_data in data]\n            logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n        except (json.JSONDecodeError, KeyError) as e:\n            logger.error(f\"Error loading tasks: {e}\")\n            \n    def save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([task.__dict__ for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n            \n    def add_task(self, title: str,",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if not self.created_at:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n        logger.info(f\"Task {self.id} marked as completed\")\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self):\n        if os.path.exists(self.storage_file):\n            try:\n                with open(self.storage_file, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(\"No task storage found, starting with empty task list\")\n    \n    def save_tasks(self):\n        with open(self.storage_file, \"w\") as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n    \n    def add_task(self,",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    due_date: Optional[datetime] = None\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, task: Task) -> None:\n        self.tasks[task.name] = task\n        self.save_tasks()\n\n    def remove_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            del self.tasks[task_name]\n            self.save_tasks()\n            return True\n        return False\n\n    def complete_task(self, task_name: str) -> bool:\n        if task_name in self.tasks:\n            self.tasks[task_name].completed = True\n            self.save_tasks()\n            return True\n        return False\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_high_priority_tasks(self, threshold: int = 7) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= threshold]\n\n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_dict = json.load(f)\n                    for task_dict in tasks_dict:\n                        if \"due_date\" in task_dict and task_dict[\"due_date\"]:\n                            task_dict[\"due_",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\nimport json\nfrom datetime import datetime\nimport time\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    description: str\n    priority: int\n    completed: bool = False\n    created_at: datetime = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now()\n    \n    def to_dict(self) -> Dict:\n        return {\n            \"id\": self.id,\n            \"name\": self.name,\n            \"description\": self.description,\n            \"priority\": self.priority,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat()\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def add_task(self, name: str, description: str, priority: int) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, description=description, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task.name}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            logger.info(f\"Completed task: {task.name}\")\n            self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    name: str\n    completed: bool = False\n    created_at: datetime = field(default_factory=datetime.now)\n    completed_at: Optional[datetime] = None\n    tags: List[str] = field(default_factory=list)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n\n    def add_task(self, name: str, tags: List[str] = None) -> Task:\n        if name in self.tasks:\n            raise ValueError(f\"Task '{name}' already exists\")\n        \n        task = Task(name=name, tags=tags or [])\n        self.tasks[name] = task\n        self.save_tasks()\n        return task\n\n    def complete_task(self, name: str) -> Task:\n        if name not in self.tasks:\n            raise ValueError(f\"Task '{name}' not found\")\n        \n        task = self.tasks[name]\n        task.completed = True\n        task.completed_at = datetime.now()\n        self.save_tasks()\n        return task\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks.values() if not task.completed]\n\n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path, 'r') as f:\n                data = json.load(f)\n                for task_data in data:\n                    task = Task(\n                        name=task_data['name'],\n                        completed=task_data['completed'],\n                        create",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom pathlib import Path\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    priority: int = 1  # 1-5, 5 being highest\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def mark_completed(self):\n        self.completed = True\n        return self\n\n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n        return self\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = {}\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str, priority: int = 1) -> Task:\n        task_id = self._generate_id()\n        task = Task(id=task_id, title=title, description=description, priority=priority)\n        self.tasks[task_id] = task\n        self.save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def delete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            del self.tasks[task_id]\n            self.save_tasks()\n            return True\n        return False\n\n    def list_tasks(self, completed: Optional[bool] = None, tag: Optional[str] = None) -> List[Task]:\n        filtered_tasks = list(self.tasks.values())\n        \n        if completed is not None:\n            filtered_tasks = [t for t in filtered_tasks if t.completed == completed]\n            \n        if tag:\n            filtered_tasks = [t for t in filtered_tasks if tag in t.tags]",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    description: str\n    category: str\n    transaction_id: str\n\n\nclass ExpenseTracker:\n    def __init__(self, data_file: str):\n        self.data_file = data_file\n        self.transactions: List[Transaction] = []\n        self._load_data()\n    \n    def _load_data(self):\n        if not os.path.exists(self.data_file):\n            return\n        \n        with open(self.data_file, 'r', newline='') as f:\n            reader = csv.DictReader(f)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    description=row['description'],\n                    category=row['category'],\n                    transaction_id=row['transaction_id']\n                ))\n    \n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_data()\n    \n    def _save_data(self):\n        with open(self.data_file, 'w', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=[\n                'date', 'amount', 'description', 'category', 'transaction_id'\n            ])\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'description': t.description,\n                    'category': t.category,\n                    'transaction_id': t.transaction_id\n                })\n    \n    def get_by_category(self, category: str) -> List[Transaction]:\n        return [t for t in self.transactions if t.category.lower() == category.lower()]",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport logging\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def add_tag(self, tag: str) -> None:\n        if tag not in self.tags:\n            self.tags.append(tag)\n            logger.debug(f\"Added tag '{tag}' to task {self.id}\")\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: Optional[Path] = None):\n        self.tasks = []\n        self.storage_path = storage_path or Path(\"tasks.json\")\n        self.load_tasks()\n\n    def add_task(self, title: str, description: str) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        logger.info(f\"Created new task: {title}\")\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = datetime.now().isoformat()\n    completed_at: Optional[str] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No tasks file found at {self.storage_path}\")\n    \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, 'w') as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0)",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    PENDING = auto()\n    IN_PROGRESS = auto()\n    COMPLETED = auto()\n    FAILED = auto()\n\n\n@dataclass\nclass Task:\n    name: str\n    priority: int\n    status: TaskStatus = TaskStatus.PENDING\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"TaskManager initialized\")\n    \n    def add_task(self, task: Task) -> int:\n        task_id = len(self.tasks)\n        self.tasks.append(task)\n        logger.info(f\"Task '{task.name}' added with ID {task_id}\")\n        return task_id\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        if 0 <= task_id < len(self.tasks):\n            return self.tasks[task_id]\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def update_status(self, task_id: int, status: TaskStatus) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.status = status\n            logger.info(f\"Task '{task.name}' status updated to {status.name}\")\n            return True\n        return False\n    \n    def get_next_task(self) -> Optional[int]:\n        available_tasks = []\n        \n        for task_id, task in enumerate(self.tasks):\n            if task.status != TaskStatus.PENDING:\n                continue",
    "import os\nimport json\nfrom typing import Dict, List, Any, Optional\nfrom dataclasses import dataclass\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: datetime = datetime.now()\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict[str, Any]:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"completed\": self.completed,\n            \"created_at\": self.created_at.isoformat(),\n            \"completed_at\": self.completed_at.isoformat() if self.completed_at else None\n        }\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n        \n    def _load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    \n                for task_data in tasks_data:\n                    task = Task(\n                        id=task_data[\"id\"],\n                        title=task_data[\"title\"],\n                        description=task_data[\"description\"],\n                        completed=task_data[\"completed\"],\n                        created_at=datetime.fromisoformat(task_data[\"created_at\"]),\n                        completed_at=datetime.fromisoformat(task_data[\"completed_at\"]) \n                            if task_",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom abc import ABC, abstractmethod\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task {self.id}: '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"□\"\n        return f\"[{status}] Task {self.id}: {self.name} (Priority: {self.priority})\"\n\nclass TaskManager(ABC):\n    @abstractmethod\n    def add_task(self, task: Task) -> None:\n        pass\n    \n    @abstractmethod\n    def get_task(self, task_id: int) -> Optional[Task]:\n        pass\n    \n    @abstractmethod\n    def get_all_tasks(self) -> List[Task]:\n        pass\n\nclass SimpleTaskManager(TaskManager):\n    def __init__(self):\n        self.tasks = {}\n        logger.info(\"Task manager initialized\")\n    \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name}\")\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def get_all_tasks(self) -> List[Task]:\n        return list(self.tasks.values())\n    \n    def get_priority_tasks(self, min_priority: int) -> List[Task]:\n        return [task for task in self.tasks.values() if task.priority >= min_priority]\n\ndef main():\n    manager = SimpleTaskManager()\n    \n    # Create some sample tasks",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        logger.info(f\"Added task: {task.title}\")\n        self.save_tasks()\n        return task\n    \n    def complete_task(self, task_id: int) -> bool:\n        if task_id in self.tasks:\n            self.tasks[task_id].completed = True\n            logger.info(f\"Completed task: {self.tasks[task_id].title}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]\n    \n    def load_tasks(self):\n        if not os.path.exists(self.storage_path):\n            return\n        \n        try:\n            with open(self.storage_path,",
    "import argparse\nimport json\nimport os\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n\n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    data = json.load(f)\n                    for task_dict in data:\n                        task = Task(**task_dict)\n                        self.tasks[task.id] = task\n            except (json.JSONDecodeError, FileNotFoundError):\n                print(f\"Error loading tasks from {self.storage_path}\")\n\n    def _save_tasks(self):\n        with open(self.storage_path, \"w\") as f:\n            json.dump([task.__dict__ for task in self.tasks.values()], f, indent=2)\n\n    def add_task(self, title: str, description: str, tags: Optional[List[str]] = None) -> Task:\n        task_id = max(self.tasks.keys(), default=0) + 1\n        task = Task(id=task_id, title=title, description=description, tags=tags or [])\n        self.tasks[task_id] = task\n        self._save_tasks()\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n\n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:\n            for key, value",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n        if self.tags is None:\n            self.tags = []\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        \n    def save_tasks(self) -> None:\n        try:\n            with open(self.storage_path, \"w\") as f:\n                json.dump([asdict(task) for task in self.tasks], f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags: List[str] = None) ->",
    "import time\nimport random\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    priority: int\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.max_workers = max_workers\n        self.tasks = {}\n        self.results = {}\n    \n    def add_task(self, task: Task):\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> Optional[str]:\n        task = self.tasks.get(task_id)\n        if not task:\n            logger.error(f\"Task {task_id} not found\")\n            return None\n            \n        # Check if dependencies are completed\n        for dep_id in task.dependencies:\n            if dep_id not in self.results:\n                logger.warning(f\"Dependency {dep_id} not completed for task {task_id}\")\n                return None\n        \n        logger.info(f\"Processing task {task.name} (ID: {task.id})\")\n        time.sleep(task.duration)  # Simulate work\n        \n        # Simulate occasional failure\n        if random.random() < 0.1:\n            logger.error(f\"Task {task.name} failed\")\n            return None\n            \n        result = f\"Result of task {task.name}\"\n        self.results[task.id] = result\n        logger.info(f\"Completed task {task.name}\")\n        return result\n    \n    def process_all(self):\n        with ThreadPoolExecutor(max_workers=self.",
    "import logging\nimport time\nfrom functools import wraps\nfrom typing import Callable, TypeVar, Any\n\n# Set up logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nT = TypeVar('T')\n\ndef retry(max_attempts: int = 3, delay: float = 1.0):\n    \"\"\"Decorator that retries a function if it raises an exception.\"\"\"\n    def decorator(func: Callable[..., T]) -> Callable[..., T]:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> T:\n            attempts = 0\n            while attempts < max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    attempts += 1\n                    if attempts == max_attempts:\n                        logger.error(f\"Function {func.__name__} failed after {max_attempts} attempts: {e}\")\n                        raise\n                    logger.warning(f\"Attempt {attempts} failed: {e}. Retrying in {delay} seconds...\")\n                    time.sleep(delay)\n            return None  # This line should never be reached\n        return wrapper\n    return decorator\n\nclass DataProcessor:\n    def __init__(self, name: str):\n        self.name = name\n        self.data = []\n        \n    @retry(max_attempts=5, delay=0.5)\n    def fetch_data(self, source_id: int) -> list:\n        \"\"\"Simulates fetching data from an external source.\"\"\"\n        logger.info(f\"Fetching data from source {source_id}\")\n        # Simulate network issues for demonstration\n        if source_id % 3 == 0 and len(self.data) < 2:\n            raise ConnectionError(f\"Failed to connect to source {source_id}\")\n        \n        # Simulate successful data fetch\n        new_data = [f\"item_{source_id}_{i}\" for i in range(5)]\n        self.",
    "import os\nimport json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    tags: List[str] = None\n    \n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n    \n    def mark_completed(self):\n        self.completed = True\n        logger.info(f\"Task {self.id} marked as completed\")\n        \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self.load_tasks()\n        \n    def add_task(self, title: str, description: str, tags: List[str] = None) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(\n            id=task_id,\n            title=title,\n            description=description,\n            created_at=datetime.now(),\n            tags=tags or []\n        )\n        self.tasks[task_id] = task\n        self.save_tasks()\n        logger.info(f\"Added new task: {title}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    def list_tasks(self, only_active: bool = False) -> List[Task]:\n        if only_active:\n            return [task for task in self.tasks.values() if not task.completed]\n        return list(self.tasks.values())\n    \n    def save_",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Optional\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        self.next_id = 1\n\n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task = Task(id=self.next_id, name=name, priority=priority)\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_pending_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if not task.completed]\n\n    def get_highest_priority_task(self) -> Optional[Task]:\n        pending = self.get_pending_tasks()\n        if not pending:\n            return None\n        return max(pending, key=lambda x: x.priority)\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    tasks = [\n        (\"Finish project proposal\", 3),\n        (\"Reply to emails\", 2),\n        (\"Schedule team meeting\", 2),\n        (\"Review code changes\", 3),\n        (\"Update documentation\", 1),\n    ]\n    \n    for name, priority in tasks:\n        manager.add_task(name, priority)\n    \n    # Complete random tasks\n    for _ in range(2):\n        task_id = random.randint(1, len(tasks))\n        manager.complete_task(task_id)\n    \n    # Display highest priority task\n    highest = manager.get_highest_priority_task",
    "from dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    \n    def complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as completed\")\n    \n    def __str__(self):\n        status = \"✓\" if self.completed else \"✗\"\n        return f\"[{status}] ({self.priority}) {self.name}\"\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        \n    def add_task(self, name: str, priority: int = 1) -> Task:\n        task_id = len(self.tasks) + 1\n        task = Task(id=task_id, name=name, priority=priority)\n        self.tasks.append(task)\n        logger.info(f\"Added task: {task}\")\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        logger.warning(f\"Task with ID {task_id} not found\")\n        return None\n    \n    def get_highest_priority_task(self) -> Optional[Task]:\n        if not self.tasks:\n            return None\n        return max(self.tasks, key=lambda t: t.priority if not t.completed else -1)\n    \n    def display_tasks(self):\n        if not self.tasks:\n            print(\"No tasks available\")\n            return\n        \n        for task in sorted(self.tasks, key=lambda t: (t.completed, -t.priority)):\n            print(task)\n\nif __name__ == \"__main__\":\n    manager = TaskManager()",
    "import json\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Dict, List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\nclass TaskManager:\n    def __init__(self, storage_path: Path):\n        self.storage_path = storage_path\n        self.tasks: Dict[int, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"Storage file {self.storage_path} not found. Starting with empty task list.\")\n            return\n            \n        try:\n            with open(self.storage_path, 'r') as f:\n                tasks_data = json.load(f)\n                \n            for task_dict in tasks_data:\n                task = Task(**task_dict)\n                self.tasks[task.id] = task\n            logger.info(f\"Loaded {len(self.tasks)} tasks from storage\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            tasks_data = [vars(task) for task in self.tasks.values()]\n            with open(self.storage_path, 'w') as f:\n                json.dump(tasks_data, f, indent=2)\n            logger.info(f\"Saved {len(self.tasks)} tasks to storage\")\n        except Exception as e:\n            logger.error(f\"Error saving tasks: {e}\")\n    \n    def add_task(self, title: str, description: str, tags:",
    "import csv\nimport os\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Transaction:\n    date: datetime\n    amount: float\n    category: str\n    description: str\n    is_expense: bool = True\n\n\nclass BudgetTracker:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n        self.transactions: List[Transaction] = []\n        self._load_transactions()\n\n    def _load_transactions(self):\n        if not os.path.exists(self.file_path):\n            return\n        \n        with open(self.file_path, 'r', newline='') as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self.transactions.append(Transaction(\n                    date=datetime.strptime(row['date'], '%Y-%m-%d'),\n                    amount=float(row['amount']),\n                    category=row['category'],\n                    description=row['description'],\n                    is_expense=row['is_expense'].lower() == 'true'\n                ))\n\n    def add_transaction(self, transaction: Transaction):\n        self.transactions.append(transaction)\n        self._save_transactions()\n        \n    def _save_transactions(self):\n        with open(self.file_path, 'w', newline='') as csvfile:\n            fieldnames = ['date', 'amount', 'category', 'description', 'is_expense']\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n            writer.writeheader()\n            for t in self.transactions:\n                writer.writerow({\n                    'date': t.date.strftime('%Y-%m-%d'),\n                    'amount': t.amount,\n                    'category': t.category,\n                    'description': t.description,\n                    'is_expense': t.is_expense\n                })\n    \n    def get_balance(self) -> float:\n        return sum([-t.amount if t.is_expense else t.",
    "import random\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Optional\nimport time\n\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    completed: bool = False\n    dependencies: List[int] = None\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: Dict[int, Task] = {}\n        self.next_id = 1\n\n    def add_task(self, name: str, priority: int = 1, dependencies: List[int] = None) -> int:\n        task_id = self.next_id\n        self.next_id += 1\n        self.tasks[task_id] = Task(\n            id=task_id,\n            name=name,\n            priority=priority,\n            dependencies=dependencies or []\n        )\n        return task_id\n\n    def complete_task(self, task_id: int) -> bool:\n        if task_id not in self.tasks:\n            return False\n        self.tasks[task_id].completed = True\n        return True\n\n    def get_next_task(self) -> Optional[Task]:\n        available_tasks = [\n            task for task in self.tasks.values()\n            if not task.completed and all(\n                self.tasks[dep].completed \n                for dep in (task.dependencies or []) \n                if dep in self.tasks\n            )\n        ]\n        \n        if not available_tasks:\n            return None\n            \n        return max(available_tasks, key=lambda t: t.priority)\n    \n    def get_stats(self) -> Dict:\n        total = len(self.tasks)\n        completed = sum(1 for task in self.tasks.values() if task.completed)\n        return {\n            \"total\": total,\n            \"completed\": completed,\n            \"pending\": total - completed\n        }\n\n\ndef simulate_work():\n    manager = TaskManager()\n    \n    # Add some tasks with dependencies\n    task1 = manager.add_task(\"Setup project\", priority=3)\n    task2 = manager.add_task(\"Create database schema\", priority=2, dependencies=[task1",
    "import os\nimport json\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom dataclasses import dataclass, asdict\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    created_at: datetime\n    completed: bool = False\n    completed_at: Optional[datetime] = None\n    \n    def complete(self) -> None:\n        self.completed = True\n        self.completed_at = datetime.now()\n        \n    def to_dict(self) -> Dict:\n        return asdict(self)\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n        \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, \"r\") as f:\n                    tasks_data = json.load(f)\n                    \n                self.tasks = []\n                for task_dict in tasks_data:\n                    task_dict[\"created_at\"] = datetime.fromisoformat(task_dict[\"created_at\"])\n                    if task_dict[\"completed_at\"]:\n                        task_dict[\"completed_at\"] = datetime.fromisoformat(task_dict[\"completed_at\"])\n                    self.tasks.append(Task(**task_dict))\n            except (json.JSONDecodeError, KeyError) as e:\n                print(f\"Error loading tasks: {e}\")\n                self.tasks = []\n        \n    def save_tasks(self) -> None:\n        tasks_data = []\n        for task in self.tasks:\n            task_dict = task.to_dict()\n            task_dict[\"created_at\"] = task_dict[\"created_at\"].isoformat()\n            if task_dict[\"completed_at\"]:\n                task_dict[\"completed_at\"] = task_dict[\"completed_at\"].isoformat()\n            tasks_data.append(task_dict)\n            \n        with open(",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom enum import Enum, auto\n\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n\nclass TaskStatus(Enum):\n    TODO = auto()\n    IN_PROGRESS = auto()\n    DONE = auto()\n\n\n@dataclass\nclass Task:\n    title: str\n    description: str\n    status: TaskStatus = TaskStatus.TODO\n    tags: List[str] = None\n    priority: int = 1\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n        if not 1 <= self.priority <= 5:\n            raise ValueError(\"Priority must be between 1 and 5\")\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks: List[Task] = []\n        logger.info(\"TaskManager initialized\")\n\n    def add_task(self, task: Task) -> None:\n        self.tasks.append(task)\n        logger.info(f\"Task added: {task.title}\")\n\n    def get_tasks_by_status(self, status: TaskStatus) -> List[Task]:\n        return [task for task in self.tasks if task.status == status]\n\n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in task.tags]\n\n    def update_task_status(self, task_title: str, new_status: TaskStatus) -> bool:\n        for task in self.tasks:\n            if task.title == task_title:\n                task.status = new_status\n                logger.info(f\"Task '{task_title}' status updated to {new_status.name}\")\n                return True\n        logger.warning(f\"Task '{task_title}' not found\")\n        return False\n\n\ndef main():\n    manager = TaskManager()\n    \n    # Add some sample tasks\n    sample_tasks =",
    "import json\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom datetime import datetime, timedelta\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    due_date: datetime\n    completed: bool = False\n    tags: List[str] = None\n\n    def __post_init__(self):\n        if self.tags is None:\n            self.tags = []\n\n    def is_overdue(self) -> bool:\n        return not self.completed and datetime.now() > self.due_date\n\n    def to_dict(self) -> dict:\n        return {\n            \"id\": self.id,\n            \"title\": self.title,\n            \"description\": self.description,\n            \"due_date\": self.due_date.isoformat(),\n            \"completed\": self.completed,\n            \"tags\": self.tags\n        }\n\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = []\n        self.next_id = 1\n\n    def add_task(self, title: str, description: str, due_date: datetime, \n                 tags: Optional[List[str]] = None) -> Task:\n        task = Task(self.next_id, title, description, due_date, tags=tags)\n        self.tasks.append(task)\n        self.next_id += 1\n        return task\n\n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n\n    def complete_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if task:\n            task.completed = True\n            return True\n        return False\n\n    def get_overdue_tasks(self) -> List[Task]:\n        return [task for task in self.tasks if task.is_overdue()]\n\n    def filter_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks if tag in (task.tags or [])]",
    "import os\nimport json\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    name: str\n    description: str\n    due_date: Optional[datetime] = None\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    \n    def mark_complete(self):\n        self.completed = True\n        logger.info(f\"Task '{self.name}' marked as complete\")\n    \n    def add_tag(self, tag: str):\n        if tag not in self.tags:\n            self.tags.append(tag)\n\n\nclass TaskManager:\n    def __init__(self, storage_file: str = \"tasks.json\"):\n        self.storage_file = storage_file\n        self.tasks: Dict[str, Task] = {}\n        self.load_tasks()\n    \n    def add_task(self, task: Task) -> bool:\n        if task.name in self.tasks:\n            logger.warning(f\"Task '{task.name}' already exists\")\n            return False\n        \n        self.tasks[task.name] = task\n        logger.info(f\"Added new task: {task.name}\")\n        self.save_tasks()\n        return True\n    \n    def get_task(self, name: str) -> Optional[Task]:\n        return self.tasks.get(name)\n    \n    def delete_task(self, name: str) -> bool:\n        if name in self.tasks:\n            del self.tasks[name]\n            logger.info(f\"Deleted task: {name}\")\n            self.save_tasks()\n            return True\n        return False\n    \n    def get_tasks_by_tag(self, tag: str) -> List[Task]:\n        return [task for task in self.tasks.values() if tag in task.tags]",
    "import logging\nimport time\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nfrom concurrent.futures import ThreadPoolExecutor\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    priority: int\n    dependencies: List[int] = None\n    completed: bool = False\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskManager:\n    def __init__(self):\n        self.tasks = {}\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        logger.info(f\"Added task: {task.name} (ID: {task.id})\")\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        return self.tasks.get(task_id)\n    \n    @lru_cache(maxsize=128)\n    def can_execute(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if not task:\n            return False\n        \n        return all(self.tasks.get(dep_id).completed \n                   for dep_id in task.dependencies \n                   if self.tasks.get(dep_id))\n    \n    def execute_task(self, task_id: int) -> bool:\n        task = self.get_task(task_id)\n        if not task or not self.can_execute(task_id):\n            return False\n        \n        logger.info(f\"Executing task: {task.name}\")\n        # Simulate work\n        time.sleep(task.priority * 0.1)\n        task.completed = True\n        logger.info(f\"Completed task: {task.name}\")\n        return True\n    \n    def execute_all(self,",
    "import logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional\nimport random\nfrom functools import lru_cache\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Item:\n    id: int\n    name: str\n    value: float\n    category: str\n\nclass Inventory:\n    def __init__(self):\n        self.items: List[Item] = []\n    \n    def add_item(self, item: Item) -> None:\n        logger.info(f\"Adding item: {item.name}\")\n        self.items.append(item)\n    \n    def remove_item(self, item_id: int) -> Optional[Item]:\n        for i, item in enumerate(self.items):\n            if item.id == item_id:\n                logger.info(f\"Removing item: {item.name}\")\n                return self.items.pop(i)\n        logger.warning(f\"Item with ID {item_id} not found\")\n        return None\n    \n    def get_items_by_category(self, category: str) -> List[Item]:\n        return [item for item in self.items if item.category == category]\n    \n    def total_value(self) -> float:\n        return sum(item.value for item in self.items)\n\n@lru_cache(maxsize=128)\ndef fibonacci(n: int) -> int:\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\ndef main():\n    inventory = Inventory()\n    categories = [\"Electronics\", \"Books\", \"Clothing\", \"Food\"]\n    \n    # Generate random items\n    for i in range(10):\n        item = Item(\n            id=i,\n            name=f\"Item-{i}\",\n            value=random.uniform(10.0, 100.0),\n            category=random.choice(categories)\n        )\n        inventory.add_item(item",
    "import argparse\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass FileStats:\n    path: Path\n    size: int\n    extension: str\n    is_hidden: bool\n\nclass FileAnalyzer:\n    def __init__(self, directory: Path, recursive: bool = False):\n        self.directory = directory\n        self.recursive = recursive\n        self.stats: List[FileStats] = []\n    \n    def analyze(self) -> List[FileStats]:\n        logger.info(f\"Analyzing directory: {self.directory}\")\n        if not self.directory.exists():\n            logger.error(f\"Directory {self.directory} does not exist\")\n            return []\n            \n        self._process_directory(self.directory)\n        return self.stats\n    \n    def _process_directory(self, directory: Path) -> None:\n        for item in directory.iterdir():\n            if item.is_file():\n                self._add_file_stats(item)\n            elif item.is_dir() and self.recursive:\n                self._process_directory(item)\n    \n    def _add_file_stats(self, file_path: Path) -> None:\n        stats = FileStats(\n            path=file_path,\n            size=file_path.stat().st_size,\n            extension=file_path.suffix.lower(),\n            is_hidden=file_path.name.startswith('.')\n        )\n        self.stats.append(stats)\n        logger.debug(f\"Added stats for {file_path}\")\n\ndef get_extension_summary(stats: List[FileStats]) -> dict:\n    extensions = {}\n    for stat in stats:\n        ext = stat.extension or \"(no extension)\"\n        if ext not in extensions:\n            extensions[ext] = {\"count\": 0, \"total_size\": 0}\n        extensions[ext",
    "import os\nimport json\nimport logging\nfrom dataclasses import dataclass, field\nfrom typing import Dict, List, Optional\nfrom datetime import datetime\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: str\n    title: str\n    description: str\n    created_at: datetime = field(default_factory=datetime.now)\n    completed: bool = False\n    tags: List[str] = field(default_factory=list)\n    due_date: Optional[datetime] = None\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = Path(storage_path)\n        self.tasks: Dict[str, Task] = {}\n        self._load_tasks()\n    \n    def _load_tasks(self) -> None:\n        if not self.storage_path.exists():\n            logger.info(f\"No task file found at {self.storage_path}\")\n            return\n        \n        try:\n            with open(self.storage_path, \"r\") as f:\n                data = json.load(f)\n                for task_id, task_data in data.items():\n                    # Convert string dates to datetime objects\n                    if task_data.get(\"created_at\"):\n                        task_data[\"created_at\"] = datetime.fromisoformat(task_data[\"created_at\"])\n                    if task_data.get(\"due_date\"):\n                        task_data[\"due_date\"] = datetime.fromisoformat(task_data[\"due_date\"])\n                    self.tasks[task_id] = Task(**task_data)\n            logger.info(f\"Loaded {len(self.tasks)} tasks\")\n        except Exception as e:\n            logger.error(f\"Error loading tasks: {e}\")\n    \n    def _save_tasks(self) -> None:\n        try:\n            # Convert Task objects to dictionaries with",
    "import os\nimport logging\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Dict\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\nimport random\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    name: str\n    duration: float\n    dependencies: List[int] = None\n    \n    def __post_init__(self):\n        if self.dependencies is None:\n            self.dependencies = []\n\nclass TaskProcessor:\n    def __init__(self, max_workers: int = 3):\n        self.max_workers = max_workers\n        self.tasks: Dict[int, Task] = {}\n        self.completed_tasks: List[int] = []\n        \n    def add_task(self, task: Task) -> None:\n        self.tasks[task.id] = task\n        \n    def process_task(self, task_id: int) -> str:\n        task = self.tasks[task_id]\n        logger.info(f\"Starting task {task.name} (ID: {task.id})\")\n        \n        # Simulate work\n        time.sleep(task.duration)\n        \n        result = f\"Task {task.name} completed successfully\"\n        self.completed_tasks.append(task_id)\n        logger.info(result)\n        return result\n    \n    def can_process(self, task_id: int) -> bool:\n        task = self.tasks[task_id]\n        return all(dep in self.completed_tasks for dep in task.dependencies)\n    \n    def run(self) -> Dict[int, str]:\n        results = {}\n        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            while len(self.completed_tasks) < len(self.tasks):\n                eligible_tasks = [\n                    task_id for task_id in self.tasks \n                    if task_id not in self.completed_",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    completed_at: Optional[str] = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n    \n    def complete(self):\n        self.completed = True\n        self.completed_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self._load_tasks()\n    \n    def _load_tasks(self):\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                self.tasks = [Task(**task) for task in tasks_data]\n                logger.info(f\"Loaded {len(self.tasks)} tasks from {self.storage_path}\")\n            except Exception as e:\n                logger.error(f\"Error loading tasks: {e}\")\n        else:\n            logger.info(f\"No task file found at {self.storage_path}\")\n    \n    def _save_tasks(self):\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n        logger.info(f\"Saved {len(self.tasks)} tasks to {self.storage_path}\")\n    \n    def add_task(self,",
    "import os\nimport json\nfrom dataclasses import dataclass, asdict\nfrom typing import List, Dict, Optional\nfrom datetime import datetime\n\n\n@dataclass\nclass Task:\n    id: int\n    title: str\n    description: str\n    completed: bool = False\n    created_at: str = None\n    \n    def __post_init__(self):\n        if self.created_at is None:\n            self.created_at = datetime.now().isoformat()\n\n\nclass TaskManager:\n    def __init__(self, storage_path: str = \"tasks.json\"):\n        self.storage_path = storage_path\n        self.tasks: List[Task] = []\n        self.load_tasks()\n    \n    def load_tasks(self) -> None:\n        if os.path.exists(self.storage_path):\n            try:\n                with open(self.storage_path, 'r') as f:\n                    tasks_data = json.load(f)\n                    self.tasks = [Task(**task) for task in tasks_data]\n            except (json.JSONDecodeError, FileNotFoundError):\n                self.tasks = []\n    \n    def save_tasks(self) -> None:\n        with open(self.storage_path, 'w') as f:\n            json.dump([asdict(task) for task in self.tasks], f, indent=2)\n    \n    def add_task(self, title: str, description: str) -> Task:\n        task_id = max([task.id for task in self.tasks], default=0) + 1\n        task = Task(id=task_id, title=title, description=description)\n        self.tasks.append(task)\n        self.save_tasks()\n        return task\n    \n    def get_task(self, task_id: int) -> Optional[Task]:\n        for task in self.tasks:\n            if task.id == task_id:\n                return task\n        return None\n    \n    def update_task(self, task_id: int, **kwargs) -> Optional[Task]:\n        task = self.get_task(task_id)\n        if task:"
  ],
  "metadata": {
    "num_examples": 1000,
    "generated_at": "2025-06-02 05:19:06",
    "model_used": "claude-3-7-sonnet-20250219"
  }
}